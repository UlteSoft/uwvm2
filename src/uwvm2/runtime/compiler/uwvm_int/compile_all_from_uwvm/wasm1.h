/*************************************************************
 * Ultimate WebAssembly Virtual Machine (Version 2)          *
 * Copyright (c) 2025-present UlteSoft. All rights reserved. *
 * Licensed under the APL-2.0 License (see LICENSE file).    *
 *************************************************************/

/**
 * @author      MacroModel
 * @version     2.0.0
 * @copyright   APL-2.0 License
 */

/****************************************
 *  _   _ __        ____     __ __  __  *
 * | | | |\ \      / /\ \   / /|  \/  | *
 * | | | | \ \ /\ / /  \ \ / / | |\/| | *
 * | |_| |  \ V  V /    \ V /  | |  | | *
 *  \___/    \_/\_/      \_/   |_|  |_| *
 *                                      *
 ****************************************/

#pragma once

#ifndef UWVM_MODULE
// std
# include <array>
# include <bit>
# include <cstddef>
# include <cstdint>
# include <cstring>
# include <limits>
# include <memory>
# include <utility>
# include <type_traits>
// macro
# include <uwvm2/utils/macro/push_macros.h>
// import
# include <fast_io.h>
# include <uwvm2/utils/intrinsics/impl.h>
# include <uwvm2/utils/container/impl.h>
# include <uwvm2/parser/wasm/base/impl.h>
# include <uwvm2/parser/wasm/standard/wasm1/impl.h>
# include <uwvm2/validation/error/impl.h>
# include <uwvm2/object/impl.h>
# include <uwvm2/uwvm/io/impl.h>
# include <uwvm2/uwvm/wasm/feature/impl.h>
# include <uwvm2/uwvm/wasm/type/impl.h>
# include <uwvm2/uwvm/runtime/storage/impl.h>
# include <uwvm2/runtime/compiler/uwvm_int/optable/impl.h>
#endif

#ifndef UWVM_MODULE_EXPORT
# define UWVM_MODULE_EXPORT
#endif

UWVM_MODULE_EXPORT namespace uwvm2::runtime::compiler::uwvm_int::compile_all_from_uwvm
{
    namespace details
    {
        using wasm_i32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32;
        using wasm_i64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64;
        using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;
        using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;
        using wasm_v128 = ::uwvm2::parser::wasm::standard::wasm1p1::type::wasm_v128;

        using wasm_stack_top_i32_with_f32_u = ::uwvm2::runtime::compiler::uwvm_int::optable::wasm_stack_top_i32_with_f32_u;
        using wasm_stack_top_i32_with_i64_u = ::uwvm2::runtime::compiler::uwvm_int::optable::wasm_stack_top_i32_with_i64_u;
        using wasm_stack_top_i32_i64_f32_f64_u = ::uwvm2::runtime::compiler::uwvm_int::optable::wasm_stack_top_i32_i64_f32_f64_u;

        using trivial_call_inline_kind = ::uwvm2::runtime::compiler::uwvm_int::optable::trivial_defined_call_kind;

        struct trivial_call_inline_match
        {
            trivial_call_inline_kind kind{};
            wasm_i32 imm{};   // used by *_const_i32 patterns
            wasm_i32 imm2{};  // used by mul_add_const_i32
        };

        [[nodiscard]] UWVM_ALWAYS_INLINE inline trivial_call_inline_match
            match_trivial_call_inline_body(::uwvm2::uwvm::runtime::storage::wasm_binfmt1_final_wasm_code_t const* code_ptr) noexcept
        {
            using wasm1_code = ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code;

            trivial_call_inline_match res{};
            if(code_ptr == nullptr) { return res; }

            auto const* curr{reinterpret_cast<::std::byte const*>(code_ptr->body.expr_begin)};
            auto const* const end{reinterpret_cast<::std::byte const*>(code_ptr->body.code_end)};

            auto const read_op{[&](wasm1_code& out) noexcept -> bool
                               {
                                   if(curr == end) { return false; }
                                   ::std::memcpy(::std::addressof(out), curr, sizeof(out));
                                   ++curr;
                                   return true;
                               }};

            auto const read_u32_leb{[&](::std::uint32_t& out) noexcept -> bool
                                    {
                                        ::std::uint32_t v{};
                                        ::std::uint32_t shift{};
                                        for(::std::size_t i{}; i != 5uz; ++i)
                                        {
                                            if(curr == end) { return false; }
                                            auto const byte{::std::to_integer<::std::uint8_t>(*curr)};
                                            ++curr;
                                            v |= (static_cast<::std::uint32_t>(byte & 0x7fu) << shift);
                                            if((byte & 0x80u) == 0u)
                                            {
                                                out = v;
                                                return true;
                                            }
                                            shift += 7u;
                                        }
                                        return false;
                                    }};

            auto const read_i32_leb{[&](wasm_i32& out) noexcept -> bool
                                    {
                                        ::std::int32_t v{};
                                        ::std::uint32_t shift{};
                                        ::std::uint8_t byte{};
                                        for(::std::size_t i{}; i != 5uz; ++i)
                                        {
                                            if(curr == end) { return false; }
                                            byte = ::std::to_integer<::std::uint8_t>(*curr);
                                            ++curr;
                                            v |= (static_cast<::std::int32_t>(byte & 0x7fu) << shift);
                                            shift += 7u;
                                            if((byte & 0x80u) == 0u)
                                            {
                                                if(shift < 32u && (byte & 0x40u)) { v |= (-1) << shift; }
                                                out = static_cast<wasm_i32>(v);
                                                return true;
                                            }
                                        }
                                        return false;
                                    }};

            wasm1_code op0{};
            if(!read_op(op0) || op0 != wasm1_code::local_get) { return res; }
            ::std::uint32_t idx0{};
            if(!read_u32_leb(idx0)) { return res; }

            wasm1_code op1{};
            if(!read_op(op1)) { return res; }
            if(op1 == wasm1_code::end && curr == end)
            {
                if(idx0 == 0u)
                {
                    res.kind = trivial_call_inline_kind::param0_i32;
                    return res;
                }
                return res;
            }

            // Pattern C': local.get 1 ; i32.const IMM ; i32.xor ; local.get 0 ; i32.add ; end
            // This is semantically equivalent to Pattern C (param0 + (param1 ^ IMM)), but uses a different stack order.
            if(op1 == wasm1_code::i32_const)
            {
                // Pattern A': local.get 0 ; i32.const IMM ; i32.add ; end
                // Pattern B': local.get 0 ; i32.const MUL ; i32.mul ; i32.const ADD ; i32.add ; end
                if(idx0 == 0u)
                {
                    wasm_i32 imm0;  // no init
                    if(!read_i32_leb(imm0)) { return res; }

                    wasm1_code op2{};
                    if(!read_op(op2)) { return res; }

                    if(op2 == wasm1_code::i32_add)
                    {
                        wasm1_code op3{};
                        if(!read_op(op3) || op3 != wasm1_code::end) { return res; }
                        if(curr != end) { return res; }

                        res.kind = trivial_call_inline_kind::add_const_i32;
                        res.imm = imm0;
                        return res;
                    }
                    else if(op2 == wasm1_code::i32_mul)
                    {
                        wasm1_code op3{};
                        if(!read_op(op3) || op3 != wasm1_code::i32_const) { return res; }
                        wasm_i32 imm1;  // no init
                        if(!read_i32_leb(imm1)) { return res; }

                        wasm1_code op4{};
                        wasm1_code op5{};
                        if(!read_op(op4) || op4 != wasm1_code::i32_add) { return res; }
                        if(!read_op(op5) || op5 != wasm1_code::end) { return res; }
                        if(curr != end) { return res; }

                        res.kind = trivial_call_inline_kind::mul_add_const_i32;
                        res.imm = imm0;
                        res.imm2 = imm1;
                        return res;
                    }

                    return res;
                }

                if(idx0 != 1u) { return res; }

                wasm_i32 imm;  // no init
                if(!read_i32_leb(imm)) { return res; }

                wasm1_code op2{};
                if(!read_op(op2) || op2 != wasm1_code::i32_xor) { return res; }

                wasm1_code op3{};
                if(!read_op(op3) || op3 != wasm1_code::local_get) { return res; }
                ::std::uint32_t idx1{};
                if(!read_u32_leb(idx1) || idx1 != 0u) { return res; }

                wasm1_code op4{};
                wasm1_code op5{};
                if(!read_op(op4) || op4 != wasm1_code::i32_add) { return res; }
                if(!read_op(op5) || op5 != wasm1_code::end) { return res; }
                if(curr != end) { return res; }

                res.kind = trivial_call_inline_kind::xor_add_const_i32;
                res.imm = imm;
                return res;
            }

            if(op1 != wasm1_code::local_get) { return res; }
            ::std::uint32_t idx1{};
            if(!read_u32_leb(idx1)) { return res; }

            wasm1_code op2{};
            if(!read_op(op2)) { return res; }

            if(op2 == wasm1_code::i32_add)
            {
                // Pattern E: sum8 xor const
                // local.get 0 ; local.get 1 ; i32.add ;
                // local.get 2 ; local.get 3 ; i32.add ; i32.add ;
                // local.get 4 ; local.get 5 ; i32.add ;
                // local.get 6 ; local.get 7 ; i32.add ; i32.add ; i32.add ;
                // i32.const IMM ; i32.xor ; end
                if(idx0 == 0u && idx1 == 1u)
                {
                    wasm1_code op3{};
                    if(!read_op(op3) || op3 != wasm1_code::local_get) { return res; }
                    ::std::uint32_t idx2{};
                    if(!read_u32_leb(idx2) || idx2 != 2u) { return res; }

                    wasm1_code op4{};
                    if(!read_op(op4) || op4 != wasm1_code::local_get) { return res; }
                    ::std::uint32_t idx3{};
                    if(!read_u32_leb(idx3) || idx3 != 3u) { return res; }

                    wasm1_code op5{};
                    wasm1_code op6{};
                    if(!read_op(op5) || op5 != wasm1_code::i32_add) { return res; }
                    if(!read_op(op6) || op6 != wasm1_code::i32_add) { return res; }

                    wasm1_code op7{};
                    if(!read_op(op7) || op7 != wasm1_code::local_get) { return res; }
                    ::std::uint32_t idx4{};
                    if(!read_u32_leb(idx4) || idx4 != 4u) { return res; }

                    wasm1_code op8{};
                    if(!read_op(op8) || op8 != wasm1_code::local_get) { return res; }
                    ::std::uint32_t idx5{};
                    if(!read_u32_leb(idx5) || idx5 != 5u) { return res; }

                    wasm1_code op9{};
                    if(!read_op(op9) || op9 != wasm1_code::i32_add) { return res; }

                    wasm1_code op10{};
                    if(!read_op(op10) || op10 != wasm1_code::local_get) { return res; }
                    ::std::uint32_t idx6{};
                    if(!read_u32_leb(idx6) || idx6 != 6u) { return res; }

                    wasm1_code op11{};
                    if(!read_op(op11) || op11 != wasm1_code::local_get) { return res; }
                    ::std::uint32_t idx7{};
                    if(!read_u32_leb(idx7) || idx7 != 7u) { return res; }

                    wasm1_code op12{};
                    wasm1_code op13{};
                    wasm1_code op14{};
                    if(!read_op(op12) || op12 != wasm1_code::i32_add) { return res; }
                    if(!read_op(op13) || op13 != wasm1_code::i32_add) { return res; }
                    if(!read_op(op14) || op14 != wasm1_code::i32_add) { return res; }

                    wasm1_code op15{};
                    if(!read_op(op15) || op15 != wasm1_code::i32_const) { return res; }
                    wasm_i32 imm;  // no init
                    if(!read_i32_leb(imm)) { return res; }

                    wasm1_code op16{};
                    wasm1_code op17{};
                    if(!read_op(op16) || op16 != wasm1_code::i32_xor) { return res; }
                    if(!read_op(op17) || op17 != wasm1_code::end) { return res; }
                    if(curr != end) { return res; }

                    res.kind = trivial_call_inline_kind::sum8_xor_const_i32;
                    res.imm = imm;
                    return res;
                }

                return res;
            }

            if(op2 == wasm1_code::i32_xor)
            {
                if(!((idx0 == 0u && idx1 == 1u) || (idx0 == 1u && idx1 == 0u))) { return res; }

                wasm1_code op3{};
                if(!read_op(op3)) { return res; }

                // Pattern B: local.get 0/1 ; local.get 1/0 ; i32.xor ; end
                if(op3 == wasm1_code::end && curr == end)
                {
                    res.kind = trivial_call_inline_kind::xor_i32;
                    return res;
                }

                // Pattern D: local.get 0/1 ; local.get 1/0 ; i32.xor ; local.get K ; i32.xor ; end
                // If K is a non-parameter local and the body contains no writes, local[K] is always the zero-initialized default (0),
                // so this reduces to `param0 xor param1`.
                if(op3 != wasm1_code::local_get) { return res; }
                ::std::uint32_t idxk{};
                if(!read_u32_leb(idxk) || idxk < 2u) { return res; }

                wasm1_code op4{};
                wasm1_code op5{};
                if(!read_op(op4) || op4 != wasm1_code::i32_xor) { return res; }
                if(!read_op(op5) || op5 != wasm1_code::end) { return res; }
                if(curr != end) { return res; }
                res.kind = trivial_call_inline_kind::xor_i32;
                return res;
            }

            if(op2 == wasm1_code::i32_const)
            {
                if(!(idx0 == 0u && idx1 == 1u)) { return res; }

                wasm_i32 imm;  // no init
                if(!read_i32_leb(imm)) { return res; }

                wasm1_code op3{};
                wasm1_code op4{};
                wasm1_code op5{};
                if(!read_op(op3) || !read_op(op4)) { return res; }
                if(!read_op(op5) || op5 != wasm1_code::end) { return res; }
                if(curr != end) { return res; }

                if(op3 == wasm1_code::i32_xor && op4 == wasm1_code::i32_add)
                {
                    res.kind = trivial_call_inline_kind::xor_add_const_i32;
                    res.imm = imm;
                    return res;
                }
                if(op3 == wasm1_code::i32_or && op4 == wasm1_code::i32_sub)
                {
                    res.kind = trivial_call_inline_kind::sub_or_const_i32;
                    res.imm = imm;
                    return res;
                }
                return res;
            }

            return res;
        }

        inline consteval bool range_enabled(::std::size_t begin_pos, ::std::size_t end_pos) noexcept { return begin_pos != end_pos; }

        inline consteval bool in_range(::std::size_t pos, ::std::size_t begin_pos, ::std::size_t end_pos) noexcept
        { return range_enabled(begin_pos, end_pos) && begin_pos <= pos && pos < end_pos; }

        template <::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_translate_option_t CompileOption>
        inline consteval ::std::size_t interpreter_tuple_size() noexcept
        {
            ::std::size_t max_end{3uz};

            if constexpr(range_enabled(CompileOption.i32_stack_top_begin_pos, CompileOption.i32_stack_top_end_pos))
            {
                if(CompileOption.i32_stack_top_end_pos > max_end) { max_end = CompileOption.i32_stack_top_end_pos; }
            }
            if constexpr(range_enabled(CompileOption.i64_stack_top_begin_pos, CompileOption.i64_stack_top_end_pos))
            {
                if(CompileOption.i64_stack_top_end_pos > max_end) { max_end = CompileOption.i64_stack_top_end_pos; }
            }
            if constexpr(range_enabled(CompileOption.f32_stack_top_begin_pos, CompileOption.f32_stack_top_end_pos))
            {
                if(CompileOption.f32_stack_top_end_pos > max_end) { max_end = CompileOption.f32_stack_top_end_pos; }
            }
            if constexpr(range_enabled(CompileOption.f64_stack_top_begin_pos, CompileOption.f64_stack_top_end_pos))
            {
                if(CompileOption.f64_stack_top_end_pos > max_end) { max_end = CompileOption.f64_stack_top_end_pos; }
            }
            if constexpr(range_enabled(CompileOption.v128_stack_top_begin_pos, CompileOption.v128_stack_top_end_pos))
            {
                if(CompileOption.v128_stack_top_end_pos > max_end) { max_end = CompileOption.v128_stack_top_end_pos; }
            }

            return max_end;
        }

        template <::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_translate_option_t CompileOption>
        inline consteval bool interpreter_tuple_has_no_holes() noexcept
        {
            constexpr ::std::size_t end_pos{interpreter_tuple_size<CompileOption>()};
            for(::std::size_t pos{3uz}; pos < end_pos; ++pos)
            {
                bool const hit{in_range(pos, CompileOption.i32_stack_top_begin_pos, CompileOption.i32_stack_top_end_pos) ||
                               in_range(pos, CompileOption.i64_stack_top_begin_pos, CompileOption.i64_stack_top_end_pos) ||
                               in_range(pos, CompileOption.f32_stack_top_begin_pos, CompileOption.f32_stack_top_end_pos) ||
                               in_range(pos, CompileOption.f64_stack_top_begin_pos, CompileOption.f64_stack_top_end_pos) ||
                               in_range(pos, CompileOption.v128_stack_top_begin_pos, CompileOption.v128_stack_top_end_pos)};
                if(!hit) { return false; }
            }
            return true;
        }

        template <::std::size_t I, ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_translate_option_t CompileOption>
        struct interpreter_tuple_arg
        {
            inline static consteval auto pick() noexcept
            {
                if constexpr(I == 0uz) { return ::std::type_identity<::std::byte const*>{}; }
                else if constexpr(I == 1uz) { return ::std::type_identity<::std::byte*>{}; }
                else if constexpr(I == 2uz) { return ::std::type_identity<::std::byte*>{}; }
                else
                {
                    constexpr bool i32_hit{in_range(I, CompileOption.i32_stack_top_begin_pos, CompileOption.i32_stack_top_end_pos)};
                    constexpr bool i64_hit{in_range(I, CompileOption.i64_stack_top_begin_pos, CompileOption.i64_stack_top_end_pos)};
                    constexpr bool f32_hit{in_range(I, CompileOption.f32_stack_top_begin_pos, CompileOption.f32_stack_top_end_pos)};
                    constexpr bool f64_hit{in_range(I, CompileOption.f64_stack_top_begin_pos, CompileOption.f64_stack_top_end_pos)};
                    constexpr bool v128_hit{in_range(I, CompileOption.v128_stack_top_begin_pos, CompileOption.v128_stack_top_end_pos)};

                    constexpr ::std::size_t hit_count{static_cast<::std::size_t>(i32_hit) + static_cast<::std::size_t>(i64_hit) +
                                                      static_cast<::std::size_t>(f32_hit) + static_cast<::std::size_t>(f64_hit) +
                                                      static_cast<::std::size_t>(v128_hit)};

                    if constexpr(hit_count == 0uz) { return ::std::type_identity<::std::byte*>{}; }
                    else if constexpr(hit_count == 1uz)
                    {
                        if constexpr(i32_hit) { return ::std::type_identity<wasm_i32>{}; }
                        else if constexpr(i64_hit) { return ::std::type_identity<wasm_i64>{}; }
                        else if constexpr(f32_hit) { return ::std::type_identity<wasm_f32>{}; }
                        else if constexpr(f64_hit) { return ::std::type_identity<wasm_f64>{}; }
                        else
                        {
                            return ::std::type_identity<wasm_v128>{};
                        }
                    }
                    else
                    {
                        // Merge layouts must be expressed as *fully overlapping* ranges (same begin/end). Partial overlaps are invalid.
                        constexpr bool i32_i64_merge{range_enabled(CompileOption.i32_stack_top_begin_pos, CompileOption.i32_stack_top_end_pos) &&
                                                     range_enabled(CompileOption.i64_stack_top_begin_pos, CompileOption.i64_stack_top_end_pos) &&
                                                     CompileOption.i32_stack_top_begin_pos == CompileOption.i64_stack_top_begin_pos &&
                                                     CompileOption.i32_stack_top_end_pos == CompileOption.i64_stack_top_end_pos};
                        constexpr bool i32_f32_merge{range_enabled(CompileOption.i32_stack_top_begin_pos, CompileOption.i32_stack_top_end_pos) &&
                                                     range_enabled(CompileOption.f32_stack_top_begin_pos, CompileOption.f32_stack_top_end_pos) &&
                                                     CompileOption.i32_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                     CompileOption.i32_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                        constexpr bool f32_f64_merge{range_enabled(CompileOption.f32_stack_top_begin_pos, CompileOption.f32_stack_top_end_pos) &&
                                                     range_enabled(CompileOption.f64_stack_top_begin_pos, CompileOption.f64_stack_top_end_pos) &&
                                                     CompileOption.f32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                     CompileOption.f32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};
                        constexpr bool f32_v128_merge{range_enabled(CompileOption.f32_stack_top_begin_pos, CompileOption.f32_stack_top_end_pos) &&
                                                      range_enabled(CompileOption.v128_stack_top_begin_pos, CompileOption.v128_stack_top_end_pos) &&
                                                      CompileOption.f32_stack_top_begin_pos == CompileOption.v128_stack_top_begin_pos &&
                                                      CompileOption.f32_stack_top_end_pos == CompileOption.v128_stack_top_end_pos};
                        constexpr bool f64_v128_merge{range_enabled(CompileOption.f64_stack_top_begin_pos, CompileOption.f64_stack_top_end_pos) &&
                                                      range_enabled(CompileOption.v128_stack_top_begin_pos, CompileOption.v128_stack_top_end_pos) &&
                                                      CompileOption.f64_stack_top_begin_pos == CompileOption.v128_stack_top_begin_pos &&
                                                      CompileOption.f64_stack_top_end_pos == CompileOption.v128_stack_top_end_pos};

                        constexpr bool scalar4_merge{i32_i64_merge && i32_f32_merge && f32_f64_merge};
                        constexpr bool f32_f64_v128_merge{f32_f64_merge && f32_v128_merge && f64_v128_merge};

                        if constexpr(i32_hit && i64_hit && f32_hit && f64_hit)
                        {
                            static_assert(scalar4_merge, "i32/i64/f32/f64 overlap must be a fully merged scalar range (same begin/end).");
                            static_assert(!v128_hit, "scalar4 merged range cannot also overlap v128 (unsupported slot layout).");
                            return ::std::type_identity<wasm_stack_top_i32_i64_f32_f64_u>{};
                        }
                        else if constexpr(f32_hit && f64_hit && v128_hit)
                        {
                            static_assert(f32_f64_v128_merge, "f32/f64/v128 overlap must be a fully merged f32/f64/v128 range (same begin/end).");
                            static_assert(!(i32_hit || i64_hit), "f32/f64/v128 merged range must not overlap i32/i64 (unsupported slot layout).");
                            return ::std::type_identity<wasm_v128>{};
                        }
                        else if constexpr(i32_hit && i64_hit)
                        {
                            static_assert(i32_i64_merge, "i32/i64 overlap must be a fully merged i32/i64 range (same begin/end).");
                            static_assert(!(f32_hit || f64_hit || v128_hit), "i32/i64 merged range must not overlap f32/f64/v128 (unsupported slot layout).");
                            return ::std::type_identity<wasm_stack_top_i32_with_i64_u>{};
                        }
                        else if constexpr(i32_hit && f32_hit)
                        {
                            static_assert(i32_f32_merge, "i32/f32 overlap must be a fully merged i32/f32 range (same begin/end).");
                            static_assert(!(i64_hit || f64_hit || v128_hit), "i32/f32 merged range must not overlap i64/f64/v128 (unsupported slot layout).");
                            return ::std::type_identity<wasm_stack_top_i32_with_f32_u>{};
                        }
                        else if constexpr(f32_hit && f64_hit)
                        {
                            static_assert(f32_f64_merge, "f32/f64 overlap must be a fully merged f32/f64 range (same begin/end).");
                            static_assert(!v128_hit, "f32/f64 merged range cannot also overlap v128 unless all three are merged.");
                            static_assert(!(i32_hit || i64_hit), "f32/f64 merged range must not overlap i32/i64 (unsupported slot layout).");
                            return ::std::type_identity<wasm_f64>{};
                        }
                        else
                        {
                            static_assert(hit_count == 0uz, "unsupported stack-top slot overlap/merge layout at this position.");
                            return ::std::type_identity<::std::byte*>{};
                        }
                    }
                }
            }

            using type = typename decltype(pick())::type;
        };

        template <::std::size_t I, ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_translate_option_t CompileOption>
        using interpreter_tuple_arg_t = typename interpreter_tuple_arg<I, CompileOption>::type;

        template <::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_translate_option_t CompileOption, ::std::size_t... Is>
        inline consteval ::uwvm2::utils::container::tuple<interpreter_tuple_arg_t<Is, CompileOption>...>
            make_interpreter_tuple(::std::index_sequence<Is...>) noexcept
        { return {}; }
    }  // namespace details

    template <::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_translate_option_t CompileOption>
    inline constexpr ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_full_function_symbol_t compile_all_from_uwvm_single_func(
        ::uwvm2::uwvm::runtime::storage::wasm_module_storage_t const& curr_module,
        [[maybe_unused]] ::uwvm2::runtime::compiler::uwvm_int::optable::compile_option& options,
        ::uwvm2::validation::error::code_validation_error_impl& err) UWVM_THROWS
    {
        ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_full_function_symbol_t storage{};

        // Note: This is a compiler-side, standalone copy of the wasm1 validator logic.
        // It validates decayed `wasm_module_storage_t` (not parser storage) and must not depend on the standard validator implementation.

        using wasm_u32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_u32;
        using wasm_i32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32;
        using wasm_i64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64;
        using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;
        using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;
        using wasm_byte = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_byte;
        using wasm_value_type = ::uwvm2::parser::wasm::standard::wasm1::type::value_type;
        using code_validation_error_code = ::uwvm2::validation::error::code_validation_error_code;

        // no necessary to set err to default

        enum class block_type : unsigned
        {
            function,
            block,
            loop,
            if_,
            else_
        };

        struct block_result_type
        {
            wasm_value_type const* begin{};
            wasm_value_type const* end{};
        };

        struct operand_stack_storage_t
        {
            wasm_value_type type{};
        };

        struct block_t
        {
            block_result_type result{};
            ::std::size_t operand_stack_base{};
            block_type type{};
            bool polymorphic_base{};
            bool then_polymorphic_end{};  // only meaningful for if/else frames

            // Stack-top cache snapshot at "end label" entry (used when fallthrough is unreachable at `end`,
            // but the construct is reachable via an earlier branch to its end label).
            // Only meaningful when scalar stack-top caching is enabled.
            bool stacktop_has_end_state{};
            ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_stacktop_currpos_t stacktop_currpos_at_end{};
            ::std::size_t stacktop_memory_count_at_end{};
            ::std::size_t stacktop_cache_count_at_end{};
            ::std::size_t stacktop_cache_i32_count_at_end{};
            ::std::size_t stacktop_cache_i64_count_at_end{};
            ::std::size_t stacktop_cache_f32_count_at_end{};
            ::std::size_t stacktop_cache_f64_count_at_end{};
            // Codegen type stack snapshot at end label entry.
            // Needed to restore type information when a polymorphic fallthrough reaches `end` and becomes reachable again.
            ::uwvm2::utils::container::vector<operand_stack_storage_t> codegen_operand_stack_at_end{};

            // Stack-top cache snapshot at `if` entry (used to restore correct else-body codegen state).
            // Only meaningful for `if` frames when scalar stack-top caching is enabled.
            ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_stacktop_currpos_t stacktop_currpos_at_else_entry{};
            ::std::size_t stacktop_memory_count_at_else_entry{};
            ::std::size_t stacktop_cache_count_at_else_entry{};
            ::std::size_t stacktop_cache_i32_count_at_else_entry{};
            ::std::size_t stacktop_cache_i64_count_at_else_entry{};
            ::std::size_t stacktop_cache_f32_count_at_else_entry{};
            ::std::size_t stacktop_cache_f64_count_at_else_entry{};
            ::uwvm2::utils::container::vector<operand_stack_storage_t> codegen_operand_stack_at_else_entry{};

            // Stack-top cache snapshot at then-path end (used when else-path is unreachable but then-path reaches `end`).
            // Only meaningful for `if-else` frames when scalar stack-top caching is enabled.
            bool stacktop_has_then_end_state{};
            ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_stacktop_currpos_t stacktop_currpos_at_then_end{};
            ::std::size_t stacktop_memory_count_at_then_end{};
            ::std::size_t stacktop_cache_count_at_then_end{};
            ::std::size_t stacktop_cache_i32_count_at_then_end{};
            ::std::size_t stacktop_cache_i64_count_at_then_end{};
            ::std::size_t stacktop_cache_f32_count_at_then_end{};
            ::std::size_t stacktop_cache_f64_count_at_then_end{};
            ::uwvm2::utils::container::vector<operand_stack_storage_t> codegen_operand_stack_at_then_end{};

            // Translation labels:
            // - For `block`/`if`/`else`/`function`: `end_label_id` is the branch target.
            // - For `loop`: `start_label_id` is the branch target, `end_label_id` is the fallthrough target.
            ::std::size_t start_label_id{SIZE_MAX};
            ::std::size_t end_label_id{SIZE_MAX};
            ::std::size_t else_label_id{SIZE_MAX};  // only meaningful for if/else frames

            // Wasm bytecode pointer at the loop start label (first opcode inside the loop body). Used by extra-heavy loop fusion.
            ::std::byte const* wasm_code_curr_at_start_label{};
        };

        auto const import_func_count{curr_module.imported_function_vec_storage.size()};
        auto const local_func_count{curr_module.local_defined_function_vec_storage.size()};

        auto const imported_global_count{static_cast<wasm_u32>(curr_module.imported_global_vec_storage.size())};
        auto const local_global_count{static_cast<wasm_u32>(curr_module.local_defined_global_vec_storage.size())};
        auto const all_global_count{static_cast<wasm_u32>(imported_global_count + local_global_count)};

        auto const imported_table_count{static_cast<wasm_u32>(curr_module.imported_table_vec_storage.size())};
        auto const local_table_count{static_cast<wasm_u32>(curr_module.local_defined_table_vec_storage.size())};
        auto const all_table_count{static_cast<wasm_u32>(imported_table_count + local_table_count)};

        auto const imported_memory_count{static_cast<wasm_u32>(curr_module.imported_memory_vec_storage.size())};
        auto const local_memory_count{static_cast<wasm_u32>(curr_module.local_defined_memory_vec_storage.size())};
        auto const all_memory_count{static_cast<wasm_u32>(imported_memory_count + local_memory_count)};

        storage.local_funcs.reserve(local_func_count);
        storage.local_defined_call_info.clear();
        storage.local_defined_call_info.resize(local_func_count);
        for(::std::size_t i{}; i != local_func_count; ++i)
        {
            auto& info{storage.local_defined_call_info.index_unchecked(i)};
            info.module_id = options.curr_wasm_id;
            info.function_index = import_func_count + i;
        }

        // Reuse translation temporaries across functions to avoid repeated heap allocations.
        using curr_block_type = block_t;
        ::uwvm2::utils::container::vector<curr_block_type> control_flow_stack{};

        using curr_operand_stack_value_type = wasm_value_type;
        using curr_operand_stack_type = ::uwvm2::utils::container::vector<operand_stack_storage_t>;
        curr_operand_stack_type operand_stack{};
        // Codegen operand stack (type-only): tracks the operand-stack types for the **emitted bytecode**.
        // This is required for stack-top caching spill/fill typing because conbine may validate ahead of codegen.
        curr_operand_stack_type codegen_operand_stack{};

        ::uwvm2::utils::container::vector<::std::size_t> local_offsets{};
        ::uwvm2::utils::container::vector<curr_operand_stack_value_type> local_types{};

        // Reuse label/thunk fixup temporaries across functions to avoid repeated heap allocations.
        using bytecode_vec_t = ::uwvm2::utils::container::vector<::std::byte>;

        using rel_offset_t = ::std::make_unsigned_t<::std::ptrdiff_t>;
        static_assert(sizeof(rel_offset_t) == sizeof(::std::byte const*));
        static_assert(::std::is_trivially_copyable_v<rel_offset_t>);

        struct label_info_t
        {
            ::std::size_t offset{SIZE_MAX};
            bool in_thunk{};
        };

        struct ptr_fixup_t
        {
            ::std::size_t site{};      // byte index within the owning buffer
            ::std::size_t label_id{};  // index into labels
            bool in_thunk{};           // false: site in `bytecode`, true: site in `thunks`
        };

        ::uwvm2::utils::container::vector<label_info_t> labels{};
        ::uwvm2::utils::container::vector<ptr_fixup_t> ptr_fixups{};
        bytecode_vec_t thunks{};
        labels.reserve(64uz);
        ptr_fixups.reserve(256uz);
        thunks.reserve(256uz);

        for(::std::size_t local_function_idx{}; local_function_idx < local_func_count; ++local_function_idx)
        {
            ::std::size_t const function_index{import_func_count + local_function_idx};

            auto const& curr_local_func{curr_module.local_defined_function_vec_storage.index_unchecked(local_function_idx)};
            auto const& curr_func_type{*curr_local_func.function_type_ptr};
            auto const& curr_code{*curr_local_func.wasm_code_ptr};

            auto const code_begin{reinterpret_cast<::std::byte const*>(curr_code.body.expr_begin)};
            auto const code_end{reinterpret_cast<::std::byte const*>(curr_code.body.code_end)};

            // check
            if(function_index < import_func_count) [[unlikely]]
            {
                err.err_curr = code_begin;
                err.err_selectable.not_local_function.function_index = function_index;
                err.err_code = code_validation_error_code::not_local_function;
                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
            }

            auto const local_func_idx{function_index - import_func_count};
            if(local_func_idx >= local_func_count) [[unlikely]]
            {
                err.err_curr = code_begin;
                err.err_selectable.invalid_function_index.function_index = function_index;
                err.err_selectable.invalid_function_index.all_function_size = import_func_count + local_func_count;
                err.err_code = code_validation_error_code::invalid_function_index;
                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
            }

            auto const func_parameter_begin{curr_func_type.parameter.begin};
            auto const func_parameter_end{curr_func_type.parameter.end};
            auto const func_parameter_count_uz{static_cast<::std::size_t>(func_parameter_end - func_parameter_begin)};
            auto const func_parameter_count_u32{static_cast<wasm_u32>(func_parameter_count_uz)};

#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
            if(func_parameter_count_u32 != func_parameter_count_uz) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif

            auto const& curr_code_locals{curr_code.locals};

            // all local count = parameter + local defined local count
            wasm_u32 all_local_count{func_parameter_count_u32};
            for(auto const& local_part: curr_code_locals)
            {
                // all_local_count never overflow and never exceed the max of u32 (validated by parser limits)
                all_local_count += local_part.count;
            }

#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
            if constexpr(::std::numeric_limits<wasm_u32>::max() > ::std::numeric_limits<::std::size_t>::max())
            {
                if(all_local_count > ::std::numeric_limits<::std::size_t>::max()) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
            }
#endif

            // Reset per-function translation temporaries.
            control_flow_stack.clear();
            operand_stack.clear();
            codegen_operand_stack.clear();
            bool is_polymorphic{};

            ::uwvm2::runtime::compiler::uwvm_int::optable::local_func_storage_t local_func_symbol{};

            // Translation uses one internal temporary local slot to preserve single-value block results across stack-unwind branches
            // (e.g., `br`/`br_if`/`br_table` when `target_base + arity` is not equal to current stack size).
            constexpr wasm_u32 internal_temp_local_count{1u};
            wasm_u32 all_local_count_with_internal{all_local_count + internal_temp_local_count};
            local_func_symbol.local_count = static_cast<::std::size_t>(all_local_count_with_internal);

            using local_offset_t = ::std::size_t;
            constexpr local_offset_t local_slot_size{sizeof(::uwvm2::runtime::compiler::uwvm_int::optable::wasm_stack_top_i32_i64_f32_f64_u)};
            static_assert(local_slot_size != 0uz);
            constexpr local_offset_t internal_temp_local_size{8uz};
            static_assert(local_slot_size == internal_temp_local_size);

            // Operand stack is byte-packed in byref mode: i32/f32 are 4 bytes, i64/f64 are 8 bytes.
            // We track the exact max byte usage during validation so the runtime can allocate precisely.
            auto const operand_stack_valtype_size{[&](wasm_value_type t) constexpr noexcept -> ::std::size_t
                                                  {
                                                      switch(t)
                                                      {
                                                          case wasm_value_type::i32:
                                                          {
                                                              return 4uz;
                                                          }
                                                          case wasm_value_type::i64:
                                                          {
                                                              return 8uz;
                                                          }
                                                          case wasm_value_type::f32:
                                                          {
                                                              return 4uz;
                                                          }
                                                          case wasm_value_type::f64:
                                                          {
                                                              return 8uz;
                                                          }
                                                          [[unlikely]] default:
                                                          {
                                                              return 0uz;
                                                          }
                                                      }
                                                  }};

            // Current operand stack size in bytes (byte-packed: i32/f32=4, i64/f64=8).
            // Maintained incrementally to avoid O(n^2) rescans during compilation.
            ::std::size_t operand_stack_bytes{};

            // Runtime operand stack maximum (for allocation sizing).
            // Track on-demand (push/restore) instead of per-op to reduce translator overhead.
            ::std::size_t runtime_operand_stack_max{};
            ::std::size_t runtime_operand_stack_byte_max{};

            auto const operand_stack_push{[&](curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                                          {
                                              // Hot path: avoid the checked `push_back()` in fast_io::vector.
                                              if(operand_stack.size() == operand_stack.capacity())
                                              {
                                                  operand_stack.reserve(operand_stack.capacity() ? operand_stack.capacity() * 2uz : 64uz);
                                              }
                                              operand_stack.push_back_unchecked({vt});
                                              auto const add{operand_stack_valtype_size(vt)};
                                              if(add == 0uz) [[unlikely]] { ::fast_io::fast_terminate(); }
                                              if(add > (::std::numeric_limits<::std::size_t>::max() - operand_stack_bytes)) [[unlikely]]
                                              {
                                                  ::fast_io::fast_terminate();
                                              }
                                              operand_stack_bytes += add;

                                              if(!is_polymorphic) [[likely]]
                                              {
                                                  auto const sz{operand_stack.size()};
                                                  if(sz > runtime_operand_stack_max) { runtime_operand_stack_max = sz; }
                                                  if(operand_stack_bytes > runtime_operand_stack_byte_max)
                                                  {
                                                      runtime_operand_stack_byte_max = operand_stack_bytes;
                                                  }
                                              }
                                          }};

            auto const operand_stack_pop_unchecked{[&]() constexpr noexcept
                                                   {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                                       if(operand_stack.empty()) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                                                       if(operand_stack.empty()) { return; }
                                                       auto const vt{operand_stack.back_unchecked().type};
                                                       operand_stack.pop_back_unchecked();
                                                       auto const sub{operand_stack_valtype_size(vt)};
                                                       if(sub == 0uz || sub > operand_stack_bytes) [[unlikely]] { ::fast_io::fast_terminate(); }
                                                       operand_stack_bytes -= sub;
                                                   }};

            auto const operand_stack_pop_n{[&](::std::size_t n) constexpr noexcept
                                           {
                                               while(n-- != 0uz && !operand_stack.empty()) { operand_stack_pop_unchecked(); }
                                           }};

            auto const operand_stack_truncate_to{[&](::std::size_t new_size) constexpr noexcept
                                                 {
                                                     while(operand_stack.size() > new_size) { operand_stack_pop_unchecked(); }
                                                 }};

            auto const sync_type_stacks_from_codegen_snapshot{[&](curr_operand_stack_type const& snapshot) constexpr UWVM_THROWS
                                                              {
                                                                  operand_stack = snapshot;
                                                                  codegen_operand_stack = snapshot;
                                                                  operand_stack_bytes = 0uz;
                                                                  for(auto const& v: operand_stack)
                                                                  {
                                                                      auto const add{operand_stack_valtype_size(v.type)};
                                                                      if(add == 0uz) [[unlikely]] { ::fast_io::fast_terminate(); }
                                                                      if(add > (::std::numeric_limits<::std::size_t>::max() - operand_stack_bytes)) [[unlikely]]
                                                                      {
                                                                          ::fast_io::fast_terminate();
                                                                      }
                                                                      operand_stack_bytes += add;
                                                                  }

                                                                  if(!is_polymorphic) [[likely]]
                                                                  {
                                                                      auto const sz{operand_stack.size()};
                                                                      if(sz > runtime_operand_stack_max) { runtime_operand_stack_max = sz; }
                                                                      if(operand_stack_bytes > runtime_operand_stack_byte_max)
                                                                      {
                                                                          runtime_operand_stack_byte_max = operand_stack_bytes;
                                                                      }
                                                                  }
                                                              }};

            // Local storage is byte-packed too (same scalar sizes). We emit local offsets as immediates, so runtime only
            // needs the total local byte size to allocate and zero-initialize.
            local_offsets.clear();
            local_types.clear();
            auto const local_offsets_need{static_cast<::std::size_t>(all_local_count_with_internal)};
            if(local_offsets.capacity() < local_offsets_need) { local_offsets.reserve(local_offsets_need); }
            // local_types stores only Wasm-visible locals (no internal temp local).
            auto const local_types_need{static_cast<::std::size_t>(all_local_count)};
            if(local_types.capacity() < local_types_need) { local_types.reserve(local_types_need); }

            auto const local_bytes_add{[&](local_offset_t& acc, local_offset_t add) constexpr noexcept
                                       {
                                           if(add > (::std::numeric_limits<local_offset_t>::max() - acc)) [[unlikely]]
                                           {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                               ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                               ::fast_io::fast_terminate();
                                           }
                                           acc += add;
                                       }};

            local_offset_t local_bytes{};
            for(wasm_u32 i{}; i != func_parameter_count_u32; ++i)
            {
                // Safe: reserved `all_local_count_with_internal` above.
                local_offsets.push_back_unchecked(local_bytes);
                // Safe: reserved `all_local_count` above.
                local_types.push_back_unchecked(func_parameter_begin[i]);
                local_bytes_add(local_bytes, static_cast<local_offset_t>(operand_stack_valtype_size(local_types.back_unchecked())));
            }
            for(auto const& local_part: curr_code_locals)
            {
                for(wasm_u32 j{}; j != local_part.count; ++j)
                {
                    // Safe: reserved `all_local_count_with_internal` above.
                    local_offsets.push_back_unchecked(local_bytes);
                    // Safe: reserved `all_local_count` above.
                    local_types.push_back_unchecked(local_part.type);
                    local_bytes_add(local_bytes, static_cast<local_offset_t>(operand_stack_valtype_size(local_types.back_unchecked())));
                }
            }

            if(local_offsets.size() != static_cast<::std::size_t>(all_local_count)) [[unlikely]]
            {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                ::fast_io::fast_terminate();
            }
            if(local_types.size() != static_cast<::std::size_t>(all_local_count)) [[unlikely]]
            {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                ::fast_io::fast_terminate();
            }

            // Internal temp local comes last and must be wide enough for any scalar result (8 bytes).
            // Safe: reserved `all_local_count_with_internal` above.
            local_offsets.push_back_unchecked(local_bytes);
            local_bytes_add(local_bytes, internal_temp_local_size);

            local_func_symbol.local_bytes_max = local_bytes;

            // Local index -> byte offset from `local_base` (type...[2u]).
            auto const local_offset_from_index{[&](wasm_u32 local_index) constexpr noexcept -> local_offset_t
                                               {
                                                   auto const idx{static_cast<::std::size_t>(local_index)};
                                                   if(idx >= local_offsets.size()) [[unlikely]]
                                                   {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                                       ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                                       ::fast_io::fast_terminate();
                                                   }
                                                   return local_offsets.index_unchecked(idx);
                                               }};

            [[maybe_unused]] auto const local_type_from_index{[&](wasm_u32 local_index) constexpr noexcept -> curr_operand_stack_value_type
                                                              {
                                                                  auto const idx{static_cast<::std::size_t>(local_index)};
                                                                  if(idx >= local_types.size()) [[unlikely]]
                                                                  {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                                                      ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                                                      ::fast_io::fast_terminate();
                                                                  }

                                                                  return local_types.index_unchecked(idx);
                                                              }};

            // Internal temp local is the first slot after all Wasm-visible locals.
            local_offset_t const internal_temp_local_off{local_offset_from_index(all_local_count)};
            // Parameters occupy the prefix of the locals buffer and are populated by memcpy at runtime.
            // Non-parameter locals must be zero-initialized by the Wasm spec, but we can skip zeroing trailing locals
            // that are never read (no `local.get`).
            local_offset_t const param_bytes_off{local_offset_from_index(func_parameter_count_u32)};
            local_offset_t local_bytes_zeroinit_end{param_bytes_off};

            static_assert(::std::is_trivially_copyable_v<::std::byte>);

            // ============================
            // Stack-top cache configuration
            // ============================

            constexpr bool stacktop_i32_enabled{CompileOption.i32_stack_top_begin_pos != CompileOption.i32_stack_top_end_pos};
            constexpr bool stacktop_i64_enabled{CompileOption.i64_stack_top_begin_pos != CompileOption.i64_stack_top_end_pos};
            constexpr bool stacktop_f32_enabled{CompileOption.f32_stack_top_begin_pos != CompileOption.f32_stack_top_end_pos};
            constexpr bool stacktop_f64_enabled{CompileOption.f64_stack_top_begin_pos != CompileOption.f64_stack_top_end_pos};
            constexpr bool stacktop_v128_enabled{CompileOption.v128_stack_top_begin_pos != CompileOption.v128_stack_top_end_pos};

            constexpr bool stacktop_enabled{stacktop_i32_enabled || stacktop_i64_enabled || stacktop_f32_enabled || stacktop_f64_enabled ||
                                            stacktop_v128_enabled};

            // Wasm1 operand stack is mixed-typed. If stack-top caching is enabled here, we require full scalar coverage
            // (i32/i64/f32/f64) so the compiler-side stack-top model remains valid for arbitrary type mixes.
            if constexpr(stacktop_enabled)
            {
                static_assert(CompileOption.is_tail_call, "stack-top caching requires tail-call (non-byref) interpreter mode");

                static_assert(stacktop_i32_enabled && stacktop_i64_enabled && stacktop_f32_enabled && stacktop_f64_enabled,
                              "Wasm1 stack-top caching requires i32/i64/f32/f64 ranges enabled together.");

                static_assert(CompileOption.i32_stack_top_begin_pos >= 3uz && CompileOption.i32_stack_top_end_pos > CompileOption.i32_stack_top_begin_pos);
                static_assert(CompileOption.i64_stack_top_begin_pos >= 3uz && CompileOption.i64_stack_top_end_pos > CompileOption.i64_stack_top_begin_pos);
                static_assert(CompileOption.f32_stack_top_begin_pos >= 3uz && CompileOption.f32_stack_top_end_pos > CompileOption.f32_stack_top_begin_pos);
                static_assert(CompileOption.f64_stack_top_begin_pos >= 3uz && CompileOption.f64_stack_top_end_pos > CompileOption.f64_stack_top_begin_pos);

                // Note:
                // Smaller rings (e.g. 1 or 2 slots) are allowed. When an opcode needs more operands than the ring can hold,
                // the opfunc falls back to reading the remaining operands from the operand stack memory (stack pointer),
                // keeping as many values in registers as possible.

                // Overlaps must be *fully merged* (same begin/end). Partial overlaps are invalid for the optable layouts.
                constexpr auto overlap{[](::std::size_t a_begin, ::std::size_t a_end, ::std::size_t b_begin, ::std::size_t b_end) consteval noexcept
                                       { return a_begin < b_end && b_begin < a_end; }};
                constexpr auto equal{[](::std::size_t a_begin, ::std::size_t a_end, ::std::size_t b_begin, ::std::size_t b_end) consteval noexcept
                                     { return a_begin == b_begin && a_end == b_end; }};

                constexpr bool i32_i64_overlap{overlap(CompileOption.i32_stack_top_begin_pos,
                                                       CompileOption.i32_stack_top_end_pos,
                                                       CompileOption.i64_stack_top_begin_pos,
                                                       CompileOption.i64_stack_top_end_pos)};
                constexpr bool i32_f32_overlap{overlap(CompileOption.i32_stack_top_begin_pos,
                                                       CompileOption.i32_stack_top_end_pos,
                                                       CompileOption.f32_stack_top_begin_pos,
                                                       CompileOption.f32_stack_top_end_pos)};
                constexpr bool i32_f64_overlap{overlap(CompileOption.i32_stack_top_begin_pos,
                                                       CompileOption.i32_stack_top_end_pos,
                                                       CompileOption.f64_stack_top_begin_pos,
                                                       CompileOption.f64_stack_top_end_pos)};
                constexpr bool i64_f32_overlap{overlap(CompileOption.i64_stack_top_begin_pos,
                                                       CompileOption.i64_stack_top_end_pos,
                                                       CompileOption.f32_stack_top_begin_pos,
                                                       CompileOption.f32_stack_top_end_pos)};
                constexpr bool i64_f64_overlap{overlap(CompileOption.i64_stack_top_begin_pos,
                                                       CompileOption.i64_stack_top_end_pos,
                                                       CompileOption.f64_stack_top_begin_pos,
                                                       CompileOption.f64_stack_top_end_pos)};
                constexpr bool f32_f64_overlap{overlap(CompileOption.f32_stack_top_begin_pos,
                                                       CompileOption.f32_stack_top_end_pos,
                                                       CompileOption.f64_stack_top_begin_pos,
                                                       CompileOption.f64_stack_top_end_pos)};

                static_assert(!i32_i64_overlap || equal(CompileOption.i32_stack_top_begin_pos,
                                                        CompileOption.i32_stack_top_end_pos,
                                                        CompileOption.i64_stack_top_begin_pos,
                                                        CompileOption.i64_stack_top_end_pos),
                              "i32/i64 stack-top ranges must be disjoint or fully merged.");
                static_assert(!i32_f32_overlap || equal(CompileOption.i32_stack_top_begin_pos,
                                                        CompileOption.i32_stack_top_end_pos,
                                                        CompileOption.f32_stack_top_begin_pos,
                                                        CompileOption.f32_stack_top_end_pos),
                              "i32/f32 stack-top ranges must be disjoint or fully merged.");
                static_assert(!i32_f64_overlap || equal(CompileOption.i32_stack_top_begin_pos,
                                                        CompileOption.i32_stack_top_end_pos,
                                                        CompileOption.f64_stack_top_begin_pos,
                                                        CompileOption.f64_stack_top_end_pos),
                              "i32/f64 stack-top ranges must be disjoint or fully merged.");
                static_assert(!i64_f32_overlap || equal(CompileOption.i64_stack_top_begin_pos,
                                                        CompileOption.i64_stack_top_end_pos,
                                                        CompileOption.f32_stack_top_begin_pos,
                                                        CompileOption.f32_stack_top_end_pos),
                              "i64/f32 stack-top ranges must be disjoint or fully merged.");
                static_assert(!i64_f64_overlap || equal(CompileOption.i64_stack_top_begin_pos,
                                                        CompileOption.i64_stack_top_end_pos,
                                                        CompileOption.f64_stack_top_begin_pos,
                                                        CompileOption.f64_stack_top_end_pos),
                              "i64/f64 stack-top ranges must be disjoint or fully merged.");
                static_assert(!f32_f64_overlap || equal(CompileOption.f32_stack_top_begin_pos,
                                                        CompileOption.f32_stack_top_end_pos,
                                                        CompileOption.f64_stack_top_begin_pos,
                                                        CompileOption.f64_stack_top_end_pos),
                              "f32/f64 stack-top ranges must be disjoint or fully merged.");

                // v128 is used as a vector register-class carrier. If enabled, it must coincide with an f32/f64 merged range.
                if constexpr(stacktop_v128_enabled)
                {
                    static_assert(CompileOption.v128_stack_top_begin_pos >= 3uz &&
                                  CompileOption.v128_stack_top_end_pos > CompileOption.v128_stack_top_begin_pos);

                    constexpr bool f32_v128_overlap{overlap(CompileOption.f32_stack_top_begin_pos,
                                                            CompileOption.f32_stack_top_end_pos,
                                                            CompileOption.v128_stack_top_begin_pos,
                                                            CompileOption.v128_stack_top_end_pos)};
                    constexpr bool f64_v128_overlap{overlap(CompileOption.f64_stack_top_begin_pos,
                                                            CompileOption.f64_stack_top_end_pos,
                                                            CompileOption.v128_stack_top_begin_pos,
                                                            CompileOption.v128_stack_top_end_pos)};
                    static_assert(f32_v128_overlap && f64_v128_overlap, "v128 range must overlap f32/f64 ranges.");
                    static_assert(equal(CompileOption.v128_stack_top_begin_pos,
                                        CompileOption.v128_stack_top_end_pos,
                                        CompileOption.f32_stack_top_begin_pos,
                                        CompileOption.f32_stack_top_end_pos) &&
                                      equal(CompileOption.v128_stack_top_begin_pos,
                                            CompileOption.v128_stack_top_end_pos,
                                            CompileOption.f64_stack_top_begin_pos,
                                            CompileOption.f64_stack_top_end_pos),
                                  "v128 range must fully coincide with an f32/f64 merged range (same begin/end).");

                    static_assert(!overlap(CompileOption.v128_stack_top_begin_pos,
                                           CompileOption.v128_stack_top_end_pos,
                                           CompileOption.i32_stack_top_begin_pos,
                                           CompileOption.i32_stack_top_end_pos) &&
                                      !overlap(CompileOption.v128_stack_top_begin_pos,
                                               CompileOption.v128_stack_top_end_pos,
                                               CompileOption.i64_stack_top_begin_pos,
                                               CompileOption.i64_stack_top_end_pos),
                                  "v128 range must not overlap i32/i64 ranges.");
                }

                static_assert(details::interpreter_tuple_has_no_holes<CompileOption>(),
                              "stack-top ranges must cover all opfunc argument slots >= 3 (no holes), or shrink the ranges.");
            }

            // Translate: opfunc signature tuple (ip, operand_stack_top_ptr, local_base_ptr, [stack-top cache...]).
            // Slot types are derived from `CompileOption` to drive ABI packing (GPR vs FP/SIMD regs) correctly.
            static constexpr ::std::size_t interpreter_tuple_size{details::interpreter_tuple_size<CompileOption>()};
            using interpreter_tuple_t = decltype(details::make_interpreter_tuple<CompileOption>(::std::make_index_sequence<interpreter_tuple_size>{}));
            static constexpr interpreter_tuple_t interpreter_tuple{};

            // Translate: stack-top currpos.
            ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_stacktop_currpos_t curr_stacktop{
                .i32_stack_top_curr_pos = stacktop_i32_enabled ? CompileOption.i32_stack_top_begin_pos : SIZE_MAX,
                .i64_stack_top_curr_pos = stacktop_i64_enabled ? CompileOption.i64_stack_top_begin_pos : SIZE_MAX,
                .f32_stack_top_curr_pos = stacktop_f32_enabled ? CompileOption.f32_stack_top_begin_pos : SIZE_MAX,
                .f64_stack_top_curr_pos = stacktop_f64_enabled ? CompileOption.f64_stack_top_begin_pos : SIZE_MAX,
                .v128_stack_top_curr_pos = stacktop_v128_enabled ? CompileOption.v128_stack_top_begin_pos : SIZE_MAX,
            };

            // Stack-top cache runtime state (compiler-side model).
            // - `memory_count`: number of stack values materialized in operand stack memory.
            // - `cache_count`:  number of stack values resident in stack-top cache (top segment).
            ::std::size_t stacktop_memory_count{};
            ::std::size_t stacktop_cache_count{};
            ::std::size_t stacktop_cache_i32_count{};
            ::std::size_t stacktop_cache_i64_count{};
            ::std::size_t stacktop_cache_f32_count{};
            ::std::size_t stacktop_cache_f64_count{};

            // Experimental: strict control-flow entry (call-like).
            // Goal: ensure re-entry points (block/loop end, loop start, else entry) see an empty stack-top cache and
            // all values materialized in operand-stack memory, to avoid expensive state-merge/repair across edges.
            // NOTE: Keeping stack-top cache across control-flow re-entry is critical for tight loops.
            // The strict mode forces call-like barriers (flush-to-memory + reset currpos) at loop/block/else entries,
            // which can introduce large per-iteration overhead when branches are hot.
            constexpr bool strict_cf_entry_like_call{false};

            // Experimental: register-only control-flow canonicalization.
            // Goal: keep operand values resident in the stack-top cache across loop re-entry, while still making the
            // label entry currpos deterministic (range-begin) so back-edges can jump directly without spilling/filling.
            constexpr bool stacktop_regtransform_cf_entry{true};

            // Current stack-top transform opfunc supports at most:
            // - one fully-merged integer ring (i32/i64), and
            // - one fully-merged fp/simd ring (f32/f64/v128).
            constexpr bool stacktop_regtransform_supported{
                // i32/i64 must be same-range if both enabled
                (!(stacktop_i32_enabled && stacktop_i64_enabled) || (CompileOption.i32_stack_top_begin_pos == CompileOption.i64_stack_top_begin_pos &&
                                                                     CompileOption.i32_stack_top_end_pos == CompileOption.i64_stack_top_end_pos)) &&
                // f32/f64 must be same-range if both enabled
                (!(stacktop_f32_enabled && stacktop_f64_enabled) || (CompileOption.f32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                                     CompileOption.f32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos)) &&
                // v128 must coincide with the active f32/f64 merged range
                (!stacktop_v128_enabled || ((stacktop_f32_enabled && CompileOption.v128_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                             CompileOption.v128_stack_top_end_pos == CompileOption.f32_stack_top_end_pos) ||
                                            (stacktop_f64_enabled && CompileOption.v128_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                             CompileOption.v128_stack_top_end_pos == CompileOption.f64_stack_top_end_pos)))};

#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
            // Tracking for `stacktop_assert_invariants()` diagnostics.
            ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code stacktop_dbg_last_op{
                ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::unreachable};
            ::std::size_t stacktop_dbg_last_ip{};
#endif

            // Bytecode emitter (writes into local_func_symbol.op.operands).
            bytecode_vec_t& bytecode{local_func_symbol.op.operands};

            bool const runtime_log_on{uwvm2::uwvm::io::enable_runtime_log};
            // Verbose emit logging for offline analysis (enabled only when `-Rclog` is used).
            constexpr bool runtime_log_emit_opfuncs{true};
            constexpr bool runtime_log_emit_cf{true};

            struct runtime_log_stats_t
            {
                ::std::uint_least64_t wasm_op_count{};
                ::std::uint_least64_t opfunc_main_count{};
                ::std::uint_least64_t opfunc_thunk_count{};
                ::std::uint_least64_t label_placeholder_main_count{};
                ::std::uint_least64_t label_placeholder_thunk_count{};
                ::std::uint_least64_t cf_br_count{};
                ::std::uint_least64_t cf_br_transform_count{};
                ::std::uint_least64_t cf_br_if_count{};
                ::std::uint_least64_t cf_loop_entry_transform_count{};
                ::std::uint_least64_t cf_loop_entry_canonicalize_to_mem_count{};
                ::std::uint_least64_t stacktop_spill1_count{};
                ::std::uint_least64_t stacktop_spillN_count{};
                ::std::uint_least64_t stacktop_fill1_count{};
                ::std::uint_least64_t stacktop_fillN_count{};
            };

            runtime_log_stats_t runtime_log_stats{};

            // Best-effort: current Wasm IP for emit logs.
            ::std::size_t runtime_log_curr_ip{};

            auto const runtime_log_bc_name{[](bool in_thunk) constexpr noexcept -> ::uwvm2::utils::container::u8string_view
                                           {
                                               if(in_thunk) { return ::uwvm2::utils::container::u8string_view{u8"thunk"}; }
                                               return ::uwvm2::utils::container::u8string_view{u8"main"};
                                           }};

            auto const runtime_log_op_name{
                [](::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code op) constexpr noexcept -> ::uwvm2::utils::container::u8string_view
                {
                    switch(op)
                    {
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::unreachable: return u8"unreachable";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::nop: return u8"nop";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::block: return u8"block";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::loop: return u8"loop";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::if_: return u8"if";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::else_: return u8"else";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::end: return u8"end";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::br: return u8"br";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::br_if: return u8"br_if";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::br_table: return u8"br_table";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::return_: return u8"return";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::call: return u8"call";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::call_indirect: return u8"call_indirect";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::drop: return u8"drop";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::select: return u8"select";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::local_get: return u8"local_get";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::local_set: return u8"local_set";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::local_tee: return u8"local_tee";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::global_get: return u8"global_get";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::global_set: return u8"global_set";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_load: return u8"i32_load";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_load: return u8"i64_load";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_load: return u8"f32_load";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_load: return u8"f64_load";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_load8_s: return u8"i32_load8_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_load8_u: return u8"i32_load8_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_load16_s: return u8"i32_load16_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_load16_u: return u8"i32_load16_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_load8_s: return u8"i64_load8_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_load8_u: return u8"i64_load8_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_load16_s: return u8"i64_load16_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_load16_u: return u8"i64_load16_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_load32_s: return u8"i64_load32_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_load32_u: return u8"i64_load32_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_store: return u8"i32_store";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_store: return u8"i64_store";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_store: return u8"f32_store";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_store: return u8"f64_store";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_store8: return u8"i32_store8";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_store16: return u8"i32_store16";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_store8: return u8"i64_store8";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_store16: return u8"i64_store16";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_store32: return u8"i64_store32";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::memory_size: return u8"memory_size";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::memory_grow: return u8"memory_grow";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_const: return u8"i32_const";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_const: return u8"i64_const";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_const: return u8"f32_const";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_const: return u8"f64_const";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_eqz: return u8"i32_eqz";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_eq: return u8"i32_eq";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_ne: return u8"i32_ne";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_lt_s: return u8"i32_lt_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_lt_u: return u8"i32_lt_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_gt_s: return u8"i32_gt_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_gt_u: return u8"i32_gt_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_le_s: return u8"i32_le_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_le_u: return u8"i32_le_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_ge_s: return u8"i32_ge_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_ge_u: return u8"i32_ge_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_eqz: return u8"i64_eqz";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_eq: return u8"i64_eq";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_ne: return u8"i64_ne";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_lt_s: return u8"i64_lt_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_lt_u: return u8"i64_lt_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_gt_s: return u8"i64_gt_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_gt_u: return u8"i64_gt_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_le_s: return u8"i64_le_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_le_u: return u8"i64_le_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_ge_s: return u8"i64_ge_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_ge_u: return u8"i64_ge_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_eq: return u8"f32_eq";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_ne: return u8"f32_ne";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_lt: return u8"f32_lt";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_gt: return u8"f32_gt";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_le: return u8"f32_le";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_ge: return u8"f32_ge";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_eq: return u8"f64_eq";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_ne: return u8"f64_ne";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_lt: return u8"f64_lt";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_gt: return u8"f64_gt";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_le: return u8"f64_le";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_ge: return u8"f64_ge";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_clz: return u8"i32_clz";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_ctz: return u8"i32_ctz";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_popcnt: return u8"i32_popcnt";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_add: return u8"i32_add";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_sub: return u8"i32_sub";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_mul: return u8"i32_mul";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_div_s: return u8"i32_div_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_div_u: return u8"i32_div_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_rem_s: return u8"i32_rem_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_rem_u: return u8"i32_rem_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_and: return u8"i32_and";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_or: return u8"i32_or";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_xor: return u8"i32_xor";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_shl: return u8"i32_shl";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_shr_s: return u8"i32_shr_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_shr_u: return u8"i32_shr_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_rotl: return u8"i32_rotl";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_rotr: return u8"i32_rotr";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_clz: return u8"i64_clz";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_ctz: return u8"i64_ctz";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_popcnt: return u8"i64_popcnt";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_add: return u8"i64_add";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_sub: return u8"i64_sub";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_mul: return u8"i64_mul";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_div_s: return u8"i64_div_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_div_u: return u8"i64_div_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_rem_s: return u8"i64_rem_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_rem_u: return u8"i64_rem_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_and: return u8"i64_and";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_or: return u8"i64_or";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_xor: return u8"i64_xor";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_shl: return u8"i64_shl";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_shr_s: return u8"i64_shr_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_shr_u: return u8"i64_shr_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_rotl: return u8"i64_rotl";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_rotr: return u8"i64_rotr";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_abs: return u8"f32_abs";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_neg: return u8"f32_neg";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_ceil: return u8"f32_ceil";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_floor: return u8"f32_floor";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_trunc: return u8"f32_trunc";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_nearest: return u8"f32_nearest";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_sqrt: return u8"f32_sqrt";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_add: return u8"f32_add";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_sub: return u8"f32_sub";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_mul: return u8"f32_mul";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_div: return u8"f32_div";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_min: return u8"f32_min";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_max: return u8"f32_max";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_copysign: return u8"f32_copysign";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_abs: return u8"f64_abs";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_neg: return u8"f64_neg";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_ceil: return u8"f64_ceil";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_floor: return u8"f64_floor";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_trunc: return u8"f64_trunc";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_nearest: return u8"f64_nearest";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_sqrt: return u8"f64_sqrt";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_add: return u8"f64_add";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_sub: return u8"f64_sub";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_mul: return u8"f64_mul";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_div: return u8"f64_div";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_min: return u8"f64_min";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_max: return u8"f64_max";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_copysign: return u8"f64_copysign";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_wrap_i64: return u8"i32_wrap_i64";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_trunc_f32_s: return u8"i32_trunc_f32_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_trunc_f32_u: return u8"i32_trunc_f32_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_trunc_f64_s: return u8"i32_trunc_f64_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_trunc_f64_u: return u8"i32_trunc_f64_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_extend_i32_s: return u8"i64_extend_i32_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_extend_i32_u: return u8"i64_extend_i32_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_trunc_f32_s: return u8"i64_trunc_f32_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_trunc_f32_u: return u8"i64_trunc_f32_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_trunc_f64_s: return u8"i64_trunc_f64_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_trunc_f64_u: return u8"i64_trunc_f64_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_convert_i32_s: return u8"f32_convert_i32_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_convert_i32_u: return u8"f32_convert_i32_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_convert_i64_s: return u8"f32_convert_i64_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_convert_i64_u: return u8"f32_convert_i64_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_demote_f64: return u8"f32_demote_f64";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_convert_i32_s: return u8"f64_convert_i32_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_convert_i32_u: return u8"f64_convert_i32_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_convert_i64_s: return u8"f64_convert_i64_s";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_convert_i64_u: return u8"f64_convert_i64_u";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_promote_f32: return u8"f64_promote_f32";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i32_reinterpret_f32: return u8"i32_reinterpret_f32";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::i64_reinterpret_f64: return u8"i64_reinterpret_f64";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f32_reinterpret_i32: return u8"f32_reinterpret_i32";
                        case ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code::f64_reinterpret_i64:
                            return u8"f64_reinterpret_i64";
                        [[unlikely]] default:
                            return u8"<unknown>";
                    }
                }};

            auto const runtime_log_vt_name{[]([[maybe_unused]] curr_operand_stack_value_type vt) constexpr noexcept -> ::uwvm2::utils::container::u8string_view
                                           {
                                               switch(vt)
                                               {
                                                   case curr_operand_stack_value_type::i32: return u8"i32";
                                                   case curr_operand_stack_value_type::i64: return u8"i64";
                                                   case curr_operand_stack_value_type::f32: return u8"f32";
                                                   case curr_operand_stack_value_type::f64:
                                                       return u8"f64";
                                                   [[unlikely]] default:
                                                       return u8"?";
                                               }
                                           }};

            auto const bytecode_reserve_suggest{[&]() constexpr noexcept
                                                {
                                                    // Heuristic: most ops expand from 1 byte opcode to (ptr + immediates). Use a conservative multiplier.
                                                    auto const code_size{static_cast<::std::size_t>(code_end - code_begin)};
                                                    // Reduce upfront allocations for modules with many small functions.
                                                    // The emitter grows geometrically if this estimate is too small.
                                                    constexpr ::std::size_t mul{8uz};
                                                    if(code_size > (::std::numeric_limits<::std::size_t>::max() / mul))
                                                    {
                                                        // Overflow-safe fallback: skip the multiplier rather than attempting an impossible reserve().
                                                        return code_size;
                                                    }
                                                    return code_size * mul;
                                                }()};
            bytecode.reserve(bytecode_reserve_suggest);

            auto const ensure_vec_capacity{[&](bytecode_vec_t& dst, ::std::size_t add_bytes) constexpr UWVM_THROWS
                                           {
                                               auto const curr{dst.size()};
                                               if(add_bytes > (::std::numeric_limits<::std::size_t>::max() - curr)) [[unlikely]]
                                               {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                                   ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                                   ::fast_io::fast_terminate();
                                               }
                                               auto const need{curr + add_bytes};
                                               if(need <= dst.capacity()) { return; }

                                               // Grow geometrically to preserve amortized O(1) push_back.
                                               ::std::size_t new_cap{dst.capacity()};
                                               if(new_cap == 0uz) { new_cap = 1uz; }
                                               while(new_cap < need)
                                               {
                                                   if(new_cap > (::std::numeric_limits<::std::size_t>::max() / 2uz))
                                                   {
                                                       new_cap = need;
                                                       break;
                                                   }
                                                   new_cap *= 2uz;
                                               }
                                               dst.reserve(new_cap);
                                           }};

            auto const emit_bytes_to{[&](bytecode_vec_t& dst, ::std::byte const* src, ::std::size_t n) constexpr UWVM_THROWS
                                     {
                                         if(n == 0uz) { return; }
                                         ensure_vec_capacity(dst, n);
                                         auto out{dst.imp.curr_ptr};
                                         dst.imp.curr_ptr += n;
                                         ::std::memcpy(out, src, n);
                                     }};

            auto const emit_imm_to{[&]<typename T>(bytecode_vec_t& dst, T const& v) constexpr UWVM_THROWS
                                   {
                                       static_assert(::std::is_trivially_copyable_v<T>);
                                       ensure_vec_capacity(dst, sizeof(T));
                                       auto out{dst.imp.curr_ptr};
                                       dst.imp.curr_ptr += sizeof(T);
                                       ::std::memcpy(out, ::std::addressof(v), sizeof(T));
                                   }};

            auto const emit_imm{[&]<typename T>(T const& v) constexpr UWVM_THROWS { emit_imm_to(bytecode, v); }};

            labels.clear();
            ptr_fixups.clear();

            auto const new_label{[&](bool in_thunk) constexpr UWVM_THROWS -> ::std::size_t
                                 {
                                     if(labels.size() == labels.capacity()) { labels.reserve(labels.capacity() ? labels.capacity() * 2uz : 64uz); }
                                     // Safe: ensured capacity.
                                     labels.push_back_unchecked(label_info_t{.offset = SIZE_MAX, .in_thunk = in_thunk});
                                     return labels.size() - 1uz;
                                 }};

            auto const set_label_offset{[&](::std::size_t label_id, ::std::size_t off) constexpr noexcept { labels.index_unchecked(label_id).offset = off; }};

            // Thunk bytecode (appended after main `bytecode` so it never shifts main offsets).
            thunks.clear();

            auto const emit_ptr_label_placeholder{[&](::std::size_t label_id, bool in_thunk) constexpr UWVM_THROWS
                                                  {
                                                      rel_offset_t const placeholder{};
                                                      ::std::size_t const site{in_thunk ? thunks.size() : bytecode.size()};
                                                      if(runtime_log_on) [[unlikely]]
                                                      {
                                                          if(in_thunk) { ++runtime_log_stats.label_placeholder_thunk_count; }
                                                          else
                                                          {
                                                              ++runtime_log_stats.label_placeholder_main_count;
                                                          }
                                                          if(runtime_log_emit_cf)
                                                          {
                                                              ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                                   u8"[uwvm-int-translator] fn=",
                                                                                   function_index,
                                                                                   u8" ip=",
                                                                                   runtime_log_curr_ip,
                                                                                   u8" event=bytecode.emit.imm | kind=label_placeholder bc=",
                                                                                   runtime_log_bc_name(in_thunk),
                                                                                   u8" off=",
                                                                                   site,
                                                                                   u8" label_id=",
                                                                                   label_id,
                                                                                   u8"\n");
                                                          }
                                                      }
                                                      if(in_thunk) { emit_imm_to(thunks, placeholder); }
                                                      else
                                                      {
                                                          emit_imm(placeholder);
                                                      }

                                                      if(ptr_fixups.size() == ptr_fixups.capacity())
                                                      {
                                                          ptr_fixups.reserve(ptr_fixups.capacity() ? ptr_fixups.capacity() * 2uz : 256uz);
                                                      }
                                                      // Safe: ensured capacity.
                                                      ptr_fixups.push_back_unchecked(ptr_fixup_t{.site = site, .label_id = label_id, .in_thunk = in_thunk});
                                                  }};

            auto const get_branch_target_label_id{[&](block_t const& frame) constexpr noexcept -> ::std::size_t
                                                  {
                                                      // For Wasm structured control:
                                                      // - block/if/else/function: label target is the end.
                                                      // - loop: label target is the start.
                                                      return frame.type == block_type::loop ? frame.start_label_id : frame.end_label_id;
                                                  }};

            auto const emit_opfunc_to{[&](bytecode_vec_t& dst, auto fptr) constexpr UWVM_THROWS
                                      {
                                          if(runtime_log_on) [[unlikely]]
                                          {
                                              bool const dst_is_thunk{::std::addressof(dst) == ::std::addressof(thunks)};
                                              ::std::size_t const off{dst.size()};
                                              if(dst_is_thunk) { ++runtime_log_stats.opfunc_thunk_count; }
                                              else
                                              {
                                                  ++runtime_log_stats.opfunc_main_count;
                                              }
                                              if(runtime_log_emit_opfuncs)
                                              {
                                                  // Print the raw opfunc pointer bits stored into the bytecode stream.
                                                  ::std::uintptr_t bits{};
                                                  constexpr ::std::size_t copy_n{sizeof(bits) < sizeof(fptr) ? sizeof(bits) : sizeof(fptr)};
                                                  ::std::memcpy(::std::addressof(bits), ::std::addressof(fptr), copy_n);
                                                  ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                       u8"[uwvm-int-translator] fn=",
                                                                       function_index,
                                                                       u8" ip=",
                                                                       runtime_log_curr_ip,
                                                                       u8" event=bytecode.emit.opfunc | bc=",
                                                                       runtime_log_bc_name(dst_is_thunk),
                                                                       u8" off=",
                                                                       off,
                                                                       u8" sz=",
                                                                       sizeof(fptr),
                                                                       u8" fptr_bits=",
                                                                       ::fast_io::mnp::hex0x(bits),
                                                                       u8"\n");
                                              }
                                          }

                                          // Best-effort: prefetch the opfunc's instruction stream into cache.
                                          // This attempts to reduce cold I$ misses when the threaded interpreter dispatches to the opfunc.
                                          if UWVM_IF_NOT_CONSTEVAL
                                          {
                                              using fptr_t = decltype(fptr);
                                              if constexpr(::std::is_pointer_v<fptr_t>)
                                              {
                                                  auto const addr{reinterpret_cast<void const*>(fptr)};
                                                  ::uwvm2::utils::intrinsics::universal::prefetch<::uwvm2::utils::intrinsics::universal::pfc_mode::instruction,
                                                                                                  ::uwvm2::utils::intrinsics::universal::pfc_level::L2>(addr);
                                              }
                                          }

                                          // Note: We intentionally store the raw function pointer bytes into the bytecode stream.
                                          emit_imm_to(dst, fptr);
                                      }};

            // ============================
            // Stack-top cache manipulation
            // ============================

            [[maybe_unused]] auto const codegen_stack_push{
                [&](curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                {
                    if(codegen_operand_stack.size() == codegen_operand_stack.capacity())
                    {
                        codegen_operand_stack.reserve(codegen_operand_stack.capacity() ? codegen_operand_stack.capacity() * 2uz : 64uz);
                    }
                    // Safe: ensured capacity.
                    codegen_operand_stack.push_back_unchecked({.type = vt});
                }};

            [[maybe_unused]] auto const codegen_stack_pop_n{[&](::std::size_t n) constexpr noexcept
                                                            {
                                                                while(n-- != 0uz)
                                                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                                                    if(codegen_operand_stack.empty()) [[unlikely]]
                                                                    {
                                                                        ::uwvm2::utils::debug::trap_and_inform_bug_pos();
                                                                    }
#endif
                                                                    if(codegen_operand_stack.empty()) { return; }
                                                                    codegen_operand_stack.pop_back_unchecked();
                                                                }
                                                            }};

            [[maybe_unused]] auto const codegen_stack_set_top{
                [&](curr_operand_stack_value_type vt) constexpr noexcept
                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                    if(codegen_operand_stack.empty()) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                    if(codegen_operand_stack.empty()) { return; }
                    if constexpr(stacktop_enabled)
                    {
                        if(!is_polymorphic && stacktop_cache_count != 0uz)
                        {
                            auto const old_vt{codegen_operand_stack.back_unchecked().type};
                            if(old_vt != vt)
                            {
                                auto const cache_count_ref_for_vt{[&]([[maybe_unused]] curr_operand_stack_value_type ty) constexpr noexcept -> ::std::size_t&
                                                                  {
                                                                      switch(ty)
                                                                      {
                                                                          case curr_operand_stack_value_type::i32:
                                                                          {
                                                                              return stacktop_cache_i32_count;
                                                                          }
                                                                          case curr_operand_stack_value_type::i64:
                                                                          {
                                                                              return stacktop_cache_i64_count;
                                                                          }
                                                                          case curr_operand_stack_value_type::f32:
                                                                          {
                                                                              return stacktop_cache_f32_count;
                                                                          }
                                                                          case curr_operand_stack_value_type::f64:
                                                                          {
                                                                              return stacktop_cache_f64_count;
                                                                          }
                                                                          [[unlikely]] default:
                                                                          {
                                                                              return stacktop_cache_i32_count;
                                                                          }
                                                                      }
                                                                  }};

                                // The top value is always inside the cached segment when `stacktop_cache_count != 0`.
                                --cache_count_ref_for_vt(old_vt);
                                ++cache_count_ref_for_vt(vt);
                            }
                        }
                    }
                    codegen_operand_stack.back_unchecked().type = vt;
                }};

            constexpr auto stacktop_range_begin_pos{[](curr_operand_stack_value_type vt) constexpr noexcept -> ::std::size_t
                                                    {
                                                        switch(vt)
                                                        {
                                                            case curr_operand_stack_value_type::i32:
                                                            {
                                                                return CompileOption.i32_stack_top_begin_pos;
                                                            }
                                                            case curr_operand_stack_value_type::i64:
                                                            {
                                                                return CompileOption.i64_stack_top_begin_pos;
                                                            }
                                                            case curr_operand_stack_value_type::f32:
                                                            {
                                                                return CompileOption.f32_stack_top_begin_pos;
                                                            }
                                                            case curr_operand_stack_value_type::f64:
                                                            {
                                                                return CompileOption.f64_stack_top_begin_pos;
                                                            }
                                                            [[unlikely]] default:
                                                            {
                                                                return SIZE_MAX;
                                                            }
                                                        }
                                                    }};

            constexpr auto stacktop_range_end_pos{[](curr_operand_stack_value_type vt) constexpr noexcept -> ::std::size_t
                                                  {
                                                      switch(vt)
                                                      {
                                                          case curr_operand_stack_value_type::i32:
                                                          {
                                                              return CompileOption.i32_stack_top_end_pos;
                                                          }
                                                          case curr_operand_stack_value_type::i64:
                                                          {
                                                              return CompileOption.i64_stack_top_end_pos;
                                                          }
                                                          case curr_operand_stack_value_type::f32:
                                                          {
                                                              return CompileOption.f32_stack_top_end_pos;
                                                          }
                                                          case curr_operand_stack_value_type::f64:
                                                          {
                                                              return CompileOption.f64_stack_top_end_pos;
                                                          }
                                                          [[unlikely]] default:
                                                          {
                                                              return SIZE_MAX;
                                                          }
                                                      }
                                                  }};

            [[maybe_unused]] constexpr auto stacktop_enabled_for_vt{
                [](curr_operand_stack_value_type vt) constexpr noexcept -> bool
                {
                    switch(vt)
                    {
                        case curr_operand_stack_value_type::i32:
                        {
                            return CompileOption.i32_stack_top_begin_pos != CompileOption.i32_stack_top_end_pos;
                        }
                        case curr_operand_stack_value_type::i64:
                        {
                            return CompileOption.i64_stack_top_begin_pos != CompileOption.i64_stack_top_end_pos;
                        }
                        case curr_operand_stack_value_type::f32:
                        {
                            return CompileOption.f32_stack_top_begin_pos != CompileOption.f32_stack_top_end_pos;
                        }
                        case curr_operand_stack_value_type::f64:
                        {
                            return CompileOption.f64_stack_top_begin_pos != CompileOption.f64_stack_top_end_pos;
                        }
                        [[unlikely]] default:
                        {
                            return false;
                        }
                    }
                }};

            [[maybe_unused]] constexpr auto stacktop_ranges_merged_for{
                [](curr_operand_stack_value_type l, curr_operand_stack_value_type r) constexpr noexcept -> bool
                {
                    auto const begin_pos{[](curr_operand_stack_value_type vt) constexpr noexcept -> ::std::size_t
                                         {
                                             switch(vt)
                                             {
                                                 case curr_operand_stack_value_type::i32: return CompileOption.i32_stack_top_begin_pos;
                                                 case curr_operand_stack_value_type::i64: return CompileOption.i64_stack_top_begin_pos;
                                                 case curr_operand_stack_value_type::f32: return CompileOption.f32_stack_top_begin_pos;
                                                 case curr_operand_stack_value_type::f64:
                                                     return CompileOption.f64_stack_top_begin_pos;
                                                 [[unlikely]] default:
                                                     return SIZE_MAX;
                                             }
                                         }};

                    auto const end_pos{[](curr_operand_stack_value_type vt) constexpr noexcept -> ::std::size_t
                                       {
                                           switch(vt)
                                           {
                                               case curr_operand_stack_value_type::i32: return CompileOption.i32_stack_top_end_pos;
                                               case curr_operand_stack_value_type::i64: return CompileOption.i64_stack_top_end_pos;
                                               case curr_operand_stack_value_type::f32: return CompileOption.f32_stack_top_end_pos;
                                               case curr_operand_stack_value_type::f64:
                                                   return CompileOption.f64_stack_top_end_pos;
                                               [[unlikely]] default:
                                                   return SIZE_MAX;
                                           }
                                       }};

                    return begin_pos(l) == begin_pos(r) && end_pos(l) == end_pos(r);
                }};

            auto const stacktop_cache_count_ref_for_vt{[&](curr_operand_stack_value_type vt) constexpr noexcept -> ::std::size_t&
                                                       {
                                                           switch(vt)
                                                           {
                                                               case curr_operand_stack_value_type::i32:
                                                               {
                                                                   return stacktop_cache_i32_count;
                                                               }
                                                               case curr_operand_stack_value_type::i64:
                                                               {
                                                                   return stacktop_cache_i64_count;
                                                               }
                                                               case curr_operand_stack_value_type::f32:
                                                               {
                                                                   return stacktop_cache_f32_count;
                                                               }
                                                               case curr_operand_stack_value_type::f64:
                                                               {
                                                                   return stacktop_cache_f64_count;
                                                               }
                                                               [[unlikely]] default:
                                                               {
                                                                   return stacktop_cache_i32_count;
                                                               }
                                                           }
                                                       }};

            auto const stacktop_cache_count_for_range{
                [&](::std::size_t begin_pos, ::std::size_t end_pos) constexpr noexcept -> ::std::size_t
                {
                    ::std::size_t sum{};
                    if(stacktop_i32_enabled && begin_pos == CompileOption.i32_stack_top_begin_pos && end_pos == CompileOption.i32_stack_top_end_pos)
                    {
                        sum += stacktop_cache_i32_count;
                    }
                    if(stacktop_i64_enabled && begin_pos == CompileOption.i64_stack_top_begin_pos && end_pos == CompileOption.i64_stack_top_end_pos)
                    {
                        sum += stacktop_cache_i64_count;
                    }
                    if(stacktop_f32_enabled && begin_pos == CompileOption.f32_stack_top_begin_pos && end_pos == CompileOption.f32_stack_top_end_pos)
                    {
                        sum += stacktop_cache_f32_count;
                    }
                    if(stacktop_f64_enabled && begin_pos == CompileOption.f64_stack_top_begin_pos && end_pos == CompileOption.f64_stack_top_end_pos)
                    {
                        sum += stacktop_cache_f64_count;
                    }
                    // Note: wasm1 codegen never produces v128 values, so no v128 cache-count here.
                    return sum;
                }};

            // Reconcile per-type cache counters from the codegen type stack.
            // This protects against missing/incorrect per-type updates on ops that only retype the top value
            // (e.g., reinterpret/extend) while keeping stack depth unchanged.
            [[maybe_unused]] auto const stacktop_rebuild_cache_type_counts_from_codegen{
                [&]() constexpr noexcept
                {
                    if constexpr(!stacktop_enabled) { return; }
                    if(is_polymorphic) { return; }

                    stacktop_cache_i32_count = 0uz;
                    stacktop_cache_i64_count = 0uz;
                    stacktop_cache_f32_count = 0uz;
                    stacktop_cache_f64_count = 0uz;

                    auto const total{codegen_operand_stack.size()};
                    auto cache_n{stacktop_cache_count};
                    if(cache_n > total) { cache_n = total; }
                    auto const start{total - cache_n};
                    for(::std::size_t i{}; i != cache_n; ++i)
                    {
                        auto const vt{codegen_operand_stack.index_unchecked(start + i).type};
                        ++stacktop_cache_count_ref_for_vt(vt);
                    }
                }};

            auto const stacktop_currpos_for_range{
                [&](::std::size_t begin_pos, ::std::size_t end_pos) constexpr noexcept -> ::std::size_t
                {
                    if(stacktop_i32_enabled && begin_pos == CompileOption.i32_stack_top_begin_pos && end_pos == CompileOption.i32_stack_top_end_pos)
                    {
                        return curr_stacktop.i32_stack_top_curr_pos;
                    }
                    if(stacktop_i64_enabled && begin_pos == CompileOption.i64_stack_top_begin_pos && end_pos == CompileOption.i64_stack_top_end_pos)
                    {
                        return curr_stacktop.i64_stack_top_curr_pos;
                    }
                    if(stacktop_f32_enabled && begin_pos == CompileOption.f32_stack_top_begin_pos && end_pos == CompileOption.f32_stack_top_end_pos)
                    {
                        return curr_stacktop.f32_stack_top_curr_pos;
                    }
                    if(stacktop_f64_enabled && begin_pos == CompileOption.f64_stack_top_begin_pos && end_pos == CompileOption.f64_stack_top_end_pos)
                    {
                        return curr_stacktop.f64_stack_top_curr_pos;
                    }
                    if(stacktop_v128_enabled && begin_pos == CompileOption.v128_stack_top_begin_pos && end_pos == CompileOption.v128_stack_top_end_pos)
                    {
                        return curr_stacktop.v128_stack_top_curr_pos;
                    }
                    return SIZE_MAX;
                }};

            auto const stacktop_set_currpos_for_range{
                [&](::std::size_t begin_pos, ::std::size_t end_pos, ::std::size_t pos) constexpr noexcept
                {
                    if(stacktop_i32_enabled && begin_pos == CompileOption.i32_stack_top_begin_pos && end_pos == CompileOption.i32_stack_top_end_pos)
                    {
                        curr_stacktop.i32_stack_top_curr_pos = pos;
                    }
                    if(stacktop_i64_enabled && begin_pos == CompileOption.i64_stack_top_begin_pos && end_pos == CompileOption.i64_stack_top_end_pos)
                    {
                        curr_stacktop.i64_stack_top_curr_pos = pos;
                    }
                    if(stacktop_f32_enabled && begin_pos == CompileOption.f32_stack_top_begin_pos && end_pos == CompileOption.f32_stack_top_end_pos)
                    {
                        curr_stacktop.f32_stack_top_curr_pos = pos;
                    }
                    if(stacktop_f64_enabled && begin_pos == CompileOption.f64_stack_top_begin_pos && end_pos == CompileOption.f64_stack_top_end_pos)
                    {
                        curr_stacktop.f64_stack_top_curr_pos = pos;
                    }
                    if(stacktop_v128_enabled && begin_pos == CompileOption.v128_stack_top_begin_pos && end_pos == CompileOption.v128_stack_top_end_pos)
                    {
                        curr_stacktop.v128_stack_top_curr_pos = pos;
                    }
                }};

            auto const stacktop_ring_prev{[&](::std::size_t pos, ::std::size_t begin_pos, ::std::size_t end_pos) constexpr noexcept -> ::std::size_t
                                          { return pos == begin_pos ? (end_pos - 1uz) : (pos - 1uz); }};

            auto const stacktop_ring_next{[&](::std::size_t pos, ::std::size_t begin_pos, ::std::size_t end_pos) constexpr noexcept -> ::std::size_t
                                          { return (pos + 1uz == end_pos) ? begin_pos : (pos + 1uz); }};

            auto const stacktop_ring_advance_next{
                [&](::std::size_t pos, ::std::size_t n, ::std::size_t begin_pos, ::std::size_t end_pos) constexpr noexcept -> ::std::size_t
                {
                    for(::std::size_t i{}; i != n; ++i) { pos = stacktop_ring_next(pos, begin_pos, end_pos); }
                    return pos;
                }};

#if 0
            [[maybe_unused]] auto const stacktop_ring_advance_prev{
                [&](::std::size_t pos, ::std::size_t n, ::std::size_t begin_pos, ::std::size_t end_pos) constexpr noexcept -> ::std::size_t
                {
                    for(::std::size_t i{}; i != n; ++i) { pos = stacktop_ring_prev(pos, begin_pos, end_pos); }
                    return pos;
                }};
#endif

#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
            auto const stacktop_runtime_depth{[&]() constexpr noexcept -> ::std::size_t { return stacktop_memory_count + stacktop_cache_count; }};
#endif

            auto const stacktop_assert_invariants{
                [&]() constexpr noexcept
                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                    if constexpr(stacktop_enabled)
                    {
                        // Stack-top cache model is tied to the emitted bytecode stream; validate against the
                        // codegen type stack, not the validator operand stack (which can be ahead during conbine).
                        if(stacktop_runtime_depth() != codegen_operand_stack.size()) [[unlikely]]
                        {
                            using op_underlying_t = ::std::underlying_type_t<::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code>;
                            auto const op_u{static_cast<::std::uint_least32_t>(static_cast<op_underlying_t>(stacktop_dbg_last_op))};

                            ::fast_io::io::perr(::fast_io::u8err(),
                                                u8"[uwvm-int-translator] stacktop invariant failure: fn=",
                                                function_index,
                                                u8" ip=",
                                                stacktop_dbg_last_ip,
                                                u8" op=",
                                                runtime_log_op_name(stacktop_dbg_last_op),
                                                u8" op_u=",
                                                ::fast_io::mnp::hex0x(op_u),
                                                u8" stacktop{mem=",
                                                stacktop_memory_count,
                                                u8",cache=",
                                                stacktop_cache_count,
                                                u8"} codegen_sz=",
                                                codegen_operand_stack.size(),
                                                u8" operand_sz=",
                                                operand_stack.size(),
                                                u8" polymorphic=",
                                                is_polymorphic,
                                                u8"\n");

                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
                        }

                        if(stacktop_cache_i32_count + stacktop_cache_i64_count + stacktop_cache_f32_count + stacktop_cache_f64_count != stacktop_cache_count)
                        {
                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
                        }

                        auto const check_currpos_in_range{[&]([[maybe_unused]] ::std::size_t pos,
                                                              [[maybe_unused]] ::std::size_t begin_pos,
                                                              [[maybe_unused]] ::std::size_t end_pos) constexpr noexcept
                                                          {
                                                              if(pos < begin_pos || pos >= end_pos) [[unlikely]]
                                                              {
                                                                  ::uwvm2::utils::debug::trap_and_inform_bug_pos();
                                                              }
                                                          }};

                        if(stacktop_i32_enabled)
                        {
                            check_currpos_in_range(curr_stacktop.i32_stack_top_curr_pos,
                                                   CompileOption.i32_stack_top_begin_pos,
                                                   CompileOption.i32_stack_top_end_pos);
                        }
                        if(stacktop_i64_enabled)
                        {
                            check_currpos_in_range(curr_stacktop.i64_stack_top_curr_pos,
                                                   CompileOption.i64_stack_top_begin_pos,
                                                   CompileOption.i64_stack_top_end_pos);
                        }
                        if(stacktop_f32_enabled)
                        {
                            check_currpos_in_range(curr_stacktop.f32_stack_top_curr_pos,
                                                   CompileOption.f32_stack_top_begin_pos,
                                                   CompileOption.f32_stack_top_end_pos);
                        }
                        if(stacktop_f64_enabled)
                        {
                            check_currpos_in_range(curr_stacktop.f64_stack_top_curr_pos,
                                                   CompileOption.f64_stack_top_begin_pos,
                                                   CompileOption.f64_stack_top_end_pos);
                        }
                        if(stacktop_v128_enabled)
                        {
                            check_currpos_in_range(curr_stacktop.v128_stack_top_curr_pos,
                                                   CompileOption.v128_stack_top_begin_pos,
                                                   CompileOption.v128_stack_top_end_pos);
                        }

                        // Capacity check per range (use direct sites so the reported line identifies the failing range).
                        if(stacktop_i32_enabled)
                        {
                            auto const begin_pos{CompileOption.i32_stack_top_begin_pos};
                            auto const end_pos{CompileOption.i32_stack_top_end_pos};
                            auto const cnt{stacktop_cache_count_for_range(begin_pos, end_pos)};
                            auto const cap{end_pos - begin_pos};
                            if(cnt > cap) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
                        }
                        if(stacktop_i64_enabled)
                        {
                            auto const begin_pos{CompileOption.i64_stack_top_begin_pos};
                            auto const end_pos{CompileOption.i64_stack_top_end_pos};
                            auto const cnt{stacktop_cache_count_for_range(begin_pos, end_pos)};
                            auto const cap{end_pos - begin_pos};
                            if(cnt > cap) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
                        }
                        if(stacktop_f32_enabled)
                        {
                            auto const begin_pos{CompileOption.f32_stack_top_begin_pos};
                            auto const end_pos{CompileOption.f32_stack_top_end_pos};
                            auto const cnt{stacktop_cache_count_for_range(begin_pos, end_pos)};
                            auto const cap{end_pos - begin_pos};
                            if(cnt > cap) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
                        }
                        if(stacktop_f64_enabled)
                        {
                            auto const begin_pos{CompileOption.f64_stack_top_begin_pos};
                            auto const end_pos{CompileOption.f64_stack_top_end_pos};
                            auto const cnt{stacktop_cache_count_for_range(begin_pos, end_pos)};
                            auto const cap{end_pos - begin_pos};
                            if(cnt > cap) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
                        }
                        if(stacktop_v128_enabled)
                        {
                            auto const begin_pos{CompileOption.v128_stack_top_begin_pos};
                            auto const end_pos{CompileOption.v128_stack_top_end_pos};
                            auto const cnt{stacktop_cache_count_for_range(begin_pos, end_pos)};
                            auto const cap{end_pos - begin_pos};
                            if(cnt > cap) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
                        }
                    }
#endif
                }};

            auto const emit_stacktop_spill1_typed_to{
                [&]([[maybe_unused]] bytecode_vec_t& dst,
                    [[maybe_unused]] ::std::size_t slot,
                    [[maybe_unused]] curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                {
                    if constexpr(stacktop_enabled)
                    {
                        if(runtime_log_on) [[unlikely]]
                        {
                            ++runtime_log_stats.stacktop_spill1_count;
                            ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                 u8"[uwvm-int-translator] fn=",
                                                 function_index,
                                                 u8" event=stacktop.spill1 | vt=",
                                                 runtime_log_vt_name(vt),
                                                 u8" slot=",
                                                 slot,
                                                 u8" currpos{i32=",
                                                 curr_stacktop.i32_stack_top_curr_pos,
                                                 u8",i64=",
                                                 curr_stacktop.i64_stack_top_curr_pos,
                                                 u8",f32=",
                                                 curr_stacktop.f32_stack_top_curr_pos,
                                                 u8",f64=",
                                                 curr_stacktop.f64_stack_top_curr_pos,
                                                 u8",v128=",
                                                 curr_stacktop.v128_stack_top_curr_pos,
                                                 u8"} stacktop{mem=",
                                                 stacktop_memory_count,
                                                 u8",cache=",
                                                 stacktop_cache_count,
                                                 u8"}\n");
                        }

                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        switch(vt)
                        {
                            case curr_operand_stack_value_type::i32:
                            {
                                emit_opfunc_to(dst,
                                               translate::get_uwvmint_stacktop_to_operand_stack_typed_single_fptr_from_tuple<
                                                   CompileOption,
                                                   ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32>(slot, interpreter_tuple));
                                break;
                            }
                            case curr_operand_stack_value_type::i64:
                            {
                                emit_opfunc_to(dst,
                                               translate::get_uwvmint_stacktop_to_operand_stack_typed_single_fptr_from_tuple<
                                                   CompileOption,
                                                   ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64>(slot, interpreter_tuple));
                                break;
                            }
                            case curr_operand_stack_value_type::f32:
                            {
                                emit_opfunc_to(dst,
                                               translate::get_uwvmint_stacktop_to_operand_stack_typed_single_fptr_from_tuple<
                                                   CompileOption,
                                                   ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32>(slot, interpreter_tuple));
                                break;
                            }
                            case curr_operand_stack_value_type::f64:
                            {
                                emit_opfunc_to(dst,
                                               translate::get_uwvmint_stacktop_to_operand_stack_typed_single_fptr_from_tuple<
                                                   CompileOption,
                                                   ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64>(slot, interpreter_tuple));
                                break;
                            }
                            [[unlikely]] default:
                            {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                break;
                            }
                        }
                    }
                }};

            // Compile-time: whether each value-type range is disjoint (not merged) with other enabled ranges.
            // If a range is merged, the untyped multi-count spill/fill opfuncs are not usable (they require StartPos to hit exactly one range),
            // so we must fall back to single-value typed spill/fill.
            [[maybe_unused]] constexpr auto const stacktop_same_range{
                [](::std::size_t a_begin, ::std::size_t a_end, ::std::size_t b_begin, ::std::size_t b_end) constexpr noexcept -> bool
                { return a_begin == b_begin && a_end == b_end; }};

            [[maybe_unused]] constexpr bool const i32_range_unique{stacktop_i32_enabled &&
                                                                   ((1uz) +
                                                                    (stacktop_i64_enabled && stacktop_same_range(CompileOption.i32_stack_top_begin_pos,
                                                                                                                 CompileOption.i32_stack_top_end_pos,
                                                                                                                 CompileOption.i64_stack_top_begin_pos,
                                                                                                                 CompileOption.i64_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_f32_enabled && stacktop_same_range(CompileOption.i32_stack_top_begin_pos,
                                                                                                                 CompileOption.i32_stack_top_end_pos,
                                                                                                                 CompileOption.f32_stack_top_begin_pos,
                                                                                                                 CompileOption.f32_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_f64_enabled && stacktop_same_range(CompileOption.i32_stack_top_begin_pos,
                                                                                                                 CompileOption.i32_stack_top_end_pos,
                                                                                                                 CompileOption.f64_stack_top_begin_pos,
                                                                                                                 CompileOption.f64_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_v128_enabled && stacktop_same_range(CompileOption.i32_stack_top_begin_pos,
                                                                                                                  CompileOption.i32_stack_top_end_pos,
                                                                                                                  CompileOption.v128_stack_top_begin_pos,
                                                                                                                  CompileOption.v128_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz)) == 1uz};

            [[maybe_unused]] constexpr bool const i64_range_unique{stacktop_i64_enabled &&
                                                                   ((1uz) +
                                                                    (stacktop_i32_enabled && stacktop_same_range(CompileOption.i64_stack_top_begin_pos,
                                                                                                                 CompileOption.i64_stack_top_end_pos,
                                                                                                                 CompileOption.i32_stack_top_begin_pos,
                                                                                                                 CompileOption.i32_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_f32_enabled && stacktop_same_range(CompileOption.i64_stack_top_begin_pos,
                                                                                                                 CompileOption.i64_stack_top_end_pos,
                                                                                                                 CompileOption.f32_stack_top_begin_pos,
                                                                                                                 CompileOption.f32_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_f64_enabled && stacktop_same_range(CompileOption.i64_stack_top_begin_pos,
                                                                                                                 CompileOption.i64_stack_top_end_pos,
                                                                                                                 CompileOption.f64_stack_top_begin_pos,
                                                                                                                 CompileOption.f64_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_v128_enabled && stacktop_same_range(CompileOption.i64_stack_top_begin_pos,
                                                                                                                  CompileOption.i64_stack_top_end_pos,
                                                                                                                  CompileOption.v128_stack_top_begin_pos,
                                                                                                                  CompileOption.v128_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz)) == 1uz};

            [[maybe_unused]] constexpr bool const f32_range_unique{stacktop_f32_enabled &&
                                                                   ((1uz) +
                                                                    (stacktop_i32_enabled && stacktop_same_range(CompileOption.f32_stack_top_begin_pos,
                                                                                                                 CompileOption.f32_stack_top_end_pos,
                                                                                                                 CompileOption.i32_stack_top_begin_pos,
                                                                                                                 CompileOption.i32_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_i64_enabled && stacktop_same_range(CompileOption.f32_stack_top_begin_pos,
                                                                                                                 CompileOption.f32_stack_top_end_pos,
                                                                                                                 CompileOption.i64_stack_top_begin_pos,
                                                                                                                 CompileOption.i64_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_f64_enabled && stacktop_same_range(CompileOption.f32_stack_top_begin_pos,
                                                                                                                 CompileOption.f32_stack_top_end_pos,
                                                                                                                 CompileOption.f64_stack_top_begin_pos,
                                                                                                                 CompileOption.f64_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_v128_enabled && stacktop_same_range(CompileOption.f32_stack_top_begin_pos,
                                                                                                                  CompileOption.f32_stack_top_end_pos,
                                                                                                                  CompileOption.v128_stack_top_begin_pos,
                                                                                                                  CompileOption.v128_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz)) == 1uz};

            [[maybe_unused]] constexpr bool const f64_range_unique{stacktop_f64_enabled &&
                                                                   ((1uz) +
                                                                    (stacktop_i32_enabled && stacktop_same_range(CompileOption.f64_stack_top_begin_pos,
                                                                                                                 CompileOption.f64_stack_top_end_pos,
                                                                                                                 CompileOption.i32_stack_top_begin_pos,
                                                                                                                 CompileOption.i32_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_i64_enabled && stacktop_same_range(CompileOption.f64_stack_top_begin_pos,
                                                                                                                 CompileOption.f64_stack_top_end_pos,
                                                                                                                 CompileOption.i64_stack_top_begin_pos,
                                                                                                                 CompileOption.i64_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_f32_enabled && stacktop_same_range(CompileOption.f64_stack_top_begin_pos,
                                                                                                                 CompileOption.f64_stack_top_end_pos,
                                                                                                                 CompileOption.f32_stack_top_begin_pos,
                                                                                                                 CompileOption.f32_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz) +
                                                                    (stacktop_v128_enabled && stacktop_same_range(CompileOption.f64_stack_top_begin_pos,
                                                                                                                  CompileOption.f64_stack_top_end_pos,
                                                                                                                  CompileOption.v128_stack_top_begin_pos,
                                                                                                                  CompileOption.v128_stack_top_end_pos)
                                                                         ? 1uz
                                                                         : 0uz)) == 1uz};

            // Emit a multi-value spill (cache -> memory) for a **single scalar type**.
            // This reduces bytecode size and dispatch overhead by combining consecutive spills into one threaded-interpreter opfunc.
            [[maybe_unused]] auto const emit_stacktop_spilln_same_vt_to{
                [&]([[maybe_unused]] bytecode_vec_t& dst,
                    [[maybe_unused]] ::std::size_t start_pos,
                    [[maybe_unused]] ::std::size_t count,
                    [[maybe_unused]] curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                {
                    if constexpr(!stacktop_enabled) { return; }
                    if(count == 0uz) { return; }
                    if(runtime_log_on) [[unlikely]] { ++runtime_log_stats.stacktop_spillN_count; }

                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                    using remain_t = ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_stacktop_remain_size_t;
                    auto tmp_currpos{curr_stacktop};
                    remain_t remain{};

                    switch(vt)
                    {
                        case curr_operand_stack_value_type::i32:
                        {
                            if constexpr(stacktop_i32_enabled)
                            {
                                tmp_currpos.i32_stack_top_curr_pos = start_pos;
                                remain.i32_stack_top_remain_size = count;
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" event=stacktop.spillN | vt=i32 start=",
                                                         start_pos,
                                                         u8" remain(i32)=",
                                                         count,
                                                         u8" currpos(i32)=",
                                                         curr_stacktop.i32_stack_top_curr_pos,
                                                         u8"\n");
                                }
                                emit_opfunc_to(
                                    dst,
                                    translate::get_uwvmint_stacktop_to_operand_stack_fptr_from_tuple<CompileOption,
                                                                                                     ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32>(
                                        tmp_currpos,
                                        remain,
                                        interpreter_tuple));
                                return;
                            }
                            break;
                        }
                        case curr_operand_stack_value_type::i64:
                        {
                            if constexpr(stacktop_i64_enabled)
                            {
                                tmp_currpos.i64_stack_top_curr_pos = start_pos;
                                remain.i64_stack_top_remain_size = count;
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" event=stacktop.spillN | vt=i64 start=",
                                                         start_pos,
                                                         u8" remain(i64)=",
                                                         count,
                                                         u8" currpos(i64)=",
                                                         curr_stacktop.i64_stack_top_curr_pos,
                                                         u8"\n");
                                }
                                emit_opfunc_to(
                                    dst,
                                    translate::get_uwvmint_stacktop_to_operand_stack_fptr_from_tuple<CompileOption,
                                                                                                     ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64>(
                                        tmp_currpos,
                                        remain,
                                        interpreter_tuple));
                                return;
                            }
                            break;
                        }
                        case curr_operand_stack_value_type::f32:
                        {
                            if constexpr(stacktop_f32_enabled)
                            {
                                tmp_currpos.f32_stack_top_curr_pos = start_pos;
                                remain.f32_stack_top_remain_size = count;
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" event=stacktop.spillN | vt=f32 start=",
                                                         start_pos,
                                                         u8" remain(f32)=",
                                                         count,
                                                         u8" currpos(f32)=",
                                                         curr_stacktop.f32_stack_top_curr_pos,
                                                         u8"\n");
                                }
                                emit_opfunc_to(
                                    dst,
                                    translate::get_uwvmint_stacktop_to_operand_stack_fptr_from_tuple<CompileOption,
                                                                                                     ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32>(
                                        tmp_currpos,
                                        remain,
                                        interpreter_tuple));
                                return;
                            }
                            break;
                        }
                        case curr_operand_stack_value_type::f64:
                        {
                            if constexpr(stacktop_f64_enabled)
                            {
                                tmp_currpos.f64_stack_top_curr_pos = start_pos;
                                remain.f64_stack_top_remain_size = count;
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" event=stacktop.spillN | vt=f64 start=",
                                                         start_pos,
                                                         u8" remain(f64)=",
                                                         count,
                                                         u8" currpos(f64)=",
                                                         curr_stacktop.f64_stack_top_curr_pos,
                                                         u8"\n");
                                }
                                emit_opfunc_to(
                                    dst,
                                    translate::get_uwvmint_stacktop_to_operand_stack_fptr_from_tuple<CompileOption,
                                                                                                     ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64>(
                                        tmp_currpos,
                                        remain,
                                        interpreter_tuple));
                                return;
                            }
                            break;
                        }
                        [[unlikely]] default:
                        {
                            break;
                        }
                    }

                    // Fallback: emit single-value spills.
                    {
                        ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                        ::std::size_t const end_pos{stacktop_range_end_pos(vt)};

                        // Spill in deepest->top order so operand-stack memory preserves deep->top layout.
                        ::std::size_t pos{start_pos};
                        pos = stacktop_ring_advance_next(pos, count - 1uz, begin_pos, end_pos);  // deepest within the segment
                        for(::std::size_t i{}; i != count; ++i)
                        {
                            emit_stacktop_spill1_typed_to(dst, pos, vt);
                            pos = stacktop_ring_prev(pos, begin_pos, end_pos);
                        }
                    }
                }};

            auto const emit_stacktop_fill1_typed_to{
                [&]([[maybe_unused]] bytecode_vec_t& dst,
                    [[maybe_unused]] ::std::size_t slot,
                    [[maybe_unused]] curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                {
                    if constexpr(stacktop_enabled)
                    {
                        if(runtime_log_on) [[unlikely]] { ++runtime_log_stats.stacktop_fill1_count; }
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        switch(vt)
                        {
                            case curr_operand_stack_value_type::i32:
                            {
                                emit_opfunc_to(dst,
                                               translate::get_uwvmint_operand_stack_to_stacktop_typed_single_fptr_from_tuple<
                                                   CompileOption,
                                                   ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32>(slot, interpreter_tuple));
                                break;
                            }
                            case curr_operand_stack_value_type::i64:
                            {
                                emit_opfunc_to(dst,
                                               translate::get_uwvmint_operand_stack_to_stacktop_typed_single_fptr_from_tuple<
                                                   CompileOption,
                                                   ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64>(slot, interpreter_tuple));
                                break;
                            }
                            case curr_operand_stack_value_type::f32:
                            {
                                emit_opfunc_to(dst,
                                               translate::get_uwvmint_operand_stack_to_stacktop_typed_single_fptr_from_tuple<
                                                   CompileOption,
                                                   ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32>(slot, interpreter_tuple));
                                break;
                            }
                            case curr_operand_stack_value_type::f64:
                            {
                                emit_opfunc_to(dst,
                                               translate::get_uwvmint_operand_stack_to_stacktop_typed_single_fptr_from_tuple<
                                                   CompileOption,
                                                   ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64>(slot, interpreter_tuple));
                                break;
                            }
                            [[unlikely]] default:
                            {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                break;
                            }
                        }
                    }
                }};

            // Emit a multi-value fill (memory -> cache) for a **single scalar type**.
            [[maybe_unused]] auto const emit_stacktop_filln_same_vt_to{
                [&]([[maybe_unused]] bytecode_vec_t& dst,
                    [[maybe_unused]] ::std::size_t start_pos,
                    [[maybe_unused]] ::std::size_t count,
                    [[maybe_unused]] curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                {
                    if constexpr(!stacktop_enabled) { return; }
                    if(count == 0uz) { return; }
                    if(runtime_log_on) [[unlikely]] { ++runtime_log_stats.stacktop_fillN_count; }

                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                    using remain_t = ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_stacktop_remain_size_t;
                    auto tmp_currpos{curr_stacktop};
                    remain_t remain{};

                    switch(vt)
                    {
                        case curr_operand_stack_value_type::i32:
                        {
                            if constexpr(stacktop_i32_enabled)
                            {
                                tmp_currpos.i32_stack_top_curr_pos = start_pos;
                                remain.i32_stack_top_remain_size = count;
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" event=stacktop.fillN | vt=i32 start=",
                                                         start_pos,
                                                         u8" remain(i32)=",
                                                         count,
                                                         u8" currpos(i32)=",
                                                         curr_stacktop.i32_stack_top_curr_pos,
                                                         u8"\n");
                                }
                                emit_opfunc_to(
                                    dst,
                                    translate::get_uwvmint_operand_stack_to_stacktop_fptr_from_tuple<CompileOption,
                                                                                                     ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32>(
                                        tmp_currpos,
                                        remain,
                                        interpreter_tuple));
                                return;
                            }
                            break;
                        }
                        case curr_operand_stack_value_type::i64:
                        {
                            if constexpr(stacktop_i64_enabled)
                            {
                                tmp_currpos.i64_stack_top_curr_pos = start_pos;
                                remain.i64_stack_top_remain_size = count;
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" event=stacktop.fillN | vt=i64 start=",
                                                         start_pos,
                                                         u8" remain(i64)=",
                                                         count,
                                                         u8" currpos(i64)=",
                                                         curr_stacktop.i64_stack_top_curr_pos,
                                                         u8"\n");
                                }
                                emit_opfunc_to(
                                    dst,
                                    translate::get_uwvmint_operand_stack_to_stacktop_fptr_from_tuple<CompileOption,
                                                                                                     ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64>(
                                        tmp_currpos,
                                        remain,
                                        interpreter_tuple));
                                return;
                            }
                            break;
                        }
                        case curr_operand_stack_value_type::f32:
                        {
                            if constexpr(stacktop_f32_enabled)
                            {
                                tmp_currpos.f32_stack_top_curr_pos = start_pos;
                                remain.f32_stack_top_remain_size = count;
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" event=stacktop.fillN | vt=f32 start=",
                                                         start_pos,
                                                         u8" remain(f32)=",
                                                         count,
                                                         u8" currpos(f32)=",
                                                         curr_stacktop.f32_stack_top_curr_pos,
                                                         u8"\n");
                                }
                                emit_opfunc_to(
                                    dst,
                                    translate::get_uwvmint_operand_stack_to_stacktop_fptr_from_tuple<CompileOption,
                                                                                                     ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32>(
                                        tmp_currpos,
                                        remain,
                                        interpreter_tuple));
                                return;
                            }
                            break;
                        }
                        case curr_operand_stack_value_type::f64:
                        {
                            if constexpr(stacktop_f64_enabled)
                            {
                                tmp_currpos.f64_stack_top_curr_pos = start_pos;
                                remain.f64_stack_top_remain_size = count;
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" event=stacktop.fillN | vt=f64 start=",
                                                         start_pos,
                                                         u8" remain(f64)=",
                                                         count,
                                                         u8" currpos(f64)=",
                                                         curr_stacktop.f64_stack_top_curr_pos,
                                                         u8"\n");
                                }
                                emit_opfunc_to(
                                    dst,
                                    translate::get_uwvmint_operand_stack_to_stacktop_fptr_from_tuple<CompileOption,
                                                                                                     ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64>(
                                        tmp_currpos,
                                        remain,
                                        interpreter_tuple));
                                return;
                            }
                            break;
                        }
                        [[unlikely]] default:
                        {
                            break;
                        }
                    }

                    // Fallback: emit single-value fills.
                    {
                        ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                        ::std::size_t const end_pos{stacktop_range_end_pos(vt)};

                        // Fill in top->deep order: each fill consumes the current operand-stack top and writes the next ring slot.
                        ::std::size_t pos{start_pos};
                        for(::std::size_t i{}; i != count; ++i)
                        {
                            emit_stacktop_fill1_typed_to(dst, pos, vt);
                            pos = stacktop_ring_next(pos, begin_pos, end_pos);
                        }
                    }
                }};

            auto const stacktop_spill_one_deepest_to{
                [&](bytecode_vec_t& dst, ::std::size_t max_spill_n = SIZE_MAX) constexpr UWVM_THROWS
                {
                    if constexpr(!stacktop_enabled) { return; }
                    if(stacktop_cache_count == 0uz) { return; }

                    stacktop_assert_invariants();

                    // Deepest cached value is at index `stacktop_memory_count`.
                    // If several *consecutive* deepest cached values share the same type, batch them into one spill opfunc.
                    auto const vt{codegen_operand_stack.index_unchecked(stacktop_memory_count).type};
                    ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                    ::std::size_t const end_pos{stacktop_range_end_pos(vt)};
                    ::std::size_t const group_cnt{stacktop_cache_count_for_range(begin_pos, end_pos)};
                    ::std::size_t const currpos{stacktop_currpos_for_range(begin_pos, end_pos)};
                    ::std::size_t spill_n{1uz};
                    {
                        auto const cache_end{stacktop_memory_count + stacktop_cache_count};
                        while(spill_n < group_cnt && (stacktop_memory_count + spill_n) < cache_end &&
                              codegen_operand_stack.index_unchecked(stacktop_memory_count + spill_n).type == vt)
                        {
                            ++spill_n;
                        }
                    }
                    if(max_spill_n == 0uz) { return; }
                    if(spill_n > max_spill_n) { spill_n = max_spill_n; }

                    // Batch only for disjoint ranges; for merged ranges, fall back to single spills.
                    // (Typed spill opfunc enforces Count==1.)
                    if(spill_n > 1uz)
                    {
                        // segment top (least deep among the deepest `spill_n` values)
                        ::std::size_t const seg_top_slot{stacktop_ring_advance_next(currpos, group_cnt - spill_n, begin_pos, end_pos)};
                        if(runtime_log_on) [[unlikely]]
                        {
                            ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                 u8"[uwvm-int-translator] fn=",
                                                 function_index,
                                                 u8" event=stacktop.spill_one_deepest(batch) | vt=",
                                                 runtime_log_vt_name(vt),
                                                 u8" spill_n=",
                                                 spill_n,
                                                 u8" seg_top_slot=",
                                                 seg_top_slot,
                                                 u8" group_cnt=",
                                                 group_cnt,
                                                 u8" currpos=",
                                                 currpos,
                                                 u8" begin=",
                                                 begin_pos,
                                                 u8" end=",
                                                 end_pos,
                                                 u8"\n");
                        }
                        emit_stacktop_spilln_same_vt_to(dst, seg_top_slot, spill_n, vt);
                    }
                    else
                    {
                        ::std::size_t const deepest_slot{stacktop_ring_advance_next(currpos, group_cnt - 1uz, begin_pos, end_pos)};
                        if(runtime_log_on) [[unlikely]]
                        {
                            ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                 u8"[uwvm-int-translator] fn=",
                                                 function_index,
                                                 u8" event=stacktop.spill_one_deepest(single) | vt=",
                                                 runtime_log_vt_name(vt),
                                                 u8" slot=",
                                                 deepest_slot,
                                                 u8" group_cnt=",
                                                 group_cnt,
                                                 u8" currpos=",
                                                 currpos,
                                                 u8" begin=",
                                                 begin_pos,
                                                 u8" end=",
                                                 end_pos,
                                                 u8"\n");
                        }
                        emit_stacktop_spill1_typed_to(dst, deepest_slot, vt);
                    }

                    // Model effects: one value moved cache -> memory.
                    stacktop_memory_count += spill_n;
                    stacktop_cache_count -= spill_n;
                    stacktop_cache_count_ref_for_vt(vt) -= spill_n;

                    stacktop_assert_invariants();
                }};

            auto const stacktop_fill_one_from_memory_to{[&](bytecode_vec_t& dst) constexpr UWVM_THROWS
                                                        {
                                                            if constexpr(!stacktop_enabled) { return; }
                                                            if(stacktop_memory_count == 0uz) { return; }

                                                            stacktop_assert_invariants();

                                                            // Fill consecutive same-typed values from memory into cache in one opfunc when possible.
                                                            auto const vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};
                                                            ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                                                            ::std::size_t const end_pos{stacktop_range_end_pos(vt)};
                                                            ::std::size_t const group_cnt{stacktop_cache_count_for_range(begin_pos, end_pos)};
                                                            ::std::size_t const currpos{stacktop_currpos_for_range(begin_pos, end_pos)};
                                                            ::std::size_t const ring_size{end_pos - begin_pos};
                                                            ::std::size_t const free_slots{ring_size - group_cnt};
                                                            ::std::size_t fill_n{1uz};
                                                            if(free_slots > 1uz)
                                                            {
                                                                while(fill_n < free_slots && fill_n < stacktop_memory_count &&
                                                                      codegen_operand_stack.index_unchecked((stacktop_memory_count - 1uz) - fill_n).type == vt)
                                                                {
                                                                    ++fill_n;
                                                                }
                                                            }

                                                            ::std::size_t const start_slot{stacktop_ring_advance_next(currpos, group_cnt, begin_pos, end_pos)};
                                                            if(fill_n > 1uz) { emit_stacktop_filln_same_vt_to(dst, start_slot, fill_n, vt); }
                                                            else
                                                            {
                                                                emit_stacktop_fill1_typed_to(dst, start_slot, vt);
                                                            }

                                                            stacktop_memory_count -= fill_n;
                                                            stacktop_cache_count += fill_n;
                                                            stacktop_cache_count_ref_for_vt(vt) += fill_n;

                                                            stacktop_assert_invariants();
                                                        }};

            auto const stacktop_prepare_push1_typed{[&](bytecode_vec_t& dst, curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                                                    {
                                                        if constexpr(!stacktop_enabled) { return; }

                                                        ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                                                        ::std::size_t const end_pos{stacktop_range_end_pos(vt)};
                                                        ::std::size_t const ring_size{end_pos - begin_pos};

                                                        // Critical correctness: push opfuncs write into `ring_prev(currpos)`. If the ring is full, that slot
                                                        // is occupied by the deepest cached value of that range; spill from the deepest cached overall until
                                                        // the target range has a free slot.
                                                        if(runtime_log_on) [[unlikely]]
                                                        {
                                                            ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                                 u8"[uwvm-int-translator] fn=",
                                                                                 function_index,
                                                                                 u8" event=stacktop.prepare_push1(begin) | vt=",
                                                                                 runtime_log_vt_name(vt),
                                                                                 u8" begin=",
                                                                                 begin_pos,
                                                                                 u8" end=",
                                                                                 end_pos,
                                                                                 u8" ring=",
                                                                                 ring_size,
                                                                                 u8" range_cache=",
                                                                                 stacktop_cache_count_for_range(begin_pos, end_pos),
                                                                                 u8" stacktop{mem=",
                                                                                 stacktop_memory_count,
                                                                                 u8",cache=",
                                                                                 stacktop_cache_count,
                                                                                 u8"}\n");
                                                        }
                                                        ::std::size_t spill_cnt{};
                                                        while(stacktop_cache_count_for_range(begin_pos, end_pos) >= ring_size)
                                                        {
                                                            // Only spill what is needed to free one slot for this push.
                                                            // Over-spilling can strand subsequent opcodes (e.g. `select`) with operands in memory while
                                                            // the corresponding opfunc expects them to still reside in the stack-top cache.
                                                            stacktop_spill_one_deepest_to(dst, 1uz);
                                                            ++spill_cnt;
                                                        }

                                                        stacktop_assert_invariants();
                                                        if(runtime_log_on) [[unlikely]]
                                                        {
                                                            ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                                 u8"[uwvm-int-translator] fn=",
                                                                                 function_index,
                                                                                 u8" event=stacktop.prepare_push1(end) | vt=",
                                                                                 runtime_log_vt_name(vt),
                                                                                 u8" spills=",
                                                                                 spill_cnt,
                                                                                 u8" range_cache=",
                                                                                 stacktop_cache_count_for_range(begin_pos, end_pos),
                                                                                 u8" stacktop{mem=",
                                                                                 stacktop_memory_count,
                                                                                 u8",cache=",
                                                                                 stacktop_cache_count,
                                                                                 u8"} currpos{i32=",
                                                                                 curr_stacktop.i32_stack_top_curr_pos,
                                                                                 u8",i64=",
                                                                                 curr_stacktop.i64_stack_top_curr_pos,
                                                                                 u8",f32=",
                                                                                 curr_stacktop.f32_stack_top_curr_pos,
                                                                                 u8",f64=",
                                                                                 curr_stacktop.f64_stack_top_curr_pos,
                                                                                 u8"}\n");
                                                        }
                                                    }};

            auto const stacktop_commit_push1_typed{[&](curr_operand_stack_value_type vt) constexpr noexcept
                                                   {
                                                       if constexpr(!stacktop_enabled) { return; }

                                                       ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                                                       ::std::size_t const end_pos{stacktop_range_end_pos(vt)};

                                                       ::std::size_t const currpos{stacktop_currpos_for_range(begin_pos, end_pos)};
                                                       ::std::size_t const new_pos{stacktop_ring_prev(currpos, begin_pos, end_pos)};
                                                       stacktop_set_currpos_for_range(begin_pos, end_pos, new_pos);

                                                       ++stacktop_cache_count;
                                                       ++stacktop_cache_count_ref_for_vt(vt);
                                                       if(runtime_log_on) [[unlikely]]
                                                       {
                                                           ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                                u8"[uwvm-int-translator] fn=",
                                                                                function_index,
                                                                                u8" event=stacktop.commit_push1 | vt=",
                                                                                runtime_log_vt_name(vt),
                                                                                u8" currpos=",
                                                                                currpos,
                                                                                u8"->",
                                                                                new_pos,
                                                                                u8" stacktop{mem=",
                                                                                stacktop_memory_count,
                                                                                u8",cache=",
                                                                                stacktop_cache_count,
                                                                                u8"}\n");
                                                       }
                                                   }};

            auto const stacktop_commit_pop_n{[&](::std::size_t n) constexpr noexcept
                                             {
                                                 if constexpr(!stacktop_enabled) { return; }
                                                 else
                                                 {
                                                     if(n == 0uz) { return; }

                                                     auto const before_curr_stacktop{curr_stacktop};
                                                     auto const before_stacktop_memory_count{stacktop_memory_count};
                                                     auto const before_stacktop_cache_count{stacktop_cache_count};
                                                     auto const before_stacktop_cache_i32_count{stacktop_cache_i32_count};
                                                     auto const before_stacktop_cache_i64_count{stacktop_cache_i64_count};
                                                     auto const before_stacktop_cache_f32_count{stacktop_cache_f32_count};
                                                     auto const before_stacktop_cache_f64_count{stacktop_cache_f64_count};

                                                     // Pop from the top; if cache becomes empty, remaining pops consume the memory-only stack.
                                                     for(::std::size_t i{}; i != n; ++i)
                                                     {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                                         if(codegen_operand_stack.empty()) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                                                         if(codegen_operand_stack.empty()) { return; }

                                                         // Pop i-th value from top (type stack is updated by the caller after this commit).
                                                         auto const vt{codegen_operand_stack.index_unchecked((codegen_operand_stack.size() - 1uz) - i).type};

                                                         ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                                                         ::std::size_t const end_pos{stacktop_range_end_pos(vt)};

                                                         ::std::size_t const currpos{stacktop_currpos_for_range(begin_pos, end_pos)};
                                                         ::std::size_t const new_pos{stacktop_ring_next(currpos, begin_pos, end_pos)};
                                                         stacktop_set_currpos_for_range(begin_pos, end_pos, new_pos);

                                                         if(stacktop_cache_count != 0uz)
                                                         {
                                                             --stacktop_cache_count;
                                                             --stacktop_cache_count_ref_for_vt(vt);
                                                         }
                                                         else
                                                         {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                                             if(stacktop_memory_count == 0uz) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                                                             --stacktop_memory_count;
                                                         }
                                                     }

                                                     if(runtime_log_on) [[unlikely]]
                                                     {
                                                         ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                              u8"[uwvm-int-translator] fn=",
                                                                              function_index,
                                                                              u8" event=stacktop.commit_pop_n | n=",
                                                                              n,
                                                                              u8" stacktop{mem=",
                                                                              before_stacktop_memory_count,
                                                                              u8",cache=",
                                                                              before_stacktop_cache_count,
                                                                              u8"}->",
                                                                              u8"{mem=",
                                                                              stacktop_memory_count,
                                                                              u8",cache=",
                                                                              stacktop_cache_count,
                                                                              u8"} cache_type{i32=",
                                                                              before_stacktop_cache_i32_count,
                                                                              u8",i64=",
                                                                              before_stacktop_cache_i64_count,
                                                                              u8",f32=",
                                                                              before_stacktop_cache_f32_count,
                                                                              u8",f64=",
                                                                              before_stacktop_cache_f64_count,
                                                                              u8"}->",
                                                                              u8"{i32=",
                                                                              stacktop_cache_i32_count,
                                                                              u8",i64=",
                                                                              stacktop_cache_i64_count,
                                                                              u8",f32=",
                                                                              stacktop_cache_f32_count,
                                                                              u8",f64=",
                                                                              stacktop_cache_f64_count,
                                                                              u8"} currpos{i32=",
                                                                              before_curr_stacktop.i32_stack_top_curr_pos,
                                                                              u8"->",
                                                                              curr_stacktop.i32_stack_top_curr_pos,
                                                                              u8",i64=",
                                                                              before_curr_stacktop.i64_stack_top_curr_pos,
                                                                              u8"->",
                                                                              curr_stacktop.i64_stack_top_curr_pos,
                                                                              u8",f32=",
                                                                              before_curr_stacktop.f32_stack_top_curr_pos,
                                                                              u8"->",
                                                                              curr_stacktop.f32_stack_top_curr_pos,
                                                                              u8",f64=",
                                                                              before_curr_stacktop.f64_stack_top_curr_pos,
                                                                              u8"->",
                                                                              curr_stacktop.f64_stack_top_curr_pos,
                                                                              u8"}\n");
                                                     }
                                                 }
                                             }};

            auto const stacktop_fill_to_canonical{[&](bytecode_vec_t& dst) constexpr UWVM_THROWS
                                                  {
                                                      if constexpr(!stacktop_enabled) { return; }
                                                      else
                                                      {

                                                          stacktop_assert_invariants();

                                                          // Fill from memory into cache as deep as possible while respecting per-range ring capacities.
                                                          while(stacktop_memory_count != 0uz)
                                                          {
                                                              auto const vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};
                                                              ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                                                              ::std::size_t const end_pos{stacktop_range_end_pos(vt)};
                                                              ::std::size_t const ring_size{end_pos - begin_pos};
                                                              if(stacktop_cache_count_for_range(begin_pos, end_pos) == ring_size) { break; }
                                                              stacktop_fill_one_from_memory_to(dst);
                                                          }

                                                          stacktop_assert_invariants();
                                                      }
                                                  }};

            auto const stacktop_flush_all_to_operand_stack{[&](bytecode_vec_t& dst) constexpr UWVM_THROWS
                                                           {
                                                               if constexpr(!stacktop_enabled) { return; }
                                                               else
                                                               {
                                                                   stacktop_assert_invariants();
                                                                   // Spill from deepest to top so operand stack memory ends up in correct deep->top order.
                                                                   while(stacktop_cache_count != 0uz) { stacktop_spill_one_deepest_to(dst); }

                                                                   stacktop_assert_invariants();
                                                               }
                                                           }};

            [[maybe_unused]] auto const stacktop_reset_currpos_to_begin{
                [&]() constexpr noexcept
                {
                    if constexpr(!stacktop_enabled) { return; }
                    curr_stacktop.i32_stack_top_curr_pos = stacktop_i32_enabled ? CompileOption.i32_stack_top_begin_pos : SIZE_MAX;
                    curr_stacktop.i64_stack_top_curr_pos = stacktop_i64_enabled ? CompileOption.i64_stack_top_begin_pos : SIZE_MAX;
                    curr_stacktop.f32_stack_top_curr_pos = stacktop_f32_enabled ? CompileOption.f32_stack_top_begin_pos : SIZE_MAX;
                    curr_stacktop.f64_stack_top_curr_pos = stacktop_f64_enabled ? CompileOption.f64_stack_top_begin_pos : SIZE_MAX;
                    curr_stacktop.v128_stack_top_curr_pos = stacktop_v128_enabled ? CompileOption.v128_stack_top_begin_pos : SIZE_MAX;
                }};

            [[maybe_unused]] auto const stacktop_transform_currpos_to_begin{
                [&](bytecode_vec_t& dst) constexpr UWVM_THROWS
                {
                    if constexpr(stacktop_enabled && CompileOption.is_tail_call && stacktop_regtransform_cf_entry && stacktop_regtransform_supported)
                    {
                        if(is_polymorphic)
                        {
                            // Unreachable region: keep compiler-side state deterministic without emitting runtime code.
                            stacktop_reset_currpos_to_begin();
                            return;
                        }

                        // If cache is empty there is no live register state to preserve; reset cursors without emitting a transform opfunc.
                        if(stacktop_cache_count == 0uz)
                        {
                            stacktop_reset_currpos_to_begin();
                            return;
                        }

                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(dst,
                                       translate::get_uwvmint_stacktop_transform_to_begin_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_reset_currpos_to_begin();
                    }
                }};

            [[maybe_unused]] auto const stacktop_canonicalize_edge_to_memory{[&](bytecode_vec_t& dst) constexpr UWVM_THROWS
                                                                             {
                                                                                 if constexpr(!stacktop_enabled) { return; }
                                                                                 // Move all cached values to operand-stack memory (call-like barrier).
                                                                                 stacktop_flush_all_to_operand_stack(dst);
                                                                                 // Make the empty-cache state deterministic for subsequent codegen.
                                                                                 stacktop_reset_currpos_to_begin();
                                                                                 stacktop_cache_count = 0uz;
                                                                                 stacktop_cache_i32_count = 0uz;
                                                                                 stacktop_cache_i64_count = 0uz;
                                                                                 stacktop_cache_f32_count = 0uz;
                                                                                 stacktop_cache_f64_count = 0uz;
                                                                                 stacktop_memory_count = codegen_operand_stack.size();
                                                                             }};

            auto const stacktop_prepare_push1_if_reachable{[&](bytecode_vec_t& dst, curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                                                           {
                                                               if constexpr(!stacktop_enabled) { return; }
                                                               else
                                                               {
                                                                   if(is_polymorphic) { return; }
                                                                   stacktop_prepare_push1_typed(dst, vt);
                                                               }
                                                           }};

            [[maybe_unused]] auto const stacktop_commit_push1_if_reachable{[&](curr_operand_stack_value_type vt) constexpr noexcept
                                                                           {
                                                                               if constexpr(!stacktop_enabled) { return; }
                                                                               else
                                                                               {
                                                                                   if(is_polymorphic) { return; }
                                                                                   stacktop_commit_push1_typed(vt);
                                                                               }
                                                                           }};

            [[maybe_unused]] auto const stacktop_commit_push1_typed_if_reachable{[&](curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                                                                                 {
                                                                                     if constexpr(!stacktop_enabled) { return; }
                                                                                     else
                                                                                     {
                                                                                         if(is_polymorphic) { return; }
                                                                                         stacktop_commit_push1_typed(vt);
                                                                                         codegen_stack_push(vt);
                                                                                     }
                                                                                 }};

            auto const stacktop_after_pop_n_if_reachable{[&](bytecode_vec_t& dst, ::std::size_t n) constexpr UWVM_THROWS
                                                         {
                                                             if constexpr(!stacktop_enabled) { return; }
                                                             else
                                                             {
                                                                 if(is_polymorphic) { return; }
                                                                 stacktop_commit_pop_n(n);
                                                                 codegen_stack_pop_n(n);
                                                                 stacktop_fill_to_canonical(dst);
                                                             }
                                                         }};

            // Pop modeling + retype the new top before canonical fill (used for ops like i64.cmp -> i32).
            [[maybe_unused]] auto const stacktop_after_pop_n_retype_top_if_reachable{
                [&](bytecode_vec_t& dst, ::std::size_t n, curr_operand_stack_value_type new_top_type) constexpr UWVM_THROWS
                {
                    if constexpr(!stacktop_enabled) { return; }
                    else
                    {
                        if(is_polymorphic) { return; }
                        stacktop_commit_pop_n(n);
                        codegen_stack_pop_n(n);
                        codegen_stack_set_top(new_top_type);
                        stacktop_fill_to_canonical(dst);
                    }
                }};

            // Pop+push modeling (used for cross-range ops like f32.cmp -> i32 when i32 range is disjoint from f32 range).
            [[maybe_unused]] auto const stacktop_after_pop_n_push1_typed_if_reachable{
                [&](bytecode_vec_t& dst, ::std::size_t pop_n, curr_operand_stack_value_type push_type) constexpr UWVM_THROWS
                {
                    if constexpr(!stacktop_enabled) { return; }
                    else
                    {
                        if(is_polymorphic) { return; }
                        stacktop_commit_pop_n(pop_n);
                        codegen_stack_pop_n(pop_n);
                        // Ensure the target stack-top ring has a free slot *after* the pop step.
                        // This is required for cross-range ops that keep depth unchanged (pop+push),
                        // e.g. `f32.load` (i32 addr -> f32 result) in split GPR/FP ring layouts.
                        stacktop_prepare_push1_typed(dst, push_type);
                        stacktop_commit_push1_typed(push_type);
                        codegen_stack_push(push_type);
                        stacktop_fill_to_canonical(dst);
                    }
                }};

            // Pop+push modeling without emitting any fill ops (used to keep `br_if` fusion candidates contiguous).
            [[maybe_unused]] auto const stacktop_after_pop_n_push1_typed_no_fill_if_reachable{
                [&](::std::size_t pop_n, curr_operand_stack_value_type push_type) constexpr noexcept
                {
                    if constexpr(!stacktop_enabled) { return; }
                    else
                    {
                        if(is_polymorphic) { return; }
                        stacktop_commit_pop_n(pop_n);
                        codegen_stack_pop_n(pop_n);
                        stacktop_commit_push1_typed(push_type);
                        codegen_stack_push(push_type);
                    }
                }};

            // Pop modeling without emitting any fill ops (used to keep `br_if` fusion candidates contiguous).
            [[maybe_unused]] auto const stacktop_after_pop_n_no_fill_if_reachable{[&](::std::size_t n) constexpr noexcept
                                                                                  {
                                                                                      if constexpr(!stacktop_enabled) { return; }
                                                                                      else
                                                                                      {
                                                                                          if(is_polymorphic) { return; }
                                                                                          stacktop_commit_pop_n(n);
                                                                                          codegen_stack_pop_n(n);
                                                                                      }
                                                                                  }};

            auto const emit_drop_typed_to{
                [&](bytecode_vec_t& dst, curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    auto const emit_real_drop{
                        [&]() constexpr UWVM_THROWS
                        {
                            switch(vt)
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    emit_opfunc_to(dst, translate::get_uwvmint_drop_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    return;
                                }
                                case curr_operand_stack_value_type::i64:
                                {
                                    emit_opfunc_to(dst, translate::get_uwvmint_drop_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    return;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    emit_opfunc_to(dst, translate::get_uwvmint_drop_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    return;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    emit_opfunc_to(dst, translate::get_uwvmint_drop_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    return;
                                }
                                [[unlikely]] default:
                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                    return;
                                }
                            }
                        }};

                    if constexpr(!stacktop_enabled)
                    {
                        emit_real_drop();
                        return;
                    }

                    if(is_polymorphic)
                    {
                        // Unreachable region: emit a real `drop` without mutating compiler-side stack-top model.
                        emit_real_drop();
                        return;
                    }

                    // Cache-hit: fold `drop` by updating the compiler-side stack-top cursor (no runtime op).
                    // Cache-miss: emit real `drop` to adjust the memory stack pointer, then update the model.
                    if(stacktop_cache_count != 0uz)
                    {
                        stacktop_commit_pop_n(1uz);
                        codegen_stack_pop_n(1uz);
                        stacktop_fill_to_canonical(dst);
                    }
                    else
                    {
                        emit_real_drop();
                        stacktop_commit_pop_n(1uz);
                        codegen_stack_pop_n(1uz);
                        stacktop_fill_to_canonical(dst);
                    }
                }};

            // Drop modeling without emitting any canonical fills.
            // Used for bulk stack-shape repair sequences (br/br_if/br_table/return) where intermediate fills would
            // often reload values that are immediately dropped again.
            [[maybe_unused]] auto const emit_drop_typed_to_no_fill{
                [&](bytecode_vec_t& dst, curr_operand_stack_value_type vt) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    auto const emit_real_drop{
                        [&]() constexpr UWVM_THROWS
                        {
                            switch(vt)
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    emit_opfunc_to(dst, translate::get_uwvmint_drop_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    return;
                                }
                                case curr_operand_stack_value_type::i64:
                                {
                                    emit_opfunc_to(dst, translate::get_uwvmint_drop_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    return;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    emit_opfunc_to(dst, translate::get_uwvmint_drop_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    return;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    emit_opfunc_to(dst, translate::get_uwvmint_drop_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    return;
                                }
                                [[unlikely]] default:
                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                    return;
                                }
                            }
                        }};

                    if constexpr(!stacktop_enabled)
                    {
                        emit_real_drop();
                        return;
                    }

                    if(is_polymorphic)
                    {
                        // Unreachable region: emit a real `drop` without mutating compiler-side stack-top model.
                        emit_real_drop();
                        return;
                    }

                    if(stacktop_cache_count != 0uz)
                    {
                        stacktop_commit_pop_n(1uz);
                        codegen_stack_pop_n(1uz);
                    }
                    else
                    {
                        emit_real_drop();
                        stacktop_commit_pop_n(1uz);
                        codegen_stack_pop_n(1uz);
                    }
                }};

            auto const emit_local_get_typed_to{
                [&](bytecode_vec_t& dst, curr_operand_stack_value_type vt, local_offset_t off) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    bool fused_spill_and_local_get{};
                    [[maybe_unused]] ::std::size_t fuse_site{};

                    if constexpr(stacktop_enabled)
                    {
                        // local.get pushes 1 value to stack-top cache; spill if ring is full.
                        [[maybe_unused]] ::std::size_t const bc_before{dst.size()};
                        stacktop_prepare_push1_if_reachable(dst, vt);

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        // If `stacktop_prepare_push1_*` emitted a spill opfunc immediately before this `local.get`, rewrite that spill opfunc
                        // into a fused "spill1 + local.get" opfunc, and reuse the would-be `local.get` opfunc slot for the immediate.
                        // This avoids an extra dispatch *and* avoids the runtime "skip next opfunc pointer" pattern.
                        if(dst.size() != bc_before)
                        {
                            constexpr bool i32_i64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.i64_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.i64_stack_top_end_pos};
                            constexpr bool i32_f32_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                            constexpr bool i32_f64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};
                            constexpr bool i64_f32_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                         CompileOption.i64_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                            constexpr bool i64_f64_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.i64_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};
                            constexpr bool f32_f64_merge{CompileOption.f32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.f32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                            using wasm_i32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32;
                            using wasm_i64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64;
                            using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;
                            using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;

                            auto const spilled_vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};

                            // Patch the *last* emitted spill opfunc (spillN is not emitted here; prepare_push1 emits spill1 only).
                            using opfunc_ptr_t =
                                decltype(translate::get_uwvmint_local_get_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            fuse_site = dst.size() - sizeof(opfunc_ptr_t);

                            auto patch_with{[&](auto fused_fptr) constexpr UWVM_THROWS
                                            {
                                                ::std::byte tmp[sizeof(fused_fptr)];
                                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                ::std::memcpy(dst.data() + fuse_site, tmp, sizeof(fused_fptr));
                                                fused_spill_and_local_get = true;
                                            }};

                            // Decide spill-value type (SpilledT) from the translator model.
                            switch(vt)
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    if(spilled_vt == curr_operand_stack_value_type::i32)
                                    {
                                        patch_with(
                                            translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_i32, wasm_i32>(
                                                curr_stacktop,
                                                interpreter_tuple));
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i64)
                                    {
                                        if constexpr(i32_i64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_i64, wasm_i32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f32)
                                    {
                                        if constexpr(i32_f32_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_f32, wasm_i32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f64)
                                    {
                                        if constexpr(i32_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_f64, wasm_i32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    break;
                                }
                                case curr_operand_stack_value_type::i64:
                                {
                                    if(spilled_vt == curr_operand_stack_value_type::i64)
                                    {
                                        patch_with(
                                            translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_i64, wasm_i64>(
                                                curr_stacktop,
                                                interpreter_tuple));
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i32)
                                    {
                                        if constexpr(i32_i64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_i32, wasm_i64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f32)
                                    {
                                        if constexpr(i64_f32_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_f32, wasm_i64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f64)
                                    {
                                        if constexpr(i64_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_f64, wasm_i64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    break;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    if(spilled_vt == curr_operand_stack_value_type::f32)
                                    {
                                        patch_with(
                                            translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_f32, wasm_f32>(
                                                curr_stacktop,
                                                interpreter_tuple));
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f64)
                                    {
                                        if constexpr(f32_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_f64, wasm_f32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i32)
                                    {
                                        if constexpr(i32_f32_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_i32, wasm_f32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i64)
                                    {
                                        if constexpr(i64_f32_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_i64, wasm_f32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    break;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    if(spilled_vt == curr_operand_stack_value_type::f64)
                                    {
                                        patch_with(
                                            translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_f64, wasm_f64>(
                                                curr_stacktop,
                                                interpreter_tuple));
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f32)
                                    {
                                        if constexpr(f32_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_f32, wasm_f64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i32)
                                    {
                                        if constexpr(i32_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_i32, wasm_f64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i64)
                                    {
                                        if constexpr(i64_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_local_get_typed_fptr_from_tuple<CompileOption, wasm_i64, wasm_f64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    break;
                                }
                                [[unlikely]] default:
                                {
                                    break;
                                }
                            }

                            if(fused_spill_and_local_get)
                            {
                                // Emit only the immediate; opfunc slot was patched above.
                                emit_imm_to(dst, off);
                            }
                        }
#endif
                    }

                    if(!fused_spill_and_local_get) switch(vt)
                        {
                            case curr_operand_stack_value_type::i32:
                            {
                                emit_opfunc_to(dst, translate::get_uwvmint_local_get_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(dst, off);
                                break;
                            }
                            case curr_operand_stack_value_type::i64:
                            {
                                emit_opfunc_to(dst, translate::get_uwvmint_local_get_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(dst, off);
                                break;
                            }
                            case curr_operand_stack_value_type::f32:
                            {
                                emit_opfunc_to(dst, translate::get_uwvmint_local_get_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(dst, off);
                                break;
                            }
                            case curr_operand_stack_value_type::f64:
                            {
                                emit_opfunc_to(dst, translate::get_uwvmint_local_get_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(dst, off);
                                break;
                            }
                            [[unlikely]] default:
                            {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                break;
                            }
                        }

                    if constexpr(stacktop_enabled)
                    {
                        // Model effects: 1 value pushed into stack-top cache.
                        stacktop_commit_push1_typed_if_reachable(vt);
                    }
                }};

            [[maybe_unused]] auto const emit_const_i32_to{
                [&](bytecode_vec_t& dst, wasm_i32 imm) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    bool fused_spill_and_const{};

                    if constexpr(stacktop_enabled)
                    {
                        [[maybe_unused]] ::std::size_t const bc_before{dst.size()};
                        stacktop_prepare_push1_if_reachable(dst, curr_operand_stack_value_type::i32);

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(dst.size() != bc_before)
                        {
                            constexpr bool i32_i64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.i64_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.i64_stack_top_end_pos};
                            constexpr bool i32_f32_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                            constexpr bool i32_f64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                            using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;
                            using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;

                            auto const spilled_vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};

                            using opfunc_ptr_t = decltype(translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            ::std::size_t const fuse_site{dst.size() - sizeof(opfunc_ptr_t)};

                            auto patch_with{[&](auto fused_fptr) constexpr UWVM_THROWS
                                            {
                                                ::std::byte tmp[sizeof(fused_fptr)];
                                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                ::std::memcpy(dst.data() + fuse_site, tmp, sizeof(fused_fptr));
                                                fused_spill_and_const = true;
                                            }};

                            if(spilled_vt == curr_operand_stack_value_type::i32)
                            {
                                patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_i32, wasm_i32>(
                                    curr_stacktop,
                                    interpreter_tuple));
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::i64)
                            {
                                if constexpr(i32_i64_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_i64, wasm_i32>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::f32)
                            {
                                if constexpr(i32_f32_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_f32, wasm_i32>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::f64)
                            {
                                if constexpr(i32_f64_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_f64, wasm_i32>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }

                            if(fused_spill_and_const) { emit_imm_to(dst, imm); }
                        }
#endif
                    }

                    if(!fused_spill_and_const)
                    {
                        emit_opfunc_to(dst, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(dst, imm);
                    }

                    if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                }};

            [[maybe_unused]] auto const emit_const_i64_to{
                [&](bytecode_vec_t& dst, wasm_i64 imm) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    bool fused_spill_and_const{};

                    if constexpr(stacktop_enabled)
                    {
                        [[maybe_unused]] ::std::size_t const bc_before{dst.size()};
                        stacktop_prepare_push1_if_reachable(dst, curr_operand_stack_value_type::i64);

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(dst.size() != bc_before)
                        {
                            constexpr bool i32_i64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.i64_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.i64_stack_top_end_pos};
                            constexpr bool i64_f32_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                         CompileOption.i64_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                            constexpr bool i64_f64_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.i64_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                            using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;
                            using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;

                            auto const spilled_vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};

                            using opfunc_ptr_t = decltype(translate::get_uwvmint_i64_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            ::std::size_t const fuse_site{dst.size() - sizeof(opfunc_ptr_t)};

                            auto patch_with{[&](auto fused_fptr) constexpr UWVM_THROWS
                                            {
                                                ::std::byte tmp[sizeof(fused_fptr)];
                                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                ::std::memcpy(dst.data() + fuse_site, tmp, sizeof(fused_fptr));
                                                fused_spill_and_const = true;
                                            }};

                            if(spilled_vt == curr_operand_stack_value_type::i64)
                            {
                                patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_i64, wasm_i64>(
                                    curr_stacktop,
                                    interpreter_tuple));
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::i32)
                            {
                                if constexpr(i32_i64_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_i32, wasm_i64>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::f32)
                            {
                                if constexpr(i64_f32_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_f32, wasm_i64>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::f64)
                            {
                                if constexpr(i64_f64_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_f64, wasm_i64>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }

                            if(fused_spill_and_const) { emit_imm_to(dst, imm); }
                        }
#endif
                    }

                    if(!fused_spill_and_const)
                    {
                        emit_opfunc_to(dst, translate::get_uwvmint_i64_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(dst, imm);
                    }

                    if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i64); }
                }};

            [[maybe_unused]] auto const emit_const_f32_to{
                [&](bytecode_vec_t& dst, wasm_f32 imm) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    bool fused_spill_and_const{};

                    if constexpr(stacktop_enabled)
                    {
                        [[maybe_unused]] ::std::size_t const bc_before{dst.size()};
                        stacktop_prepare_push1_if_reachable(dst, curr_operand_stack_value_type::f32);

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(dst.size() != bc_before)
                        {
                            constexpr bool i32_f32_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                            constexpr bool i64_f32_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                         CompileOption.i64_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                            constexpr bool f32_f64_merge{CompileOption.f32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.f32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                            using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;

                            auto const spilled_vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};

                            using opfunc_ptr_t = decltype(translate::get_uwvmint_f32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            ::std::size_t const fuse_site{dst.size() - sizeof(opfunc_ptr_t)};

                            auto patch_with{[&](auto fused_fptr) constexpr UWVM_THROWS
                                            {
                                                ::std::byte tmp[sizeof(fused_fptr)];
                                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                ::std::memcpy(dst.data() + fuse_site, tmp, sizeof(fused_fptr));
                                                fused_spill_and_const = true;
                                            }};

                            if(spilled_vt == curr_operand_stack_value_type::f32)
                            {
                                patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_f32, wasm_f32>(
                                    curr_stacktop,
                                    interpreter_tuple));
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::f64)
                            {
                                if constexpr(f32_f64_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_f64, wasm_f32>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::i32)
                            {
                                if constexpr(i32_f32_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_i32, wasm_f32>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::i64)
                            {
                                if constexpr(i64_f32_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_i64, wasm_f32>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }

                            if(fused_spill_and_const) { emit_imm_to(dst, imm); }
                        }
#endif
                    }

                    if(!fused_spill_and_const)
                    {
                        emit_opfunc_to(dst, translate::get_uwvmint_f32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(dst, imm);
                    }

                    if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                }};

            [[maybe_unused]] auto const emit_const_f64_to{
                [&](bytecode_vec_t& dst, wasm_f64 imm) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    bool fused_spill_and_const{};

                    if constexpr(stacktop_enabled)
                    {
                        [[maybe_unused]] ::std::size_t const bc_before{dst.size()};
                        stacktop_prepare_push1_if_reachable(dst, curr_operand_stack_value_type::f64);

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(dst.size() != bc_before)
                        {
                            constexpr bool i32_f64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.i32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};
                            constexpr bool i64_f64_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.i64_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};
                            constexpr bool f32_f64_merge{CompileOption.f32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                         CompileOption.f32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                            using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;

                            auto const spilled_vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};

                            using opfunc_ptr_t = decltype(translate::get_uwvmint_f64_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            ::std::size_t const fuse_site{dst.size() - sizeof(opfunc_ptr_t)};

                            auto patch_with{[&](auto fused_fptr) constexpr UWVM_THROWS
                                            {
                                                ::std::byte tmp[sizeof(fused_fptr)];
                                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                ::std::memcpy(dst.data() + fuse_site, tmp, sizeof(fused_fptr));
                                                fused_spill_and_const = true;
                                            }};

                            if(spilled_vt == curr_operand_stack_value_type::f64)
                            {
                                patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_f64, wasm_f64>(
                                    curr_stacktop,
                                    interpreter_tuple));
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::f32)
                            {
                                if constexpr(f32_f64_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_f32, wasm_f64>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::i32)
                            {
                                if constexpr(i32_f64_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_i32, wasm_f64>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }
                            else if(spilled_vt == curr_operand_stack_value_type::i64)
                            {
                                if constexpr(i64_f64_merge)
                                {
                                    patch_with(translate::get_uwvmint_stacktop_spill1_then_const_typed_fptr_from_tuple<CompileOption, wasm_i64, wasm_f64>(
                                        curr_stacktop,
                                        interpreter_tuple));
                                }
                            }

                            if(fused_spill_and_const) { emit_imm_to(dst, imm); }
                        }
#endif
                    }

                    if(!fused_spill_and_const)
                    {
                        emit_opfunc_to(dst, translate::get_uwvmint_f64_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(dst, imm);
                    }

                    if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                }};

            auto const emit_local_set_typed_to{
                [&](bytecode_vec_t& dst, curr_operand_stack_value_type vt, local_offset_t off) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    if constexpr(stacktop_enabled)
                    {
                        // local.set reads its operand from stack-top cache; ensure cache is populated.
                        if(!is_polymorphic && stacktop_cache_count == 0uz) { stacktop_fill_to_canonical(dst); }
                    }

                    switch(vt)
                    {
                        case curr_operand_stack_value_type::i32:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_set_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::i64:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_set_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::f32:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_set_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::f64:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_set_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        [[unlikely]] default:
                        {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                            break;
                        }
                    }

                    if constexpr(stacktop_enabled)
                    {
                        // Model effects: 1 value popped (compiler-managed stack-top cursor).
                        if(!is_polymorphic)
                        {
                            stacktop_commit_pop_n(1uz);
                            codegen_stack_pop_n(1uz);
                            stacktop_fill_to_canonical(dst);
                        }
                    }
                }};

            // Local.set without emitting any canonical fills (see `emit_drop_typed_to_no_fill` rationale).
            [[maybe_unused]] auto const emit_local_set_typed_to_no_fill{
                [&](bytecode_vec_t& dst, curr_operand_stack_value_type vt, local_offset_t off) constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    if constexpr(stacktop_enabled)
                    {
                        // local.set reads its operand from stack-top cache; ensure the top value is resident in cache.
                        // Avoid a full canonical refill here; bulk repair will canonicalize once at the end when needed.
                        if(!is_polymorphic && stacktop_cache_count == 0uz) { stacktop_fill_one_from_memory_to(dst); }
                    }

                    switch(vt)
                    {
                        case curr_operand_stack_value_type::i32:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_set_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::i64:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_set_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::f32:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_set_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::f64:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_set_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        [[unlikely]] default:
                        {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                            break;
                        }
                    }

                    if constexpr(stacktop_enabled)
                    {
                        if(!is_polymorphic)
                        {
                            stacktop_commit_pop_n(1uz);
                            codegen_stack_pop_n(1uz);
                        }
                    }
                }};

            auto const emit_local_tee_typed_to{
                [&](bytecode_vec_t& dst, curr_operand_stack_value_type vt, local_offset_t off) constexpr UWVM_THROWS -> ::std::size_t
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    if constexpr(stacktop_enabled)
                    {
                        // local.tee reads the top value from stack-top cache; ensure cache is populated.
                        if(!is_polymorphic && stacktop_cache_count == 0uz) { stacktop_fill_to_canonical(dst); }
                    }

                    ::std::size_t const site{dst.size()};

                    switch(vt)
                    {
                        case curr_operand_stack_value_type::i32:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_tee_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::i64:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_tee_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::f32:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_tee_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        case curr_operand_stack_value_type::f64:
                        {
                            emit_opfunc_to(dst, translate::get_uwvmint_local_tee_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(dst, off);
                            break;
                        }
                        [[unlikely]] default:
                        {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                            break;
                        }
                    }

                    return site;
                }};

            auto const emit_br_to{[&](bytecode_vec_t& dst, ::std::size_t label_id, bool dst_is_thunk) constexpr UWVM_THROWS
                                  {
                                      namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                                      if(runtime_log_on) [[unlikely]]
                                      {
                                          ++runtime_log_stats.cf_br_count;
                                          if(runtime_log_emit_cf)
                                          {
                                              ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                   u8"[uwvm-int-translator] fn=",
                                                                   function_index,
                                                                   u8" ip=",
                                                                   runtime_log_curr_ip,
                                                                   u8" event=bytecode.emit.cf | op=br bc=",
                                                                   runtime_log_bc_name(dst_is_thunk),
                                                                   u8" off=",
                                                                   dst.size(),
                                                                   u8" label_id=",
                                                                   label_id,
                                                                   u8"\n");
                                          }
                                      }
                                      emit_opfunc_to(dst, translate::get_uwvmint_br_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                      emit_ptr_label_placeholder(label_id, dst_is_thunk);
                                  }};

            [[maybe_unused]] auto const emit_br_to_with_stacktop_transform{
                [&](bytecode_vec_t& dst, ::std::size_t label_id, bool dst_is_thunk) constexpr UWVM_THROWS
                {
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    if constexpr(stacktop_enabled && CompileOption.is_tail_call && stacktop_regtransform_cf_entry && stacktop_regtransform_supported)
                    {
                        if(!is_polymorphic && stacktop_cache_count != 0uz)
                        {
                            if(runtime_log_on) [[unlikely]]
                            {
                                ++runtime_log_stats.cf_br_transform_count;
                                if(runtime_log_emit_cf)
                                {
                                    ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                         u8"[uwvm-int-translator] fn=",
                                                         function_index,
                                                         u8" ip=",
                                                         runtime_log_curr_ip,
                                                         u8" event=bytecode.emit.cf | op=br_stacktop_transform_to_begin bc=",
                                                         runtime_log_bc_name(dst_is_thunk),
                                                         u8" off=",
                                                         dst.size(),
                                                         u8" label_id=",
                                                         label_id,
                                                         u8" cache=",
                                                         stacktop_cache_count,
                                                         u8"\n");
                                }
                            }
                            emit_opfunc_to(
                                dst,
                                translate::get_uwvmint_br_stacktop_transform_to_begin_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_ptr_label_placeholder(label_id, dst_is_thunk);
                            return;
                        }
                    }
#endif

                    // Fallback: plain `br`.
                    emit_br_to(dst, label_id, dst_is_thunk);
                }};

            auto const emit_return_to{[&](bytecode_vec_t& dst) constexpr UWVM_THROWS
                                      {
                                          namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                                          // Tail-call `return` requires flushing cached stack-top values back to the operand stack memory.
                                          // See optable/control.h `uwvmint_return` contract.
                                          stacktop_flush_all_to_operand_stack(dst);
                                          emit_opfunc_to(dst, translate::get_uwvmint_return_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                      }};

            // block type
            using value_type_enum = curr_operand_stack_value_type;
            static constexpr value_type_enum i32_result_arr[1u]{value_type_enum::i32};
            static constexpr value_type_enum i64_result_arr[1u]{value_type_enum::i64};
            static constexpr value_type_enum f32_result_arr[1u]{value_type_enum::f32};
            static constexpr value_type_enum f64_result_arr[1u]{value_type_enum::f64};

            auto const func_end_label_id{new_label(false)};

            // function block (label/result type is the function result)
            control_flow_stack.push_back({
                .result = {.begin = curr_func_type.result.begin, .end = curr_func_type.result.end},
                .operand_stack_base = 0uz,
                .type = block_type::function,
                .polymorphic_base = false,
                .then_polymorphic_end = false,
                .start_label_id = SIZE_MAX,
                .end_label_id = func_end_label_id,
                .else_label_id = SIZE_MAX
            });

            // start parse the code
            auto code_curr{code_begin};

            using wasm_value_type_u = ::uwvm2::parser::wasm::standard::wasm1::type::value_type;

            auto const validate_numeric_unary{
                [&](::uwvm2::utils::container::u8string_view op_name,
                    curr_operand_stack_value_type expected_operand_type,
                    curr_operand_stack_value_type result_type) constexpr UWVM_THROWS
                {
                    // op_name ...
                    // [safe] unsafe (could be the section_end)
                    // ^^ code_curr

                    auto const op_begin{code_curr};

                    // op_name ...
                    // [safe] unsafe (could be the section_end)
                    // ^^ op_begin

                    ++code_curr;

                    // op_name ...
                    // [safe]  unsafe (could be the section_end)
                    //         ^^ code_curr

                    if(is_polymorphic)
                    {
                        // Polymorphic stack: pops never underflow and types are ignored.
                        operand_stack_pop_n(1uz);
                        operand_stack_push(result_type);
                        return;
                    }

                    if(operand_stack.empty()) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.operand_stack_underflow.op_code_name = op_name;
                        err.err_selectable.operand_stack_underflow.stack_size_actual = 0uz;
                        err.err_selectable.operand_stack_underflow.stack_size_required = 1uz;
                        err.err_code = code_validation_error_code::operand_stack_underflow;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    auto const operand_type{operand_stack.back_unchecked().type};
                    operand_stack_pop_unchecked();

                    if(operand_type != expected_operand_type) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.numeric_operand_type_mismatch.op_code_name = op_name;
                        err.err_selectable.numeric_operand_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_operand_type);
                        err.err_selectable.numeric_operand_type_mismatch.actual_type = static_cast<wasm_value_type_u>(operand_type);
                        err.err_code = code_validation_error_code::numeric_operand_type_mismatch;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    operand_stack_push(result_type);
                }};

            auto const validate_numeric_binary{
                [&](::uwvm2::utils::container::u8string_view op_name,
                    curr_operand_stack_value_type expected_operand_type,
                    curr_operand_stack_value_type result_type) constexpr UWVM_THROWS
                {
                    // op_name ...
                    // [safe] unsafe (could be the section_end)
                    // ^^ code_curr

                    auto const op_begin{code_curr};

                    // op_name ...
                    // [safe] unsafe (could be the section_end)
                    // ^^ op_begin

                    ++code_curr;

                    // op_name ...
                    // [safe ] unsafe (could be the section_end)
                    //         ^^ code_curr

                    if(is_polymorphic)
                    {
                        // Polymorphic stack: pops never underflow and types are ignored.
                        operand_stack_pop_n(2uz);
                        operand_stack_push(result_type);
                        return;
                    }

                    if(operand_stack.size() < 2uz) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.operand_stack_underflow.op_code_name = op_name;
                        err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                        err.err_selectable.operand_stack_underflow.stack_size_required = 2uz;
                        err.err_code = code_validation_error_code::operand_stack_underflow;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    // rhs
                    auto const rhs_type{operand_stack.back_unchecked().type};
                    operand_stack_pop_unchecked();

                    if(rhs_type != expected_operand_type) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.numeric_operand_type_mismatch.op_code_name = op_name;
                        err.err_selectable.numeric_operand_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_operand_type);
                        err.err_selectable.numeric_operand_type_mismatch.actual_type = static_cast<wasm_value_type_u>(rhs_type);
                        err.err_code = code_validation_error_code::numeric_operand_type_mismatch;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    // lhs
                    auto const lhs_type{operand_stack.back_unchecked().type};
                    operand_stack_pop_unchecked();

                    if(lhs_type != expected_operand_type) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.numeric_operand_type_mismatch.op_code_name = op_name;
                        err.err_selectable.numeric_operand_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_operand_type);
                        err.err_selectable.numeric_operand_type_mismatch.actual_type = static_cast<wasm_value_type_u>(lhs_type);
                        err.err_code = code_validation_error_code::numeric_operand_type_mismatch;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    operand_stack_push(result_type);
                }};

            auto const validate_mem_load{
                [&](::uwvm2::utils::container::u8string_view op_name,
                    wasm_u32 const max_align,
                    curr_operand_stack_value_type const result_type) constexpr UWVM_THROWS -> wasm_u32
                {
                    // i32.load align offset ...
                    // [ safe ] unsafe (could be the section_end)
                    // ^^ code_curr

                    auto const op_begin{code_curr};

                    // i32.load align offset ...
                    // [ safe ] unsafe (could be the section_end)
                    // ^^ op_begin

                    ++code_curr;

                    // i32.load align offset ...
                    // [ safe ] unsafe (could be the section_end)
                    //          ^^ code_curr

                    wasm_u32 align;   // No initialization necessary
                    wasm_u32 offset;  // No initialization necessary

                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;

                    auto const [align_next, align_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                ::fast_io::mnp::leb128_get(align))};
                    if(align_err != ::fast_io::parse_code::ok) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_code = code_validation_error_code::invalid_memarg_align;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(align_err);
                    }

                    // i32.load align offset ...
                    // [    safe    ] unsafe (could be the section_end)
                    //          ^^ code_curr

                    code_curr = reinterpret_cast<::std::byte const*>(align_next);

                    // i32.load align offset ...
                    // [    safe    ] unsafe (could be the section_end)
                    //                ^^ code_curr

                    auto const [offset_next, offset_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                  reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                  ::fast_io::mnp::leb128_get(offset))};
                    if(offset_err != ::fast_io::parse_code::ok) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_code = code_validation_error_code::invalid_memarg_offset;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(offset_err);
                    }

                    // i32.load align offset ...
                    // [        safe       ] unsafe (could be the section_end)
                    //                ^^ code_curr

                    code_curr = reinterpret_cast<::std::byte const*>(offset_next);

                    // i32.load align offset ...
                    // [        safe       ] unsafe (could be the section_end)
                    //                       ^^ code_curr

                    if(all_memory_count == 0u) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.no_memory.op_code_name = op_name;
                        err.err_selectable.no_memory.align = align;
                        err.err_selectable.no_memory.offset = offset;
                        err.err_code = code_validation_error_code::no_memory;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    if(align > max_align) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.illegal_memarg_alignment.op_code_name = op_name;
                        err.err_selectable.illegal_memarg_alignment.align = align;
                        err.err_selectable.illegal_memarg_alignment.max_align = max_align;
                        err.err_code = code_validation_error_code::illegal_memarg_alignment;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    if(!is_polymorphic)
                    {
                        if(operand_stack.empty()) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = op_name;
                            err.err_selectable.operand_stack_underflow.stack_size_actual = 0uz;
                            err.err_selectable.operand_stack_underflow.stack_size_required = 1uz;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const addr{operand_stack.back_unchecked()};
                        operand_stack_pop_unchecked();

                        if(addr.type != wasm_value_type_u::i32) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.memarg_address_type_not_i32.op_code_name = op_name;
                            err.err_selectable.memarg_address_type_not_i32.addr_type = addr.type;
                            err.err_code = code_validation_error_code::memarg_address_type_not_i32;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }
                    }
                    else
                    {
                        operand_stack_pop_unchecked();
                    }

                    operand_stack_push(result_type);

                    return offset;
                }};

            auto const validate_mem_store{
                [&](::uwvm2::utils::container::u8string_view op_name,
                    wasm_u32 const max_align,
                    curr_operand_stack_value_type const expected_value_type) constexpr UWVM_THROWS -> wasm_u32
                {
                    // i32.store align offset ...
                    // [ safe  ] unsafe (could be the section_end)
                    // ^^ code_curr

                    auto const op_begin{code_curr};

                    // i32.store align offset ...
                    // [ safe  ] unsafe (could be the section_end)
                    // ^^ op_begin

                    ++code_curr;

                    // i32.store align offset ...
                    // [ safe  ] unsafe (could be the section_end)
                    //           ^^ code_curr

                    wasm_u32 align;   // No initialization necessary
                    wasm_u32 offset;  // No initialization necessary

                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;

                    auto const [align_next, align_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                ::fast_io::mnp::leb128_get(align))};
                    if(align_err != ::fast_io::parse_code::ok) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_code = code_validation_error_code::invalid_memarg_align;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(align_err);
                    }

                    // i32.store align offset ...
                    // [      safe   ] unsafe (could be the section_end)
                    //           ^^ code_curr

                    code_curr = reinterpret_cast<::std::byte const*>(align_next);

                    // i32.store align offset ...
                    // [      safe   ] unsafe (could be the section_end)
                    //                 ^^ code_curr

                    auto const [offset_next, offset_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                  reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                  ::fast_io::mnp::leb128_get(offset))};
                    if(offset_err != ::fast_io::parse_code::ok) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_code = code_validation_error_code::invalid_memarg_offset;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(offset_err);
                    }

                    // i32.store align offset ...
                    // [      safe          ] unsafe (could be the section_end)
                    //                 ^^ code_curr

                    code_curr = reinterpret_cast<::std::byte const*>(offset_next);

                    // i32.store align offset ...
                    // [      safe          ] unsafe (could be the section_end)
                    //                        ^^ code_curr

                    // MVP memory instructions implicitly target memory 0. If the module has no imported/defined memory, any load/store is invalid.
                    if(all_memory_count == 0u) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.no_memory.op_code_name = op_name;
                        err.err_selectable.no_memory.align = align;
                        err.err_selectable.no_memory.offset = offset;
                        err.err_code = code_validation_error_code::no_memory;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    if(align > max_align) [[unlikely]]
                    {
                        err.err_curr = op_begin;
                        err.err_selectable.illegal_memarg_alignment.op_code_name = op_name;
                        err.err_selectable.illegal_memarg_alignment.align = align;
                        err.err_selectable.illegal_memarg_alignment.max_align = max_align;
                        err.err_code = code_validation_error_code::illegal_memarg_alignment;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }

                    if(!is_polymorphic)
                    {
                        if(operand_stack.size() < 2uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = op_name;
                            err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                            err.err_selectable.operand_stack_underflow.stack_size_required = 2uz;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const value{operand_stack.back_unchecked()};
                        operand_stack_pop_unchecked();
                        auto const addr{operand_stack.back_unchecked()};
                        operand_stack_pop_unchecked();

                        if(addr.type != wasm_value_type_u::i32) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.memarg_address_type_not_i32.op_code_name = op_name;
                            err.err_selectable.memarg_address_type_not_i32.addr_type = addr.type;
                            err.err_code = code_validation_error_code::memarg_address_type_not_i32;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(value.type != expected_value_type) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.store_value_type_mismatch.op_code_name = op_name;
                            err.err_selectable.store_value_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_value_type);
                            err.err_selectable.store_value_type_mismatch.actual_type = value.type;
                            err.err_code = code_validation_error_code::store_value_type_mismatch;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }
                    }
                    else
                    {
                        operand_stack_pop_unchecked();
                        operand_stack_pop_unchecked();
                    }

                    return offset;
                }};

            // Resolve memory/global runtime pointers for translation.
            // NOTE: The UWVM-int optable currently encodes memory ops against `native_memory_t*` and global ops against `wasm_global_storage_t*`.
            // Local-imported (host) memories/globals do not expose these runtime objects, so they are not supported by this compiler backend yet.

            using native_memory_t = ::uwvm2::object::memory::linear::native_memory_t;
            using wasm_global_storage_t = ::uwvm2::object::global::wasm_global_storage_t;

            struct resolved_memory0_t
            {
                native_memory_t* memory_p{};
                ::std::size_t max_limit_memory_length{};
                bool resolved{};
            };

            resolved_memory0_t resolved_memory0{};

            auto const ensure_memory0_resolved{
                [&]() constexpr UWVM_THROWS
                {
                    if(resolved_memory0.resolved) { return; }

                    // Convert Wasm memory max pages into a byte-length bound for `native_memory_t::grow_*`.
                    auto const max_limit_from_limits{[&](auto const& limits) constexpr noexcept -> ::std::size_t
                                                     {
                                                         if(!limits.present_max) { return ::std::numeric_limits<::std::size_t>::max(); }
                                                         ::std::size_t const max_pages{static_cast<::std::size_t>(limits.max)};
                                                         constexpr ::std::size_t wasm_page_bytes{65536uz};
                                                         if(max_pages > (::std::numeric_limits<::std::size_t>::max() / wasm_page_bytes))
                                                         {
                                                             return ::std::numeric_limits<::std::size_t>::max();
                                                         }
                                                         return max_pages * wasm_page_bytes;
                                                     }};

                    if(all_memory_count == 0u) [[unlikely]]
                    {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                        ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                        ::fast_io::fast_terminate();
                    }

                    if(imported_memory_count != 0u)
                    {
                        using imported_memory_storage_t = ::uwvm2::uwvm::runtime::storage::imported_memory_storage_t;
                        using memory_link_kind = imported_memory_storage_t::imported_memory_link_kind;

                        auto const& imported_mem0{curr_module.imported_memory_vec_storage.index_unchecked(0uz)};
                        auto const import_type_ptr{imported_mem0.import_type_ptr};
                        if(import_type_ptr == nullptr) [[unlikely]]
                        {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                            ::fast_io::fast_terminate();
                        }

                        resolved_memory0.max_limit_memory_length = max_limit_from_limits(import_type_ptr->imports.storage.memory.limits);

                        // Follow import -> import -> ... chains until we reach a defined memory storage.
                        imported_memory_storage_t const* curr{::std::addressof(imported_mem0)};
                        for(;;)
                        {
                            if(curr == nullptr) [[unlikely]]
                            {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                ::fast_io::fast_terminate();
                            }

                            switch(curr->link_kind)
                            {
                                case memory_link_kind::imported:
                                {
                                    curr = curr->target.imported_ptr;
                                    continue;
                                }
                                case memory_link_kind::defined:
                                {
                                    auto def{curr->target.defined_ptr};
                                    if(def == nullptr) [[unlikely]]
                                    {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                        ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                        ::fast_io::fast_terminate();
                                    }
                                    resolved_memory0.memory_p = ::std::addressof(def->memory);
                                    resolved_memory0.resolved = true;
                                    return;
                                }
                                case memory_link_kind::local_imported:
                                    [[fallthrough]];
                                [[unlikely]] default:
                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                    ::fast_io::fast_terminate();
                                }
                            }
                        }
                    }
                    else
                    {
                        // Wasm1 MVP: at most one memory. This backend compiles memory index 0.
                        auto& local_mem0{curr_module.local_defined_memory_vec_storage.index_unchecked(0uz)};
                        resolved_memory0.memory_p = const_cast<native_memory_t*>(::std::addressof(local_mem0.memory));
                        auto const mem_type_ptr{local_mem0.memory_type_ptr};
                        if(mem_type_ptr == nullptr) [[unlikely]]
                        {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                            ::fast_io::fast_terminate();
                        }
                        resolved_memory0.max_limit_memory_length = max_limit_from_limits(mem_type_ptr->limits);
                        resolved_memory0.resolved = true;
                    }
                }};

            auto const resolve_global_storage_ptr{
                [&](wasm_u32 global_index) constexpr UWVM_THROWS -> wasm_global_storage_t*
                {
                    using imported_global_storage_t = ::uwvm2::uwvm::runtime::storage::imported_global_storage_t;
                    using global_link_kind = imported_global_storage_t::imported_global_link_kind;

                    if(global_index < imported_global_count)
                    {
                        imported_global_storage_t const* curr{
                            ::std::addressof(curr_module.imported_global_vec_storage.index_unchecked(static_cast<::std::size_t>(global_index)))};

                        for(;;)
                        {
                            if(curr == nullptr) [[unlikely]]
                            {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                ::fast_io::fast_terminate();
                            }

                            switch(curr->link_kind)
                            {
                                case global_link_kind::imported:
                                {
                                    curr = curr->target.imported_ptr;
                                    continue;
                                }
                                case global_link_kind::defined:
                                {
                                    auto def{curr->target.defined_ptr};
                                    if(def == nullptr) [[unlikely]]
                                    {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                        ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                        ::fast_io::fast_terminate();
                                    }
                                    return const_cast<wasm_global_storage_t*>(::std::addressof(def->global));
                                }
                                case global_link_kind::local_imported:
                                    [[fallthrough]];
                                [[unlikely]] default:
                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                    ::fast_io::fast_terminate();
                                }
                            }
                        }
                    }
                    else
                    {
                        auto const local_idx{static_cast<::std::size_t>(global_index - imported_global_count)};
                        auto& local_global{curr_module.local_defined_global_vec_storage.index_unchecked(local_idx)};
                        return const_cast<wasm_global_storage_t*>(::std::addressof(local_global.global));
                    }
                }};

            // [before_section ... ] | opbase opextent
            // [        safe       ] | unsafe (could be the section_end)
            //                         ^^ code_curr

            // a WebAssembly function with type '() -> ()' (often written as returning nil) can have no meaningful code, but it still must have a valid
            // instruction sequenceat minimum an end.

            using wasm1_code = ::uwvm2::runtime::compiler::uwvm_int::optable::wasm1_code;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
            enum class br_if_fuse_kind : unsigned
            {
                none,

                // cmp/eqz/and ; br_if
                local_tee_nz,
                i32_eqz,
                i32_eq,
                i32_ne,
                i32_lt_s,
                i32_lt_u,
                i32_gt_u,
                i32_ge_s,
                i32_ge_u,
                i32_le_u,
                i32_gt_s,
                i32_le_s,
                i32_and_nz,

                i64_eqz,
                i64_ne,
                i64_gt_u,
                i64_lt_u,

# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                f32_eq,
                f32_ne,
                f32_lt,
                f32_gt,
                f32_le,
                f32_ge,
                f64_eq,
                f64_lt,
                f64_lt_eqz,
# endif
            };

            enum class conbine_pending_kind : unsigned
            {
                none,
                local_get,
                local_get2,
                local_get2_const_i32,
                local_get2_const_i32_mul,
                local_get2_const_i32_shl,
                i32_add_2localget_local_set,
                i32_add_2localget_local_tee,
                i32_add_imm_local_settee_same,
                local_get_eqz_i32,
                local_get_const_i32,
                local_get_const_i64,
                const_i32,
                const_i64,
                local_get_const_i32_cmp_brif,
                local_get_const_i32_add,
                local_get_const_i32_add_localget,

# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                local_get_const_f32,
                local_get_const_f64,

                // heavy: const-first / imm-stack float patterns
                const_f32,                       // imm_f32
                const_f64,                       // imm_f64
                const_f32_localget,              // off1=src, imm_f32
                f32_div_from_imm_localtee_wait,  // off1=src, imm_f32

                // heavy: float mul-add/sub and 2mul patterns
                float_mul_2localget,          // off1, off2, vt={f32|f64}
                float_mul_2localget_local3,   // off1, off2, off3, vt={f32|f64}
                float_2mul_wait_second_mul,   // off1, off2, off3, off4, vt={f32|f64}
                float_2mul_after_second_mul,  // off1, off2, off3, off4, vt={f32|f64}

                // heavy: select(local.get a,b,cond)
                select_localget3,     // off1=a, off2=b, off3=cond, vt={i32|f32}
                select_after_select,  // waiting local.set/local.tee

                // heavy: mac local accumulator (acc + x*y -> acc)
                mac_localget3,  // off1=acc, off2=x, off3=y, vt={i32|i64|f32|f64}
                mac_after_mul,
                mac_after_add,

                // heavy: update_local add (dst = a + b)
                f32_add_2localget_local_set,  // off1, off2, off3=dst
                f32_add_2localget_local_tee,  // off1, off2, off3=dst
                f64_add_2localget_local_set,  // off1, off2, off3=dst
                f64_add_2localget_local_tee,  // off1, off2, off3=dst

                // heavy: br_if fuse (local-based)
                i32_rem_u_2localget_wait_eqz,
                i32_rem_u_eqz_2localget_wait_brif,

#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                // extra-heavy: loop fuse
                for_i32_inc_after_tee,
                for_i32_inc_after_end_const,
                for_i32_inc_after_cmp,
                for_ptr_inc_after_tee,
                for_ptr_inc_after_pend_get,
                for_ptr_inc_after_cmp,
#  endif

                // heavy: f64 loop condition (LLVM loop pattern; e.g. test8 hot loop)
                for_i32_inc_f64_lt_u_eqz_after_gets,
                for_i32_inc_f64_lt_u_eqz_after_step_const,
                for_i32_inc_f64_lt_u_eqz_after_add,
                for_i32_inc_f64_lt_u_eqz_after_tee,
                for_i32_inc_f64_lt_u_eqz_after_convert,
                for_i32_inc_f64_lt_u_eqz_after_cmp,
                for_i32_inc_f64_lt_u_eqz_after_eqz,

                // heavy: bit-mix
                xorshift_pre_shr,                 // off1=x, imm_i32=a
                xorshift_after_shr,               // off1=x, imm_i32=a
                xorshift_after_xor1,              // off1=x, imm_i32=a
                xorshift_after_xor1_getx,         // off1=x, imm_i32=a
                xorshift_after_xor1_getx_constb,  // off1=x, imm_i32=a, imm_i32_2=b
                xorshift_after_shl,               // off1=x, imm_i32=a, imm_i32_2=b

                rot_xor_add_after_rotl,        // off1=x, imm_i32=r
                rot_xor_add_after_gety,        // off1=x, off2=y, imm_i32=r
                rot_xor_add_after_xor,         // off1=x, off2=y, imm_i32=r
                rot_xor_add_after_xor_constc,  // off1=x, off2=y, imm_i32=r, imm_i32_2=c

                rotl_xor_local_set_after_rotl,  // off1=y, off2=x, imm_i32=r
                rotl_xor_local_set_after_xor,   // off1=y, off2=x, imm_i32=r

                // heavy: compound mem
                u16_copy_scaled_index_after_shl,  // off1=dst, off2=idx, imm_i32=sh
                u16_copy_scaled_index_after_load  // off1=dst, off2=idx, imm_i32=sh, imm_u32=src_off
# endif
            };

            enum class conbine_brif_cmp_kind : unsigned
            {
                none,
                i32_eq,
                i32_lt_s,
                i32_lt_u,
                i32_ge_s,
                i32_ge_u,
            };

            struct conbine_pending_t
            {
                conbine_pending_kind kind{conbine_pending_kind::none};
                conbine_brif_cmp_kind brif_cmp{conbine_brif_cmp_kind::none};
                curr_operand_stack_value_type vt{};
                local_offset_t off1{};
                local_offset_t off2{};
                local_offset_t off3{};
                local_offset_t off4{};
                wasm_i32 imm_i32{};
                wasm_i32 imm_i32_2{};
                wasm_u32 imm_u32{};
                wasm_u32 imm_u32_2{};
                wasm_i64 imm_i64{};

# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                wasm_f32 imm_f32{};
                wasm_f64 imm_f64{};
# endif
            };

            struct br_if_fuse_state_t
            {
                br_if_fuse_kind kind{br_if_fuse_kind::none};
                ::std::size_t site{SIZE_MAX};  // byte offset within `bytecode` to patch
                ::std::size_t end{SIZE_MAX};   // byte offset at end of the candidate op within `bytecode` (SIZE_MAX => op has no immediates)

                // Stack-top snapshot at the candidate-op entry (used to select the correct fused `br_if_*` specialization).
                ::uwvm2::runtime::compiler::uwvm_int::optable::uwvm_interpreter_stacktop_currpos_t stacktop_currpos_at_site{};
            };

            br_if_fuse_state_t br_if_fuse{};
            conbine_pending_t conbine_pending{};

            auto const runtime_log_conbine_kind_name{[]([[maybe_unused]] conbine_pending_kind k) constexpr noexcept -> ::uwvm2::utils::container::u8string_view
                                                     {
                                                         switch(k)
                                                         {
                                                             case conbine_pending_kind::none: return u8"none";
                                                             case conbine_pending_kind::local_get: return u8"local_get";
                                                             case conbine_pending_kind::local_get2: return u8"local_get2";
                                                             case conbine_pending_kind::local_get2_const_i32: return u8"local_get2_const_i32";
                                                             case conbine_pending_kind::local_get2_const_i32_mul: return u8"local_get2_const_i32_mul";
                                                             case conbine_pending_kind::local_get2_const_i32_shl: return u8"local_get2_const_i32_shl";
                                                             case conbine_pending_kind::i32_add_2localget_local_set: return u8"i32_add_2localget_local_set";
                                                             case conbine_pending_kind::i32_add_2localget_local_tee: return u8"i32_add_2localget_local_tee";
                                                             case conbine_pending_kind::i32_add_imm_local_settee_same: return u8"i32_add_imm_local_settee_same";
                                                             case conbine_pending_kind::local_get_eqz_i32: return u8"local_get_eqz_i32";
                                                             case conbine_pending_kind::local_get_const_i32: return u8"local_get_const_i32";
                                                             case conbine_pending_kind::local_get_const_i64: return u8"local_get_const_i64";
                                                             case conbine_pending_kind::const_i32: return u8"const_i32";
                                                             case conbine_pending_kind::const_i64: return u8"const_i64";
                                                             case conbine_pending_kind::local_get_const_i32_cmp_brif: return u8"local_get_const_i32_cmp_brif";
                                                             case conbine_pending_kind::local_get_const_i32_add: return u8"local_get_const_i32_add";
                                                             case conbine_pending_kind::local_get_const_i32_add_localget:
                                                                 return u8"local_get_const_i32_add_localget";
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                                             case conbine_pending_kind::local_get_const_f32: return u8"local_get_const_f32";
                                                             case conbine_pending_kind::local_get_const_f64: return u8"local_get_const_f64";
                                                             case conbine_pending_kind::const_f32: return u8"const_f32";
                                                             case conbine_pending_kind::const_f64: return u8"const_f64";
                                                             case conbine_pending_kind::const_f32_localget: return u8"const_f32_localget";
                                                             case conbine_pending_kind::f32_div_from_imm_localtee_wait:
                                                                 return u8"f32_div_from_imm_localtee_wait";
                                                             case conbine_pending_kind::float_mul_2localget: return u8"float_mul_2localget";
                                                             case conbine_pending_kind::float_mul_2localget_local3: return u8"float_mul_2localget_local3";
                                                             case conbine_pending_kind::float_2mul_wait_second_mul: return u8"float_2mul_wait_second_mul";
                                                             case conbine_pending_kind::float_2mul_after_second_mul: return u8"float_2mul_after_second_mul";
                                                             case conbine_pending_kind::select_localget3: return u8"select_localget3";
                                                             case conbine_pending_kind::select_after_select: return u8"select_after_select";
                                                             case conbine_pending_kind::mac_localget3: return u8"mac_localget3";
                                                             case conbine_pending_kind::mac_after_mul: return u8"mac_after_mul";
                                                             case conbine_pending_kind::mac_after_add: return u8"mac_after_add";
                                                             case conbine_pending_kind::f32_add_2localget_local_set: return u8"f32_add_2localget_local_set";
                                                             case conbine_pending_kind::f32_add_2localget_local_tee: return u8"f32_add_2localget_local_tee";
                                                             case conbine_pending_kind::f64_add_2localget_local_set: return u8"f64_add_2localget_local_set";
                                                             case conbine_pending_kind::f64_add_2localget_local_tee: return u8"f64_add_2localget_local_tee";
                                                             case conbine_pending_kind::i32_rem_u_2localget_wait_eqz: return u8"i32_rem_u_2localget_wait_eqz";
                                                             case conbine_pending_kind::i32_rem_u_eqz_2localget_wait_brif:
                                                                 return u8"i32_rem_u_eqz_2localget_wait_brif";
#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                                                             case conbine_pending_kind::for_i32_inc_after_tee: return u8"for_i32_inc_after_tee";
                                                             case conbine_pending_kind::for_i32_inc_after_end_const: return u8"for_i32_inc_after_end_const";
                                                             case conbine_pending_kind::for_i32_inc_after_cmp: return u8"for_i32_inc_after_cmp";
                                                             case conbine_pending_kind::for_ptr_inc_after_tee: return u8"for_ptr_inc_after_tee";
                                                             case conbine_pending_kind::for_ptr_inc_after_pend_get: return u8"for_ptr_inc_after_pend_get";
                                                             case conbine_pending_kind::for_ptr_inc_after_cmp: return u8"for_ptr_inc_after_cmp";
#  endif
                                                             case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_gets:
                                                                 return u8"for_i32_inc_f64_lt_u_eqz_after_gets";
                                                             case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_step_const:
                                                                 return u8"for_i32_inc_f64_lt_u_eqz_after_step_const";
                                                             case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_add:
                                                                 return u8"for_i32_inc_f64_lt_u_eqz_after_add";
                                                             case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_tee:
                                                                 return u8"for_i32_inc_f64_lt_u_eqz_after_tee";
                                                             case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_convert:
                                                                 return u8"for_i32_inc_f64_lt_u_eqz_after_convert";
                                                             case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_cmp:
                                                                 return u8"for_i32_inc_f64_lt_u_eqz_after_cmp";
                                                             case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_eqz:
                                                                 return u8"for_i32_inc_f64_lt_u_eqz_after_eqz";
                                                             case conbine_pending_kind::xorshift_pre_shr: return u8"xorshift_pre_shr";
                                                             case conbine_pending_kind::xorshift_after_shr: return u8"xorshift_after_shr";
                                                             case conbine_pending_kind::xorshift_after_xor1: return u8"xorshift_after_xor1";
                                                             case conbine_pending_kind::xorshift_after_xor1_getx: return u8"xorshift_after_xor1_getx";
                                                             case conbine_pending_kind::xorshift_after_xor1_getx_constb:
                                                                 return u8"xorshift_after_xor1_getx_constb";
                                                             case conbine_pending_kind::xorshift_after_shl: return u8"xorshift_after_shl";
                                                             case conbine_pending_kind::rot_xor_add_after_rotl: return u8"rot_xor_add_after_rotl";
                                                             case conbine_pending_kind::rot_xor_add_after_gety: return u8"rot_xor_add_after_gety";
                                                             case conbine_pending_kind::rot_xor_add_after_xor: return u8"rot_xor_add_after_xor";
                                                             case conbine_pending_kind::rot_xor_add_after_xor_constc: return u8"rot_xor_add_after_xor_constc";
                                                             case conbine_pending_kind::rotl_xor_local_set_after_rotl: return u8"rotl_xor_local_set_after_rotl";
                                                             case conbine_pending_kind::rotl_xor_local_set_after_xor: return u8"rotl_xor_local_set_after_xor";
                                                             case conbine_pending_kind::u16_copy_scaled_index_after_shl:
                                                                 return u8"u16_copy_scaled_index_after_shl";
                                                             case conbine_pending_kind::u16_copy_scaled_index_after_load:
                                                                 return u8"u16_copy_scaled_index_after_load";
# endif
                                                             [[unlikely]] default:
                                                                 return u8"?";
                                                         }
                                                     }};

            auto const runtime_log_conbine_brif_cmp_name{
                []([[maybe_unused]] conbine_brif_cmp_kind k) constexpr noexcept -> ::uwvm2::utils::container::u8string_view
                {
                    switch(k)
                    {
                        case conbine_brif_cmp_kind::none: return u8"none";
                        case conbine_brif_cmp_kind::i32_eq: return u8"i32_eq";
                        case conbine_brif_cmp_kind::i32_lt_s: return u8"i32_lt_s";
                        case conbine_brif_cmp_kind::i32_lt_u: return u8"i32_lt_u";
                        case conbine_brif_cmp_kind::i32_ge_s: return u8"i32_ge_s";
                        case conbine_brif_cmp_kind::i32_ge_u:
                            return u8"i32_ge_u";
                        [[unlikely]] default:
                            return u8"?";
                    }
                }};

            auto const flush_conbine_pending{
                [&]() constexpr UWVM_THROWS
                {
                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                    auto const kind_before{conbine_pending.kind};
                    auto const bc_before{bytecode.size()};
                    auto const thunks_before{thunks.size()};

                    if(runtime_log_on && kind_before != conbine_pending_kind::none) [[unlikely]]
                    {
                        wasm1_code next_op{};
                        ::std::uint_least8_t next_op_u8{};
                        bool const has_next_op{code_curr != code_end};
                        if(has_next_op)
                        {
                            ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(wasm1_code));
                            next_op_u8 = static_cast<::std::uint_least8_t>(next_op);
                        }

                        ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                             u8"[uwvm-int-translator] fn=",
                                             function_index,
                                             u8" ip=",
                                             static_cast<::std::size_t>(code_curr - code_begin),
                                             u8" event=conbine.flush.before | kind=",
                                             runtime_log_conbine_kind_name(kind_before),
                                             u8" next_op=",
                                             (has_next_op ? runtime_log_op_name(next_op) : u8"<eof>"),
                                             u8"(",
                                             static_cast<::std::size_t>(next_op_u8),
                                             u8")",
                                             u8" brif=",
                                             runtime_log_conbine_brif_cmp_name(conbine_pending.brif_cmp),
                                             u8" vt=",
                                             runtime_log_vt_name(conbine_pending.vt),
                                             u8" off{",
                                             conbine_pending.off1,
                                             u8",",
                                             conbine_pending.off2,
                                             u8",",
                                             conbine_pending.off3,
                                             u8",",
                                             conbine_pending.off4,
                                             u8"} imm{i32=",
                                             conbine_pending.imm_i32,
                                             u8",i32_2=",
                                             conbine_pending.imm_i32_2,
                                             u8",u32=",
                                             conbine_pending.imm_u32,
                                             u8",u32_2=",
                                             conbine_pending.imm_u32_2,
                                             u8",i64=",
                                             conbine_pending.imm_i64,
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                             u8",f32=",
                                             conbine_pending.imm_f32,
                                             u8",f64=",
                                             conbine_pending.imm_f64,
# endif
                                             u8"} bytecode{main=",
                                             bc_before,
                                             u8",thunk=",
                                             thunks_before,
                                             u8"}\n");
                    }

                    switch(conbine_pending.kind)
                    {
                        case conbine_pending_kind::none:
                        {
                            return;
                        }
                        case conbine_pending_kind::local_get:
                        {
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off1);
                            break;
                        }
                        case conbine_pending_kind::local_get2:
                        {
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off2);
                            break;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        case conbine_pending_kind::const_i32:
                        {
                            emit_const_i32_to(bytecode, conbine_pending.imm_i32);
                            break;
                        }
                        case conbine_pending_kind::const_i64:
                        {
                            emit_const_i64_to(bytecode, conbine_pending.imm_i64);
                            break;
                        }
                        case conbine_pending_kind::i32_add_2localget_local_set: [[fallthrough]];
                        case conbine_pending_kind::i32_add_2localget_local_tee:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
                        case conbine_pending_kind::local_get2_const_i32:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            emit_const_i32_to(bytecode, conbine_pending.imm_i32);
                            break;
                        }
                        case conbine_pending_kind::local_get2_const_i32_mul:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            emit_const_i32_to(bytecode, conbine_pending.imm_i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            if constexpr(stacktop_enabled) { stacktop_after_pop_n_if_reachable(bytecode, 1uz); }
                            break;
                        }
                        case conbine_pending_kind::local_get2_const_i32_shl:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            emit_const_i32_to(bytecode, conbine_pending.imm_i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_shl_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            if constexpr(stacktop_enabled) { stacktop_after_pop_n_if_reachable(bytecode, 1uz); }
                            break;
                        }
                        case conbine_pending_kind::i32_add_imm_local_settee_same:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
                        case conbine_pending_kind::local_get_eqz_i32:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_eqz_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
                        case conbine_pending_kind::local_get_const_i32:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            emit_const_i32_to(bytecode, conbine_pending.imm_i32);
                            break;
                        }
                        case conbine_pending_kind::local_get_const_i32_add:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            emit_const_i32_to(bytecode, conbine_pending.imm_i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            if constexpr(stacktop_enabled) { stacktop_after_pop_n_if_reachable(bytecode, 1uz); }
                            break;
                        }
                        case conbine_pending_kind::local_get_const_i32_add_localget:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            emit_const_i32_to(bytecode, conbine_pending.imm_i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            if constexpr(stacktop_enabled) { stacktop_after_pop_n_if_reachable(bytecode, 1uz); }
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off2);
                            break;
                        }
                        case conbine_pending_kind::local_get_const_i64:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i64, conbine_pending.off1);
                            emit_const_i64_to(bytecode, conbine_pending.imm_i64);
                            break;
                        }
                        case conbine_pending_kind::local_get_const_i32_cmp_brif:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            switch(conbine_pending.brif_cmp)
                            {
                                case conbine_brif_cmp_kind::i32_eq:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_i32_eq_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case conbine_brif_cmp_kind::i32_lt_s:
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_i32_lt_s_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case conbine_brif_cmp_kind::i32_lt_u:
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_i32_lt_u_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case conbine_brif_cmp_kind::i32_ge_s:
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_i32_ge_s_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case conbine_brif_cmp_kind::i32_ge_u:
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_i32_ge_u_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case conbine_brif_cmp_kind::none:
                                {
                                    [[fallthrough]];
                                }
                                [[unlikely]] default:
                                {
#  if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#  endif
                                    ::fast_io::fast_terminate();
                                }
                            }

                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }

                            break;
                        }
#  ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        case conbine_pending_kind::local_get_const_f32:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f32, conbine_pending.off1);
                            emit_const_f32_to(bytecode, conbine_pending.imm_f32);
                            break;
                        }
                        case conbine_pending_kind::local_get_const_f64:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f64, conbine_pending.off1);
                            emit_const_f64_to(bytecode, conbine_pending.imm_f64);
                            break;
                        }
                        case conbine_pending_kind::const_f32:
                        {
                            emit_const_f32_to(bytecode, conbine_pending.imm_f32);
                            break;
                        }
                        case conbine_pending_kind::const_f64:
                        {
                            emit_const_f64_to(bytecode, conbine_pending.imm_f64);
                            break;
                        }
                        case conbine_pending_kind::const_f32_localget:
                        {
                            emit_const_f32_to(bytecode, conbine_pending.imm_f32);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f32, conbine_pending.off1);
                            break;
                        }
                        case conbine_pending_kind::f32_div_from_imm_localtee_wait:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_div_from_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                            break;
                        }
                        case conbine_pending_kind::float_mul_2localget:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, conbine_pending.vt); }
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f32_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(conbine_pending.vt); }

                            break;
                        }
                        case conbine_pending_kind::float_mul_2localget_local3:
                        {
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32)
                            {
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f32_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f32, conbine_pending.off3);
                            }
                            else
                            {
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f64, conbine_pending.off3);
                            }
                            break;
                        }
                        case conbine_pending_kind::float_2mul_wait_second_mul:
                        {
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32)
                            {
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f32_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f32, conbine_pending.off3);
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f32, conbine_pending.off4);
                            }
                            else
                            {
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f64, conbine_pending.off3);
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f64, conbine_pending.off4);
                            }
                            break;
                        }
                        case conbine_pending_kind::float_2mul_after_second_mul:
                        {
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32)
                            {
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f32_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f32_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off3);
                                emit_imm_to(bytecode, conbine_pending.off4);
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                            }
                            else
                            {
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off3);
                                emit_imm_to(bytecode, conbine_pending.off4);
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                            }
                            break;
                        }
                        case conbine_pending_kind::select_localget3:
                        {
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off2);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off3);
                            break;
                        }
                        case conbine_pending_kind::select_after_select:
                        {
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off2);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off3);
                            if(conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_select_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_select_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                            break;
                        }
                        case conbine_pending_kind::mac_localget3:
                        {
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off2);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off3);
                            break;
                        }
                        case conbine_pending_kind::mac_after_mul:
                        {
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off2);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off3);
                            if(conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_i32_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            else if(conbine_pending.vt == curr_operand_stack_value_type::i64)
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_i64_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            else if(conbine_pending.vt == curr_operand_stack_value_type::f32)
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_f32_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_f64_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            break;
                        }
                        case conbine_pending_kind::mac_after_add:
                        {
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off2);
                            emit_local_get_typed_to(bytecode, conbine_pending.vt, conbine_pending.off3);
                            if(conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_i32_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                                emit_opfunc_to(bytecode, translate::get_uwvmint_i32_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                            else if(conbine_pending.vt == curr_operand_stack_value_type::i64)
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_i64_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                                emit_opfunc_to(bytecode, translate::get_uwvmint_i64_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                            else if(conbine_pending.vt == curr_operand_stack_value_type::f32)
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_f32_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                                emit_opfunc_to(bytecode, translate::get_uwvmint_f32_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                            else
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_f64_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                                emit_opfunc_to(bytecode, translate::get_uwvmint_f64_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                            break;
                        }

                        case conbine_pending_kind::f32_add_2localget_local_set: [[fallthrough]];
                        case conbine_pending_kind::f32_add_2localget_local_tee:
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            break;
                        }
                        case conbine_pending_kind::f64_add_2localget_local_set: [[fallthrough]];
                        case conbine_pending_kind::f64_add_2localget_local_tee:
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            break;
                        }

                        case conbine_pending_kind::i32_rem_u_2localget_wait_eqz:
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rem_u_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            break;
                        }
                        case conbine_pending_kind::i32_rem_u_eqz_2localget_wait_brif:
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rem_u_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_eqz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            break;
                        }

#   ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                        case conbine_pending_kind::for_i32_inc_after_tee:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_local_tee_same_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
                        case conbine_pending_kind::for_i32_inc_after_end_const:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_local_tee_same_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32_2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
                        case conbine_pending_kind::for_i32_inc_after_cmp:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_local_tee_same_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32_2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_lt_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            break;
                        }
                        case conbine_pending_kind::for_ptr_inc_after_tee:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_local_tee_same_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
                        case conbine_pending_kind::for_ptr_inc_after_pend_get:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_local_tee_same_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            break;
                        }
                        case conbine_pending_kind::for_ptr_inc_after_cmp:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_local_tee_same_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ne_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            break;
                        }
#   endif
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_gets: [[fallthrough]];
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_step_const: [[fallthrough]];
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_add: [[fallthrough]];
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_tee: [[fallthrough]];
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_convert: [[fallthrough]];
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_cmp: [[fallthrough]];
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_eqz:
                        {
                            // Sequence:
                            //   local.get(sqrt:f64); local.get(i:i32); i32.const step; i32.add; local.tee i;
                            //   f64.convert_i32_u; f64.lt; i32.eqz
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::f64, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_gets) { break; }

                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_step_const) { break; }

                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_add) { break; }

                            (void)emit_local_tee_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_tee) { break; }

                            if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f64) &&
                                         !stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64))
                            {
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_convert_i32_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64))
                            {
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f64); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f64);
                            }
                            if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_convert) { break; }

                            if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                         !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                            {
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_lt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if)
                            {
                                if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                                {
                                    stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                    if constexpr(stacktop_enabled)
                                    {
                                        if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                    }
                                }
                                else
                                {
                                    stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                                }
                            }
                            else
                            {
                                if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                                {
                                    stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                                }
                                else
                                {
                                    stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                                }
                            }

                            if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_cmp) { break; }

                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_eqz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            break;
                        }
                        case conbine_pending_kind::xorshift_pre_shr: [[fallthrough]];
                        case conbine_pending_kind::xorshift_after_shr: [[fallthrough]];
                        case conbine_pending_kind::xorshift_after_xor1: [[fallthrough]];
                        case conbine_pending_kind::xorshift_after_xor1_getx: [[fallthrough]];
                        case conbine_pending_kind::xorshift_after_xor1_getx_constb: [[fallthrough]];
                        case conbine_pending_kind::xorshift_after_shl:
                        {
                            // Sequence:
                            //   local.get x; local.get x; i32.const a; i32.shr_u; i32.xor;
                            //   local.get x; i32.const b; i32.shl; i32.xor
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            if(conbine_pending.kind == conbine_pending_kind::xorshift_pre_shr) { break; }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_shr_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            if(conbine_pending.kind == conbine_pending_kind::xorshift_after_shr) { break; }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_xor_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            if(conbine_pending.kind == conbine_pending_kind::xorshift_after_xor1) { break; }
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            if(conbine_pending.kind == conbine_pending_kind::xorshift_after_xor1_getx) { break; }
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32_2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            if(conbine_pending.kind == conbine_pending_kind::xorshift_after_xor1_getx_constb) { break; }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_shl_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            break;
                        }
                        case conbine_pending_kind::rot_xor_add_after_rotl: [[fallthrough]];
                        case conbine_pending_kind::rot_xor_add_after_gety: [[fallthrough]];
                        case conbine_pending_kind::rot_xor_add_after_xor: [[fallthrough]];
                        case conbine_pending_kind::rot_xor_add_after_xor_constc:
                        {
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rotl_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            if(conbine_pending.kind == conbine_pending_kind::rot_xor_add_after_rotl) { break; }
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            if(conbine_pending.kind == conbine_pending_kind::rot_xor_add_after_gety) { break; }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_xor_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            if(conbine_pending.kind == conbine_pending_kind::rot_xor_add_after_xor) { break; }
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32_2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
                        case conbine_pending_kind::rotl_xor_local_set_after_rotl: [[fallthrough]];
                        case conbine_pending_kind::rotl_xor_local_set_after_xor:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rotl_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            if(conbine_pending.kind == conbine_pending_kind::rotl_xor_local_set_after_rotl) { break; }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_xor_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            break;
                        }
                        case conbine_pending_kind::u16_copy_scaled_index_after_shl: [[fallthrough]];
                        case conbine_pending_kind::u16_copy_scaled_index_after_load:
                        {
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off2);
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_shl_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            if(conbine_pending.kind == conbine_pending_kind::u16_copy_scaled_index_after_shl) { break; }

                            ensure_memory0_resolved();
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_load16_u_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                  *resolved_memory0.memory_p,
                                                                                                                  interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_i32_load16_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            emit_imm_to(bytecode, resolved_memory0.memory_p);
                            emit_imm_to(bytecode, conbine_pending.imm_u32);
                            break;
                        }
#  endif
# endif  // UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        [[unlikely]] default:
                        {
# if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
# endif
                            break;
                        }
                    }

                    conbine_pending.kind = conbine_pending_kind::none;
                    conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;

                    if(runtime_log_on && kind_before != conbine_pending_kind::none) [[unlikely]]
                    {
                        wasm1_code next_op{};
                        ::std::uint_least8_t next_op_u8{};
                        bool const has_next_op{code_curr != code_end};
                        if(has_next_op)
                        {
                            ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(wasm1_code));
                            next_op_u8 = static_cast<::std::uint_least8_t>(next_op);
                        }

                        ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                             u8"[uwvm-int-translator] fn=",
                                             function_index,
                                             u8" ip=",
                                             static_cast<::std::size_t>(code_curr - code_begin),
                                             u8" event=conbine.flush.after | kind=",
                                             runtime_log_conbine_kind_name(kind_before),
                                             u8" next_op=",
                                             (has_next_op ? runtime_log_op_name(next_op) : u8"<eof>"),
                                             u8"(",
                                             static_cast<::std::size_t>(next_op_u8),
                                             u8")",
                                             u8" bytecode{main=",
                                             bytecode.size(),
                                             u8"(+",
                                             bytecode.size() - bc_before,
                                             u8"),thunk=",
                                             thunks.size(),
                                             u8"(+",
                                             thunks.size() - thunks_before,
                                             u8")}\n");
                    }
                }};

            [[maybe_unused]] auto const conbine_can_continue{
                [&](wasm1_code op) constexpr noexcept -> bool
                {
                    switch(conbine_pending.kind)
                    {
                        case conbine_pending_kind::none:
                        {
                            return true;
                        }
                        case conbine_pending_kind::const_i32:
                        {
                            switch(op)
                            {
                                case wasm1_code::i32_add: [[fallthrough]];
                                case wasm1_code::i32_sub: [[fallthrough]];
                                case wasm1_code::i32_mul: [[fallthrough]];
                                case wasm1_code::i32_and: [[fallthrough]];
                                case wasm1_code::i32_or: [[fallthrough]];
                                case wasm1_code::i32_xor: [[fallthrough]];
                                case wasm1_code::i32_shl: [[fallthrough]];
                                case wasm1_code::i32_shr_s: [[fallthrough]];
                                case wasm1_code::i32_shr_u: [[fallthrough]];
                                case wasm1_code::i32_rotl: [[fallthrough]];
                                case wasm1_code::i32_rotr:
                                {
                                    return true;
                                }
                                [[unlikely]] default:
                                {
                                    return false;
                                }
                            }
                        }
                        case conbine_pending_kind::const_i64:
                        {
                            switch(op)
                            {
                                case wasm1_code::i64_add: [[fallthrough]];
                                case wasm1_code::i64_sub: [[fallthrough]];
                                case wasm1_code::i64_mul: [[fallthrough]];
                                case wasm1_code::i64_and: [[fallthrough]];
                                case wasm1_code::i64_or: [[fallthrough]];
                                case wasm1_code::i64_xor: [[fallthrough]];
                                case wasm1_code::i64_shl: [[fallthrough]];
                                case wasm1_code::i64_shr_s: [[fallthrough]];
                                case wasm1_code::i64_shr_u: [[fallthrough]];
                                case wasm1_code::i64_rotl: [[fallthrough]];
                                case wasm1_code::i64_rotr:
                                {
                                    return true;
                                }
                                [[unlikely]] default:
                                {
                                    return false;
                                }
                            }
                        }
                        case conbine_pending_kind::local_get:
                        {
                            if(op == wasm1_code::local_get) { return true; }
                            if(conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                return op == wasm1_code::i32_const || op == wasm1_code::i32_eqz || op == wasm1_code::i32_load ||
                                       (CompileOption.is_tail_call && (op == wasm1_code::i32_load8_s || op == wasm1_code::i32_load8_u ||
                                                                       op == wasm1_code::i32_load16_s || op == wasm1_code::i32_load16_u))
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                       || op == wasm1_code::i32_clz || op == wasm1_code::i32_ctz || op == wasm1_code::i32_popcnt ||
                                       op == wasm1_code::f32_convert_i32_s || op == wasm1_code::f32_convert_i32_u
# endif
                                    ;
                            }
                            if(conbine_pending.vt == curr_operand_stack_value_type::i64) { return op == wasm1_code::i64_const; }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32)
                            {
                                switch(op)
                                {
                                    case wasm1_code::f32_const:
                                    case wasm1_code::f32_abs:
                                    case wasm1_code::f32_neg:
                                    case wasm1_code::f32_sqrt:
                                    case wasm1_code::i32_trunc_f32_s:
                                    case wasm1_code::i32_trunc_f32_u:
                                    {
                                        return true;
                                    }
                                    [[unlikely]] default:
                                    {
                                        return false;
                                    }
                                }
                            }
                            if(conbine_pending.vt == curr_operand_stack_value_type::f64)
                            {
                                switch(op)
                                {
                                    case wasm1_code::f64_const:
                                    case wasm1_code::f64_abs:
                                    case wasm1_code::f64_neg:
                                    case wasm1_code::f64_sqrt:
                                    case wasm1_code::i32_trunc_f64_s:
                                    case wasm1_code::i32_trunc_f64_u:
                                    {
                                        return true;
                                    }
                                    [[unlikely]] default:
                                    {
                                        return false;
                                    }
                                }
                            }
# endif
                            return false;
                        }
                        case conbine_pending_kind::local_get2:
                        {
                            if(conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                switch(op)
                                {
                                    case wasm1_code::i32_const: [[fallthrough]];
                                    case wasm1_code::i32_add: [[fallthrough]];
                                    case wasm1_code::i32_sub: [[fallthrough]];
                                    case wasm1_code::i32_mul: [[fallthrough]];
                                    case wasm1_code::i32_and: [[fallthrough]];
                                    case wasm1_code::i32_or: [[fallthrough]];
                                    case wasm1_code::i32_xor: [[fallthrough]];
                                    case wasm1_code::i32_rem_s: [[fallthrough]];
                                    case wasm1_code::i32_rem_u: [[fallthrough]];
                                    case wasm1_code::i32_load: [[fallthrough]];
                                    case wasm1_code::i32_load8_s: [[fallthrough]];
                                    case wasm1_code::i32_load8_u: [[fallthrough]];
                                    case wasm1_code::i32_load16_s: [[fallthrough]];
                                    case wasm1_code::i32_load16_u: [[fallthrough]];
                                    case wasm1_code::i32_store: [[fallthrough]];
                                    case wasm1_code::i32_store8: [[fallthrough]];
                                    case wasm1_code::i32_store16:
                                    {
                                        return true;
                                    }
                                    [[unlikely]] default:
                                    {
                                        return false;
                                    }
                                }
                            }
                            if(conbine_pending.vt == curr_operand_stack_value_type::i64) { return op == wasm1_code::i64_add; }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32)
                            {
                                switch(op)
                                {
                                    case wasm1_code::f32_add: [[fallthrough]];
                                    case wasm1_code::f32_sub: [[fallthrough]];
                                    case wasm1_code::f32_mul: [[fallthrough]];
                                    case wasm1_code::f32_div: [[fallthrough]];
                                    case wasm1_code::f32_min: [[fallthrough]];
                                    case wasm1_code::f32_max: [[fallthrough]];
                                    case wasm1_code::f32_lt:
                                    {
                                        return true;
                                    }
                                    [[unlikely]] default:
                                    {
                                        return false;
                                    }
                                }
                            }
                            if(conbine_pending.vt == curr_operand_stack_value_type::f64)
                            {
                                switch(op)
                                {
                                    case wasm1_code::f64_add: [[fallthrough]];
                                    case wasm1_code::f64_sub: [[fallthrough]];
                                    case wasm1_code::f64_mul: [[fallthrough]];
                                    case wasm1_code::f64_div: [[fallthrough]];
                                    case wasm1_code::f64_min: [[fallthrough]];
                                    case wasm1_code::f64_max:
                                    {
                                        return true;
                                    }
                                    [[unlikely]] default:
                                    {
                                        return false;
                                    }
                                }
                            }
                            if(op == wasm1_code::local_get) { return true; }
# endif
                            return false;
                        }
                        case conbine_pending_kind::local_get2_const_i32:
                        {
                            return op == wasm1_code::i32_mul || op == wasm1_code::i32_shl
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                   || op == wasm1_code::i32_rotl
# endif
                                ;
                        }
                        case conbine_pending_kind::local_get2_const_i32_mul: [[fallthrough]];
                        case conbine_pending_kind::local_get2_const_i32_shl:
                        {
                            return op == wasm1_code::i32_add;
                        }
                        case conbine_pending_kind::i32_add_2localget_local_set:
                        {
                            return op == wasm1_code::local_set;
                        }
                        case conbine_pending_kind::i32_add_2localget_local_tee:
                        {
                            return op == wasm1_code::local_tee;
                        }
                        case conbine_pending_kind::i32_add_imm_local_settee_same:
                        {
                            return op == wasm1_code::local_set || op == wasm1_code::local_tee;
                        }
                        case conbine_pending_kind::local_get_eqz_i32: [[fallthrough]];
                        case conbine_pending_kind::local_get_const_i32_cmp_brif:
                        {
                            return op == wasm1_code::br_if;
                        }
                        case conbine_pending_kind::local_get_const_i32:
                        {
                            switch(op)
                            {
                                case wasm1_code::i32_add: [[fallthrough]];
                                case wasm1_code::i32_sub: [[fallthrough]];
                                case wasm1_code::i32_mul: [[fallthrough]];
                                case wasm1_code::i32_and: [[fallthrough]];
                                case wasm1_code::i32_or: [[fallthrough]];
                                case wasm1_code::i32_xor: [[fallthrough]];
                                case wasm1_code::i32_shl: [[fallthrough]];
                                case wasm1_code::i32_shr_s: [[fallthrough]];
                                case wasm1_code::i32_shr_u: [[fallthrough]];
                                case wasm1_code::i32_eq: [[fallthrough]];
                                case wasm1_code::i32_ne: [[fallthrough]];
                                case wasm1_code::i32_lt_s: [[fallthrough]];
                                case wasm1_code::i32_lt_u: [[fallthrough]];
                                case wasm1_code::i32_ge_s: [[fallthrough]];
                                case wasm1_code::i32_ge_u: [[fallthrough]];
                                case wasm1_code::i32_store: [[fallthrough]];
                                case wasm1_code::i32_store8: [[fallthrough]];
                                case wasm1_code::i32_store16:
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                case wasm1_code::i32_rotl: [[fallthrough]];
                                case wasm1_code::i32_rotr:
# endif
                                    return true;
                                [[unlikely]] default:
                                    return false;
                            }
                        }
                        case conbine_pending_kind::local_get_const_i32_add:
                        {
                            switch(op)
                            {
                                case wasm1_code::local_get: [[fallthrough]];
                                case wasm1_code::i32_load:
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                case wasm1_code::f32_load: [[fallthrough]];
                                case wasm1_code::f64_load:
# endif
                                    return true;
                                [[unlikely]] default:
                                    return false;
                            }
                        }
                        case conbine_pending_kind::local_get_const_i32_add_localget:
                        {
                            if(conbine_pending.vt == curr_operand_stack_value_type::i32) { return op == wasm1_code::i32_store; }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32) { return op == wasm1_code::f32_store; }
                            if(conbine_pending.vt == curr_operand_stack_value_type::f64) { return op == wasm1_code::f64_store; }
# endif
                            return false;
                        }
                        case conbine_pending_kind::local_get_const_i64:
                        {
                            return op == wasm1_code::i64_add || op == wasm1_code::i64_and;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        case conbine_pending_kind::local_get_const_f32: [[fallthrough]];
                        case conbine_pending_kind::local_get_const_f64:
                        {
                            if(conbine_pending.kind == conbine_pending_kind::local_get_const_f32)
                            {
                                return op == wasm1_code::f32_add || op == wasm1_code::f32_mul || op == wasm1_code::f32_min || op == wasm1_code::f32_max;
                            }
                            return op == wasm1_code::f64_add || op == wasm1_code::f64_mul || op == wasm1_code::f64_min || op == wasm1_code::f64_max;
                        }
                        case conbine_pending_kind::const_f32:
                        {
                            switch(op)
                            {
                                case wasm1_code::local_get: [[fallthrough]];
                                case wasm1_code::f32_add: [[fallthrough]];
                                case wasm1_code::f32_sub: [[fallthrough]];
                                case wasm1_code::f32_mul: [[fallthrough]];
                                case wasm1_code::f32_div: [[fallthrough]];
                                case wasm1_code::f32_min: [[fallthrough]];
                                case wasm1_code::f32_max: [[fallthrough]];
                                case wasm1_code::f32_copysign:
                                {
                                    return true;
                                }
                                [[unlikely]] default:
                                {
                                    return false;
                                }
                            }
                        }
                        case conbine_pending_kind::const_f64:
                        {
                            switch(op)
                            {
                                case wasm1_code::local_get: [[fallthrough]];
                                case wasm1_code::f64_add: [[fallthrough]];
                                case wasm1_code::f64_sub: [[fallthrough]];
                                case wasm1_code::f64_mul: [[fallthrough]];
                                case wasm1_code::f64_div: [[fallthrough]];
                                case wasm1_code::f64_min: [[fallthrough]];
                                case wasm1_code::f64_max: [[fallthrough]];
                                case wasm1_code::f64_copysign:
                                {
                                    return true;
                                }
                                [[unlikely]] default:
                                {
                                    return false;
                                }
                            }
                        }
                        case conbine_pending_kind::const_f32_localget:
                        {
                            return op == wasm1_code::f32_div || op == wasm1_code::f32_sub;
                        }
                        case conbine_pending_kind::f32_div_from_imm_localtee_wait:
                        {
                            return op == wasm1_code::local_tee;
                        }
                        case conbine_pending_kind::float_mul_2localget:
                        {
                            return op == wasm1_code::local_get;
                        }
                        case conbine_pending_kind::float_mul_2localget_local3:
                        {
                            if(op == wasm1_code::local_get) { return true; }
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32) { return op == wasm1_code::f32_add || op == wasm1_code::f32_sub; }
                            return op == wasm1_code::f64_add || op == wasm1_code::f64_sub;
                        }
                        case conbine_pending_kind::float_2mul_wait_second_mul:
                        {
                            return conbine_pending.vt == curr_operand_stack_value_type::f32 ? op == wasm1_code::f32_mul : op == wasm1_code::f64_mul;
                        }
                        case conbine_pending_kind::float_2mul_after_second_mul:
                        {
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32) { return op == wasm1_code::f32_add || op == wasm1_code::f32_sub; }
                            return op == wasm1_code::f64_add || op == wasm1_code::f64_sub;
                        }
                        case conbine_pending_kind::select_localget3:
                        {
                            return op == wasm1_code::select;
                        }
                        case conbine_pending_kind::select_after_select:
                        {
                            // Heavy select fusions:
                            // - `i32` supports local.set only (no local.tee fused op in conbine_heavy).
                            // - `f32` supports both local.set and local.tee.
                            return op == wasm1_code::local_set || (op == wasm1_code::local_tee && conbine_pending.vt == curr_operand_stack_value_type::f32);
                        }
                        case conbine_pending_kind::mac_localget3:
                        {
                            if(conbine_pending.vt == curr_operand_stack_value_type::i32) { return op == wasm1_code::i32_mul; }
                            if(conbine_pending.vt == curr_operand_stack_value_type::i64) { return op == wasm1_code::i64_mul; }
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32) { return op == wasm1_code::f32_mul; }
                            return op == wasm1_code::f64_mul;
                        }
                        case conbine_pending_kind::mac_after_mul:
                        {
                            if(conbine_pending.vt == curr_operand_stack_value_type::i32) { return op == wasm1_code::i32_add; }
                            if(conbine_pending.vt == curr_operand_stack_value_type::i64) { return op == wasm1_code::i64_add; }
                            if(conbine_pending.vt == curr_operand_stack_value_type::f32) { return op == wasm1_code::f32_add; }
                            return op == wasm1_code::f64_add;
                        }
                        case conbine_pending_kind::mac_after_add:
                        {
                            // Heavy MAC fusions:
                            // - `f32` supports local.set and local.tee.
                            // - {i32,i64,f64} support local.set only.
                            return op == wasm1_code::local_set || (op == wasm1_code::local_tee && conbine_pending.vt == curr_operand_stack_value_type::f32);
                        }
                        case conbine_pending_kind::f32_add_2localget_local_set:
                        {
                            return op == wasm1_code::local_set;
                        }
                        case conbine_pending_kind::f32_add_2localget_local_tee:
                        {
                            return op == wasm1_code::local_tee;
                        }
                        case conbine_pending_kind::f64_add_2localget_local_set:
                        {
                            return op == wasm1_code::local_set;
                        }
                        case conbine_pending_kind::f64_add_2localget_local_tee:
                        {
                            return op == wasm1_code::local_tee;
                        }
                        case conbine_pending_kind::i32_rem_u_2localget_wait_eqz:
                        {
                            return op == wasm1_code::i32_eqz;
                        }
                        case conbine_pending_kind::i32_rem_u_eqz_2localget_wait_brif:
                        {
                            return op == wasm1_code::br_if;
                        }
#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                        case conbine_pending_kind::for_i32_inc_after_tee:
                        {
                            return op == wasm1_code::i32_const;
                        }
                        case conbine_pending_kind::for_i32_inc_after_end_const:
                        {
                            return op == wasm1_code::i32_lt_u;
                        }
                        case conbine_pending_kind::for_i32_inc_after_cmp:
                        {
                            return op == wasm1_code::br_if;
                        }
                        case conbine_pending_kind::for_ptr_inc_after_tee:
                        {
                            return op == wasm1_code::local_get;
                        }
                        case conbine_pending_kind::for_ptr_inc_after_pend_get:
                        {
                            return op == wasm1_code::i32_ne;
                        }
                        case conbine_pending_kind::for_ptr_inc_after_cmp:
                        {
                            return op == wasm1_code::br_if;
                        }
#  endif
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_gets:
                        {
                            return op == wasm1_code::i32_const;
                        }
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_step_const:
                        {
                            return op == wasm1_code::i32_add;
                        }
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_add:
                        {
                            return op == wasm1_code::local_tee;
                        }
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_tee:
                        {
                            return op == wasm1_code::f64_convert_i32_u;
                        }
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_convert:
                        {
                            return op == wasm1_code::f64_lt;
                        }
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_cmp:
                        {
                            return op == wasm1_code::i32_eqz;
                        }
                        case conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_eqz:
                        {
                            return op == wasm1_code::br_if;
                        }
                        case conbine_pending_kind::xorshift_pre_shr:
                        {
                            return op == wasm1_code::i32_shr_u;
                        }
                        case conbine_pending_kind::xorshift_after_shr:
                        {
                            return op == wasm1_code::i32_xor;
                        }
                        case conbine_pending_kind::xorshift_after_xor1:
                        {
                            return op == wasm1_code::local_get;
                        }
                        case conbine_pending_kind::xorshift_after_xor1_getx:
                        {
                            return op == wasm1_code::i32_const;
                        }
                        case conbine_pending_kind::xorshift_after_xor1_getx_constb:
                        {
                            return op == wasm1_code::i32_shl;
                        }
                        case conbine_pending_kind::xorshift_after_shl:
                        {
                            return op == wasm1_code::i32_xor;
                        }
                        case conbine_pending_kind::rot_xor_add_after_rotl:
                        {
                            return op == wasm1_code::local_get;
                        }
                        case conbine_pending_kind::rot_xor_add_after_gety:
                        {
                            return op == wasm1_code::i32_xor;
                        }
                        case conbine_pending_kind::rot_xor_add_after_xor:
                        {
                            return op == wasm1_code::i32_const;
                        }
                        case conbine_pending_kind::rot_xor_add_after_xor_constc:
                        {
                            return op == wasm1_code::i32_add;
                        }
                        case conbine_pending_kind::rotl_xor_local_set_after_rotl:
                        {
                            return op == wasm1_code::i32_xor;
                        }
                        case conbine_pending_kind::rotl_xor_local_set_after_xor:
                        {
                            return op == wasm1_code::local_set || op == wasm1_code::local_tee;
                        }
                        case conbine_pending_kind::u16_copy_scaled_index_after_shl:
                        {
                            return op == wasm1_code::i32_load16_u;
                        }
                        case conbine_pending_kind::u16_copy_scaled_index_after_load:
                        {
                            return op == wasm1_code::i32_store16;
                        }
# endif
                        [[unlikely]] default:
                        {
                            return false;
                        }
                    }
                }};
#endif

            auto const runtime_log_wasm_op_state{[&]([[maybe_unused]] ::uwvm2::utils::container::u8string_view phase,
                                                     [[maybe_unused]] wasm1_code op,
                                                     [[maybe_unused]] ::std::byte const* wasm_ip,
                                                     [[maybe_unused]] ::std::size_t bytecode_before,
                                                     [[maybe_unused]] ::std::size_t thunks_before,
                                                     [[maybe_unused]] ::std::uint_least64_t opfunc_main_before,
                                                     [[maybe_unused]] ::std::uint_least64_t opfunc_thunk_before) constexpr noexcept
                                                 {
                                                     if(!runtime_log_on) [[likely]] { return; }

                                                     auto const bc_delta{bytecode.size() - bytecode_before};
                                                     auto const thunk_delta{thunks.size() - thunks_before};
                                                     auto const opfunc_main_delta{runtime_log_stats.opfunc_main_count - opfunc_main_before};
                                                     auto const opfunc_thunk_delta{runtime_log_stats.opfunc_thunk_count - opfunc_thunk_before};
                                                     using op_underlying_t = ::std::underlying_type_t<wasm1_code>;
                                                     auto const op_u{static_cast<::std::uint_least32_t>(static_cast<op_underlying_t>(op))};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                                                     if(conbine_pending.kind == conbine_pending_kind::none)
                                                     {
                                                         ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                              u8"[uwvm-int-translator] fn=",
                                                                              function_index,
                                                                              u8" ip=",
                                                                              static_cast<::std::size_t>(wasm_ip - code_begin),
                                                                              u8" event=",
                                                                              phase,
                                                                              u8" | op=",
                                                                              runtime_log_op_name(op),
                                                                              u8" op_u=",
                                                                              ::fast_io::mnp::hex0x(op_u),
                                                                              u8" bytecode{main=",
                                                                              bytecode.size(),
                                                                              u8"(+",
                                                                              bc_delta,
                                                                              u8"),thunk=",
                                                                              thunks.size(),
                                                                              u8"(+",
                                                                              thunk_delta,
                                                                              u8")} opfunc{main=+",
                                                                              opfunc_main_delta,
                                                                              u8",thunk=+",
                                                                              opfunc_thunk_delta,
                                                                              u8"}",
                                                                              u8" operand{sz=",
                                                                              operand_stack.size(),
                                                                              u8",bytes=",
                                                                              operand_stack_bytes,
                                                                              u8"} polymorphic=",
                                                                              is_polymorphic,
                                                                              u8" conbine{none}",
                                                                              u8" stacktop{mem=",
                                                                              stacktop_memory_count,
                                                                              u8",cache=",
                                                                              stacktop_cache_count,
                                                                              u8",i32=",
                                                                              stacktop_cache_i32_count,
                                                                              u8",i64=",
                                                                              stacktop_cache_i64_count,
                                                                              u8",f32=",
                                                                              stacktop_cache_f32_count,
                                                                              u8",f64=",
                                                                              stacktop_cache_f64_count,
                                                                              u8"} currpos{i32=",
                                                                              curr_stacktop.i32_stack_top_curr_pos,
                                                                              u8",i64=",
                                                                              curr_stacktop.i64_stack_top_curr_pos,
                                                                              u8",f32=",
                                                                              curr_stacktop.f32_stack_top_curr_pos,
                                                                              u8",f64=",
                                                                              curr_stacktop.f64_stack_top_curr_pos,
                                                                              u8",v128=",
                                                                              curr_stacktop.v128_stack_top_curr_pos,
                                                                              u8"}\n");
                                                     }
                                                     else
                                                     {
                                                         ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                              u8"[uwvm-int-translator] fn=",
                                                                              function_index,
                                                                              u8" ip=",
                                                                              static_cast<::std::size_t>(wasm_ip - code_begin),
                                                                              u8" event=",
                                                                              phase,
                                                                              u8" | op=",
                                                                              runtime_log_op_name(op),
                                                                              u8" op_u=",
                                                                              ::fast_io::mnp::hex0x(op_u),
                                                                              u8" bytecode{main=",
                                                                              bytecode.size(),
                                                                              u8"(+",
                                                                              bc_delta,
                                                                              u8"),thunk=",
                                                                              thunks.size(),
                                                                              u8"(+",
                                                                              thunk_delta,
                                                                              u8")} opfunc{main=+",
                                                                              opfunc_main_delta,
                                                                              u8",thunk=+",
                                                                              opfunc_thunk_delta,
                                                                              u8"}",
                                                                              u8" operand{sz=",
                                                                              operand_stack.size(),
                                                                              u8",bytes=",
                                                                              operand_stack_bytes,
                                                                              u8"} polymorphic=",
                                                                              is_polymorphic,
                                                                              u8" conbine{kind=",
                                                                              runtime_log_conbine_kind_name(conbine_pending.kind),
                                                                              u8",brif=",
                                                                              runtime_log_conbine_brif_cmp_name(conbine_pending.brif_cmp),
                                                                              u8",vt=",
                                                                              runtime_log_vt_name(conbine_pending.vt),
                                                                              u8",off{",
                                                                              conbine_pending.off1,
                                                                              u8",",
                                                                              conbine_pending.off2,
                                                                              u8",",
                                                                              conbine_pending.off3,
                                                                              u8",",
                                                                              conbine_pending.off4,
                                                                              u8"} imm{i32=",
                                                                              conbine_pending.imm_i32,
                                                                              u8",i32_2=",
                                                                              conbine_pending.imm_i32_2,
                                                                              u8",u32=",
                                                                              conbine_pending.imm_u32,
                                                                              u8",u32_2=",
                                                                              conbine_pending.imm_u32_2,
                                                                              u8",i64=",
                                                                              conbine_pending.imm_i64,
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                                                              u8",f32=",
                                                                              conbine_pending.imm_f32,
                                                                              u8",f64=",
                                                                              conbine_pending.imm_f64,
# endif
                                                                              u8"}}",
                                                                              u8" stacktop{mem=",
                                                                              stacktop_memory_count,
                                                                              u8",cache=",
                                                                              stacktop_cache_count,
                                                                              u8",i32=",
                                                                              stacktop_cache_i32_count,
                                                                              u8",i64=",
                                                                              stacktop_cache_i64_count,
                                                                              u8",f32=",
                                                                              stacktop_cache_f32_count,
                                                                              u8",f64=",
                                                                              stacktop_cache_f64_count,
                                                                              u8"} currpos{i32=",
                                                                              curr_stacktop.i32_stack_top_curr_pos,
                                                                              u8",i64=",
                                                                              curr_stacktop.i64_stack_top_curr_pos,
                                                                              u8",f32=",
                                                                              curr_stacktop.f32_stack_top_curr_pos,
                                                                              u8",f64=",
                                                                              curr_stacktop.f64_stack_top_curr_pos,
                                                                              u8",v128=",
                                                                              curr_stacktop.v128_stack_top_curr_pos,
                                                                              u8"}\n");
                                                     }

#else
                                                     ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                          u8"[uwvm-int-translator] fn=",
                                                                          function_index,
                                                                          u8" ip=",
                                                                          static_cast<::std::size_t>(wasm_ip - code_begin),
                                                                          u8" event=",
                                                                          phase,
                                                                          u8" | op=",
                                                                          runtime_log_op_name(op),
                                                                          u8" op_u=",
                                                                          ::fast_io::mnp::hex0x(op_u),
                                                                          u8" bytecode{main=",
                                                                          bytecode.size(),
                                                                          u8"(+",
                                                                          bc_delta,
                                                                          u8"),thunk=",
                                                                          thunks.size(),
                                                                          u8"(+",
                                                                          thunk_delta,
                                                                          u8")} opfunc{main=+",
                                                                          opfunc_main_delta,
                                                                          u8",thunk=+",
                                                                          opfunc_thunk_delta,
                                                                          u8"}",
                                                                          u8" operand{sz=",
                                                                          operand_stack.size(),
                                                                          u8",bytes=",
                                                                          operand_stack_bytes,
                                                                          u8"} polymorphic=",
                                                                          is_polymorphic,
                                                                          u8" conbine{none}",
                                                                          u8" stacktop{mem=",
                                                                          stacktop_memory_count,
                                                                          u8",cache=",
                                                                          stacktop_cache_count,
                                                                          u8",i32=",
                                                                          stacktop_cache_i32_count,
                                                                          u8",i64=",
                                                                          stacktop_cache_i64_count,
                                                                          u8",f32=",
                                                                          stacktop_cache_f32_count,
                                                                          u8",f64=",
                                                                          stacktop_cache_f64_count,
                                                                          u8"} currpos{i32=",
                                                                          curr_stacktop.i32_stack_top_curr_pos,
                                                                          u8",i64=",
                                                                          curr_stacktop.i64_stack_top_curr_pos,
                                                                          u8",f32=",
                                                                          curr_stacktop.f32_stack_top_curr_pos,
                                                                          u8",f64=",
                                                                          curr_stacktop.f64_stack_top_curr_pos,
                                                                          u8",v128=",
                                                                          curr_stacktop.v128_stack_top_curr_pos,
                                                                          u8"}\n");
#endif
                                                 }};

            bool finished_current_func{};

            for(;;)
            {
                if(code_curr == code_end) [[unlikely]]
                {
                    // [... ] | (end)
                    // [safe] | unsafe (could be the section_end)
                    //          ^^ code_curr

                    // Validation completes when the end is reached, so this condition can never be met. If it were met, it would indicate a missing end.

                    err.err_curr = code_curr;
                    err.err_code = code_validation_error_code::missing_end;
                    ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                }

                // opbase ...
                // [safe] unsafe (could be the section_end)
                // ^^ code_curr

                auto const op_begin{code_curr};

                wasm1_code curr_opbase;  // no initialize necessary
                ::std::memcpy(::std::addressof(curr_opbase), code_curr, sizeof(wasm1_code));
                if(runtime_log_on) [[unlikely]]
                {
                    runtime_log_curr_ip = static_cast<::std::size_t>(op_begin - code_begin);
                    ++runtime_log_stats.wasm_op_count;
                }

#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                stacktop_dbg_last_op = curr_opbase;
                stacktop_dbg_last_ip = static_cast<::std::size_t>(op_begin - code_begin);
#endif

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                // Combine state: only fuse if the next opcode is immediately `br_if`.
                if(br_if_fuse.kind != br_if_fuse_kind::none && curr_opbase != wasm1_code::br_if) [[unlikely]]
                {
                    br_if_fuse.kind = br_if_fuse_kind::none;
                    br_if_fuse.site = SIZE_MAX;
                    br_if_fuse.end = SIZE_MAX;
                    br_if_fuse.stacktop_currpos_at_site = {};
                }

                // Conbine state machine: flush pending ops unless the current opcode can continue the fusion.
                if(conbine_pending.kind != conbine_pending_kind::none && !conbine_can_continue(curr_opbase)) [[unlikely]] { flush_conbine_pending(); }
#endif

                ::std::size_t bytecode_before{};
                ::std::size_t thunks_before{};
                ::std::uint_least64_t opfunc_main_before{};
                ::std::uint_least64_t opfunc_thunk_before{};

                if(runtime_log_on) [[unlikely]]
                {
                    bytecode_before = bytecode.size();
                    thunks_before = thunks.size();
                    opfunc_main_before = runtime_log_stats.opfunc_main_count;
                    opfunc_thunk_before = runtime_log_stats.opfunc_thunk_count;
                    runtime_log_wasm_op_state(u8"wasm.op.before",
                                              curr_opbase,
                                              op_begin,
                                              bytecode_before,
                                              thunks_before,
                                              opfunc_main_before,
                                              opfunc_thunk_before);
                }

                switch(curr_opbase)
                {
                    case wasm1_code::unreachable:
                    {
                        // unreachable ...
                        // [   safe  ] unsafe (could be the section_end)
                        // ^^ code_curr

                        ++code_curr;

                        // unreachable ...
                        // [   safe  ] unsafe (could be the section_end)
                        //             ^^ code_curr

                        emit_opfunc_to(bytecode,
                                       ::uwvm2::runtime::compiler::uwvm_int::optable::translate::get_uwvmint_unreachable_fptr_from_tuple<CompileOption>(
                                           curr_stacktop,
                                           interpreter_tuple));

                        if(!control_flow_stack.empty())
                        {
                            auto const base{control_flow_stack.back_unchecked().operand_stack_base};
                            operand_stack_truncate_to(base);
                        }

                        is_polymorphic = true;

                        break;
                    }
                    case wasm1_code::nop:
                    {
                        // nop    ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        ++code_curr;

                        // nop    ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        break;
                    }
                    case wasm1_code::block:
                    {
                        // block  blocktype ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // block  blocktype ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // block  blocktype ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ op_begin

                        if(code_curr == code_end) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::missing_block_type;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::end_of_file);
                        }

                        // block blocktype ...
                        // [     safe    ] unsafe (could be the section_end)
                        //       ^^ op_begin

                        wasm_byte blocktype_byte;
                        ::std::memcpy(::std::addressof(blocktype_byte), code_curr, sizeof(blocktype_byte));

                        ++code_curr;

                        // block blocktype ...
                        // [     safe    ] unsafe (could be the section_end)
                        //                 ^^ op_begin

                        block_result_type block_result{};
                        switch(blocktype_byte)
                        {
                            case 0x40u:
                            {
                                block_result = {};
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::i32):
                            {
                                block_result.begin = i32_result_arr;
                                block_result.end = i32_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::i64):
                            {
                                block_result.begin = i64_result_arr;
                                block_result.end = i64_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::f32):
                            {
                                block_result.begin = f32_result_arr;
                                block_result.end = f32_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::f64):
                            {
                                block_result.begin = f64_result_arr;
                                block_result.end = f64_result_arr + 1u;
                                break;
                            }
                            [[unlikely]] default:
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.u8 = blocktype_byte;
                                err.err_code = code_validation_error_code::illegal_block_type;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        control_flow_stack.push_back({.result = block_result,
                                                      .operand_stack_base = operand_stack.size(),
                                                      .type = block_type::block,
                                                      .polymorphic_base = is_polymorphic,
                                                      .then_polymorphic_end = false,
                                                      .start_label_id = SIZE_MAX,
                                                      .end_label_id = new_label(false),
                                                      .else_label_id = SIZE_MAX});

                        break;
                    }
                    case wasm1_code::loop:
                    {
                        // loop   blocktype ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // loop   blocktype ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // loop   blocktype ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        if(code_curr == code_end) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::missing_block_type;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::end_of_file);
                        }

                        // loop blocktype ...
                        // [    safe    ] unsafe (could be the section_end)
                        //      ^^ code_curr

                        wasm_byte blocktype_byte;
                        ::std::memcpy(::std::addressof(blocktype_byte), code_curr, sizeof(blocktype_byte));

                        ++code_curr;

                        // loop blocktype ...
                        // [    safe    ] unsafe (could be the section_end)
                        //                ^^ code_curr

                        block_result_type block_result{};
                        switch(blocktype_byte)
                        {
                            case 0x40u:
                            {
                                block_result = {};
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::i32):
                            {
                                block_result.begin = i32_result_arr;
                                block_result.end = i32_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::i64):
                            {
                                block_result.begin = i64_result_arr;
                                block_result.end = i64_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::f32):
                            {
                                block_result.begin = f32_result_arr;
                                block_result.end = f32_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::f64):
                            {
                                block_result.begin = f64_result_arr;
                                block_result.end = f64_result_arr + 1u;
                                break;
                            }
                            [[unlikely]] default:
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.u8 = blocktype_byte;
                                err.err_code = code_validation_error_code::illegal_block_type;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        control_flow_stack.push_back(
                            {.result = block_result,
                             .operand_stack_base = operand_stack.size(),
                             .type = block_type::loop,
                             .polymorphic_base = is_polymorphic,
                             .then_polymorphic_end = false,
                             .start_label_id =
                                 [&]() constexpr UWVM_THROWS
                             {
                                 auto const loop_start{new_label(false)};
                                 if constexpr(stacktop_enabled)
                                 {
                                     if constexpr(strict_cf_entry_like_call)
                                     {
                                         if(!is_polymorphic)
                                         {
                                             // Fallthrough into loop start: canonicalize before the re-entry label so
                                             // back-edges can jump directly to the label and see the canonical state.
                                             if(runtime_log_on) [[unlikely]]
                                             {
                                                 ++runtime_log_stats.cf_loop_entry_canonicalize_to_mem_count;
                                                 if(runtime_log_emit_cf)
                                                 {
                                                     ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                          u8"[uwvm-int-translator] fn=",
                                                                          function_index,
                                                                          u8" ip=",
                                                                          runtime_log_curr_ip,
                                                                          u8" event=cf.loop_entry | action=canonicalize_edge_to_memory\n");
                                                 }
                                             }
                                             stacktop_canonicalize_edge_to_memory(bytecode);
                                         }
                                         else
                                         {
                                             // Unreachable fallthrough: no runtime code needed, but keep model deterministic.
                                             stacktop_reset_currpos_to_begin();
                                             stacktop_memory_count = codegen_operand_stack.size();
                                             stacktop_cache_count = 0uz;
                                             stacktop_cache_i32_count = 0uz;
                                             stacktop_cache_i64_count = 0uz;
                                             stacktop_cache_f32_count = 0uz;
                                             stacktop_cache_f64_count = 0uz;
                                         }
                                     }
                                 }
                                 if constexpr(stacktop_enabled)
                                 {
                                     if constexpr(!strict_cf_entry_like_call)
                                     {
                                         // Fallthrough into loop start: canonicalize currpos to a deterministic begin slot
                                         // using a pure-register transform (no operand-stack spill/fill).
                                         if(runtime_log_on) [[unlikely]]
                                         {
                                             ++runtime_log_stats.cf_loop_entry_transform_count;
                                             if(runtime_log_emit_cf)
                                             {
                                                 ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                      u8"[uwvm-int-translator] fn=",
                                                                      function_index,
                                                                      u8" ip=",
                                                                      runtime_log_curr_ip,
                                                                      u8" event=cf.loop_entry | action=stacktop_transform_currpos_to_begin\n");
                                             }
                                         }
                                         stacktop_transform_currpos_to_begin(bytecode);
                                     }
                                 }
                                 set_label_offset(loop_start, bytecode.size());
                                 return loop_start;
                             }(),
                             .end_label_id = new_label(false),
                             .else_label_id = SIZE_MAX,
                             .wasm_code_curr_at_start_label = code_curr});

                        break;
                    }
                    case wasm1_code::if_:
                    {
                        // if     blocktype ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // if     blocktype ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // if     blocktype ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        if(code_curr == code_end) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::missing_block_type;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::end_of_file);
                        }

                        // if blocktype ...
                        // [   safe   ] unsafe (could be the section_end)
                        //    ^^ code_curr

                        wasm_byte blocktype_byte;
                        ::std::memcpy(::std::addressof(blocktype_byte), code_curr, sizeof(blocktype_byte));

                        ++code_curr;

                        // if blocktype ...
                        // [   safe   ] unsafe (could be the section_end)
                        //              ^^ code_curr

                        block_result_type block_result{};
                        switch(blocktype_byte)
                        {
                            case 0x40u:
                            {
                                block_result = {};
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::i32):
                            {
                                block_result.begin = i32_result_arr;
                                block_result.end = i32_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::i64):
                            {
                                block_result.begin = i64_result_arr;
                                block_result.end = i64_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::f32):
                            {
                                block_result.begin = f32_result_arr;
                                block_result.end = f32_result_arr + 1u;
                                break;
                            }
                            case static_cast<wasm_byte>(wasm_value_type_u::f64):
                            {
                                block_result.begin = f64_result_arr;
                                block_result.end = f64_result_arr + 1u;
                                break;
                            }
                            [[unlikely]] default:
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.u8 = blocktype_byte;
                                err.err_code = code_validation_error_code::illegal_block_type;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        if(!is_polymorphic && operand_stack.empty()) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = u8"if";
                            err.err_selectable.operand_stack_underflow.stack_size_actual = 0uz;
                            err.err_selectable.operand_stack_underflow.stack_size_required = 1uz;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(!operand_stack.empty())
                        {
                            auto const cond{operand_stack.back_unchecked()};
                            operand_stack_pop_unchecked();
                            if(cond.type != curr_operand_stack_value_type::i32) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.if_cond_type_not_i32.cond_type = cond.type;
                                err.err_code = code_validation_error_code::if_cond_type_not_i32;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        auto const else_dest_label_id{new_label(false)};
                        auto const end_label_id{new_label(false)};

                        // With stack-top caching enabled, the condition pop requires cache refills (fills are skipped on the taken path),
                        // so we lower the taken path to an always-present thunk:
                        //   if (cond==0) -> else_thunk: [fill-to-canonical] ; br else_dest
                        // This ensures both then/else paths see a canonical cache state at entry.
                        ::std::size_t else_thunk_label_id{SIZE_MAX};
                        ::std::size_t const br_if_target_label_id{[&]() constexpr UWVM_THROWS -> ::std::size_t
                                                                  {
                                                                      if constexpr(stacktop_enabled)
                                                                      {
                                                                          if(!is_polymorphic)
                                                                          {
                                                                              else_thunk_label_id = new_label(true);
                                                                              return else_thunk_label_id;
                                                                          }
                                                                      }
                                                                      return else_dest_label_id;
                                                                  }()};

                        // Lower `if` to `br_if(cond==0)` (jump to else/end on condition == 0).
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        emit_opfunc_to(bytecode,
                                       ::uwvm2::runtime::compiler::uwvm_int::optable::translate::get_uwvmint_br_if_i32_eqz_fptr_from_tuple<CompileOption>(
                                           curr_stacktop,
                                           interpreter_tuple));
#else
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_eqz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_opfunc_to(bytecode, translate::get_uwvmint_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
#endif
                        emit_ptr_label_placeholder(br_if_target_label_id, false);

                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                // `if` consumes the i32 condition (compiler-managed stack-top cursor); then refill to canonical on then-path.
                                stacktop_commit_pop_n(1uz);
                                codegen_stack_pop_n(1uz);

                                // Save post-pop pre-fill state for the else thunk.
                                auto const post_pop_curr_stacktop{curr_stacktop};
                                auto const post_pop_memory_count{stacktop_memory_count};
                                auto const post_pop_cache_count{stacktop_cache_count};
                                auto const post_pop_cache_i32_count{stacktop_cache_i32_count};
                                auto const post_pop_cache_i64_count{stacktop_cache_i64_count};
                                auto const post_pop_cache_f32_count{stacktop_cache_f32_count};
                                auto const post_pop_cache_f64_count{stacktop_cache_f64_count};
                                auto const post_pop_codegen_operand_stack{codegen_operand_stack};

                                // Emit else thunk now (types are still the pre-then stack state).
                                {
                                    auto const saved_curr_stacktop{curr_stacktop};
                                    auto const saved_memory_count{stacktop_memory_count};
                                    auto const saved_cache_count{stacktop_cache_count};
                                    auto const saved_cache_i32_count{stacktop_cache_i32_count};
                                    auto const saved_cache_i64_count{stacktop_cache_i64_count};
                                    auto const saved_cache_f32_count{stacktop_cache_f32_count};
                                    auto const saved_cache_f64_count{stacktop_cache_f64_count};
                                    auto const saved_codegen_operand_stack{codegen_operand_stack};

                                    curr_stacktop = post_pop_curr_stacktop;
                                    stacktop_memory_count = post_pop_memory_count;
                                    stacktop_cache_count = post_pop_cache_count;
                                    stacktop_cache_i32_count = post_pop_cache_i32_count;
                                    stacktop_cache_i64_count = post_pop_cache_i64_count;
                                    stacktop_cache_f32_count = post_pop_cache_f32_count;
                                    stacktop_cache_f64_count = post_pop_cache_f64_count;
                                    codegen_operand_stack = post_pop_codegen_operand_stack;

                                    set_label_offset(else_thunk_label_id, thunks.size());
                                    if constexpr(strict_cf_entry_like_call) { stacktop_canonicalize_edge_to_memory(thunks); }
                                    else
                                    {
                                        stacktop_fill_to_canonical(thunks);
                                    }
                                    emit_br_to(thunks, else_dest_label_id, true);

                                    curr_stacktop = saved_curr_stacktop;
                                    stacktop_memory_count = saved_memory_count;
                                    stacktop_cache_count = saved_cache_count;
                                    stacktop_cache_i32_count = saved_cache_i32_count;
                                    stacktop_cache_i64_count = saved_cache_i64_count;
                                    stacktop_cache_f32_count = saved_cache_f32_count;
                                    stacktop_cache_f64_count = saved_cache_f64_count;
                                    codegen_operand_stack = saved_codegen_operand_stack;
                                }

                                // then-path: execute the fill-to-canonical immediately after the conditional branch.
                                curr_stacktop = post_pop_curr_stacktop;
                                stacktop_memory_count = post_pop_memory_count;
                                stacktop_cache_count = post_pop_cache_count;
                                stacktop_cache_i32_count = post_pop_cache_i32_count;
                                stacktop_cache_i64_count = post_pop_cache_i64_count;
                                stacktop_cache_f32_count = post_pop_cache_f32_count;
                                stacktop_cache_f64_count = post_pop_cache_f64_count;
                                codegen_operand_stack = post_pop_codegen_operand_stack;
                                stacktop_fill_to_canonical(bytecode);
                            }
                        }

                        auto else_entry_curr_stacktop{curr_stacktop};
                        auto else_entry_memory_count{stacktop_memory_count};
                        auto else_entry_cache_count{stacktop_cache_count};
                        auto else_entry_cache_i32_count{stacktop_cache_i32_count};
                        auto else_entry_cache_i64_count{stacktop_cache_i64_count};
                        auto else_entry_cache_f32_count{stacktop_cache_f32_count};
                        auto else_entry_cache_f64_count{stacktop_cache_f64_count};
                        auto else_entry_codegen_operand_stack{codegen_operand_stack};
                        if constexpr(stacktop_enabled)
                        {
                            if constexpr(strict_cf_entry_like_call)
                            {
                                else_entry_curr_stacktop.i32_stack_top_curr_pos = stacktop_i32_enabled ? CompileOption.i32_stack_top_begin_pos : SIZE_MAX;
                                else_entry_curr_stacktop.i64_stack_top_curr_pos = stacktop_i64_enabled ? CompileOption.i64_stack_top_begin_pos : SIZE_MAX;
                                else_entry_curr_stacktop.f32_stack_top_curr_pos = stacktop_f32_enabled ? CompileOption.f32_stack_top_begin_pos : SIZE_MAX;
                                else_entry_curr_stacktop.f64_stack_top_curr_pos = stacktop_f64_enabled ? CompileOption.f64_stack_top_begin_pos : SIZE_MAX;
                                else_entry_curr_stacktop.v128_stack_top_curr_pos = stacktop_v128_enabled ? CompileOption.v128_stack_top_begin_pos : SIZE_MAX;
                                else_entry_memory_count = else_entry_codegen_operand_stack.size();
                                else_entry_cache_count = 0uz;
                                else_entry_cache_i32_count = 0uz;
                                else_entry_cache_i64_count = 0uz;
                                else_entry_cache_f32_count = 0uz;
                                else_entry_cache_f64_count = 0uz;
                            }
                        }

                        control_flow_stack.push_back({.result = block_result,
                                                      .operand_stack_base = operand_stack.size(),
                                                      .type = block_type::if_,
                                                      .polymorphic_base = is_polymorphic,
                                                      .then_polymorphic_end = false,
                                                      .stacktop_currpos_at_else_entry = else_entry_curr_stacktop,
                                                      .stacktop_memory_count_at_else_entry = else_entry_memory_count,
                                                      .stacktop_cache_count_at_else_entry = else_entry_cache_count,
                                                      .stacktop_cache_i32_count_at_else_entry = else_entry_cache_i32_count,
                                                      .stacktop_cache_i64_count_at_else_entry = else_entry_cache_i64_count,
                                                      .stacktop_cache_f32_count_at_else_entry = else_entry_cache_f32_count,
                                                      .stacktop_cache_f64_count_at_else_entry = else_entry_cache_f64_count,
                                                      .codegen_operand_stack_at_else_entry = else_entry_codegen_operand_stack,
                                                      .start_label_id = SIZE_MAX,
                                                      .end_label_id = end_label_id,
                                                      .else_label_id = else_dest_label_id});
                        break;
                    }
                    case wasm1_code::else_:
                    {
                        // else   ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // else   ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // else   ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        if(control_flow_stack.empty() || control_flow_stack.back_unchecked().type != block_type::if_) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::illegal_else;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto& if_frame{control_flow_stack.back_unchecked()};

                        if(!is_polymorphic)
                        {
                            auto const expected_count{static_cast<::std::size_t>(if_frame.result.end - if_frame.result.begin)};
                            auto const actual_count{operand_stack.size() - if_frame.operand_stack_base};

                            bool mismatch{expected_count != actual_count};

                            wasm_value_type_u expected_type{};
                            wasm_value_type_u actual_type{};

                            bool const expected_single{expected_count == 1uz};
                            bool const actual_single{actual_count == 1uz};

                            if(expected_single) { expected_type = static_cast<wasm_value_type_u>(*if_frame.result.begin); }
                            if(actual_single) { actual_type = static_cast<wasm_value_type_u>(operand_stack.back_unchecked().type); }

                            if(!mismatch && expected_single && actual_single && expected_type != actual_type) { mismatch = true; }

                            if(mismatch) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.if_then_result_mismatch.expected_count = expected_count;
                                err.err_selectable.if_then_result_mismatch.actual_count = actual_count;
                                err.err_selectable.if_then_result_mismatch.expected_type = expected_type;
                                err.err_selectable.if_then_result_mismatch.actual_type = actual_type;
                                err.err_code = code_validation_error_code::if_then_result_mismatch;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        if_frame.then_polymorphic_end = is_polymorphic;

                        if constexpr(stacktop_enabled)
                        {
                            if(!if_frame.polymorphic_base)
                            {
                                // If the then-path is reachable, record its stack-top state at the end label.
                                // This is required when the else-path becomes unreachable before `end` (only then reaches `end`).
                                if_frame.stacktop_has_then_end_state = !is_polymorphic;
                                if(!is_polymorphic)
                                {
                                    if_frame.stacktop_currpos_at_then_end = curr_stacktop;
                                    if_frame.stacktop_memory_count_at_then_end = stacktop_memory_count;
                                    if_frame.stacktop_cache_count_at_then_end = stacktop_cache_count;
                                    if_frame.stacktop_cache_i32_count_at_then_end = stacktop_cache_i32_count;
                                    if_frame.stacktop_cache_i64_count_at_then_end = stacktop_cache_i64_count;
                                    if_frame.stacktop_cache_f32_count_at_then_end = stacktop_cache_f32_count;
                                    if_frame.stacktop_cache_f64_count_at_then_end = stacktop_cache_f64_count;
                                    if_frame.codegen_operand_stack_at_then_end = codegen_operand_stack;
                                }
                            }
                        }

                        // Lower `else` marker:
                        // - then-path must skip else body, so we emit an unconditional `br` to the end label here.
                        // - else-label is the start of else body, which is *after* this `br`.
                        if constexpr(stacktop_enabled)
                        {
                            if constexpr(strict_cf_entry_like_call)
                            {
                                if(!is_polymorphic) { stacktop_canonicalize_edge_to_memory(bytecode); }
                            }
                        }
                        emit_br_to(bytecode, if_frame.end_label_id, false);
                        set_label_offset(if_frame.else_label_id, bytecode.size());

                        operand_stack_truncate_to(if_frame.operand_stack_base);
                        is_polymorphic = if_frame.polymorphic_base;
                        if constexpr(stacktop_enabled)
                        {
                            if(!if_frame.polymorphic_base)
                            {
                                // Restore stack-top cache state at `if` entry so else body codegen matches the taken path
                                // (which runs the else thunk fill sequence then branches here).
                                curr_stacktop = if_frame.stacktop_currpos_at_else_entry;
                                stacktop_memory_count = if_frame.stacktop_memory_count_at_else_entry;
                                stacktop_cache_count = if_frame.stacktop_cache_count_at_else_entry;
                                stacktop_cache_i32_count = if_frame.stacktop_cache_i32_count_at_else_entry;
                                stacktop_cache_i64_count = if_frame.stacktop_cache_i64_count_at_else_entry;
                                stacktop_cache_f32_count = if_frame.stacktop_cache_f32_count_at_else_entry;
                                stacktop_cache_f64_count = if_frame.stacktop_cache_f64_count_at_else_entry;
                                sync_type_stacks_from_codegen_snapshot(if_frame.codegen_operand_stack_at_else_entry);
                            }
                        }
                        if_frame.type = block_type::else_;

                        break;
                    }
                    case wasm1_code::end:
                    {
                        // end    ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // end    ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // end    ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        if(control_flow_stack.empty()) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.u8 = static_cast<::std::uint_least8_t>(curr_opbase);
                            err.err_code = code_validation_error_code::illegal_opbase;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const& frame{control_flow_stack.back_unchecked()};
                        bool const is_function_frame{frame.type == block_type::function};

                        ::uwvm2::utils::container::u8string_view block_kind;
                        switch(frame.type)
                        {
                            case block_type::function:
                            {
                                block_kind = u8"function";
                                break;
                            }
                            case block_type::block:
                            {
                                block_kind = u8"block";
                                break;
                            }
                            case block_type::loop:
                            {
                                block_kind = u8"loop";
                                break;
                            }
                            case block_type::if_:
                            {
                                block_kind = u8"if";
                                break;
                            }
                            case block_type::else_:
                            {
                                block_kind = u8"if-else";
                                break;
                            }
                            [[unlikely]] default:
                            {
                                block_kind = u8"block";
                                break;
                            }
                        }

                        auto const expected_count{static_cast<::std::size_t>(frame.result.end - frame.result.begin)};

                        if(frame.type == block_type::if_ && expected_count != 0uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.if_missing_else.expected_count = expected_count;
                            err.err_selectable.if_missing_else.expected_type = static_cast<wasm_value_type_u>(*frame.result.begin);
                            err.err_code = code_validation_error_code::if_missing_else;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const base{frame.operand_stack_base};
                        auto const stack_size{operand_stack.size()};
                        auto const actual_count{stack_size >= base ? stack_size - base : 0uz};

                        if(!is_polymorphic ? (actual_count != expected_count) : (actual_count > expected_count))
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.end_result_mismatch.block_kind = block_kind;
                            err.err_selectable.end_result_mismatch.expected_count = expected_count;
                            err.err_selectable.end_result_mismatch.actual_count = actual_count;

                            if(expected_count == 1uz)
                            {
                                err.err_selectable.end_result_mismatch.expected_type = static_cast<wasm_value_type_u>(*frame.result.begin);
                            }
                            else
                            {
                                err.err_selectable.end_result_mismatch.expected_type = {};
                            }

                            if(actual_count == 1uz && stack_size != 0uz)
                            {
                                err.err_selectable.end_result_mismatch.actual_type = static_cast<wasm_value_type_u>(operand_stack.back_unchecked().type);
                            }
                            else
                            {
                                err.err_selectable.end_result_mismatch.actual_type = {};
                            }

                            err.err_code = code_validation_error_code::end_result_mismatch;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(expected_count != 0uz && actual_count >= expected_count)
                        {
                            for(::std::size_t i{}; i != expected_count; ++i)
                            {
                                auto const expected_type{frame.result.begin[expected_count - 1uz - i]};
                                auto const actual_type{operand_stack.index_unchecked(stack_size - 1uz - i).type};
                                if(actual_type != expected_type) [[unlikely]]
                                {
                                    err.err_curr = op_begin;
                                    err.err_selectable.end_result_mismatch.block_kind = block_kind;
                                    err.err_selectable.end_result_mismatch.expected_count = expected_count;
                                    err.err_selectable.end_result_mismatch.actual_count = actual_count;
                                    err.err_selectable.end_result_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                                    err.err_selectable.end_result_mismatch.actual_type = static_cast<wasm_value_type_u>(actual_type);
                                    err.err_code = code_validation_error_code::end_result_mismatch;
                                    ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                                }
                            }
                        }

                        // Lower `end` marker: materialize branch target labels (no runtime opcode is emitted for `end` itself).
                        //
                        // bytecode[0 ... end_label) | (next opfunc / return)
                        // [           safe         ] | unsafe (could be realloc during later append)
                        //                              ^^ bytecode.size()
                        if constexpr(stacktop_enabled)
                        {
                            if constexpr(strict_cf_entry_like_call)
                            {
                                // Fallthrough into `end`: canonicalize *before* the re-entry label so branches can jump
                                // directly to the label (skipping this sequence) after doing their own canonicalization.
                                if(!is_polymorphic) { stacktop_canonicalize_edge_to_memory(bytecode); }
                                else
                                {
                                    // Unreachable fallthrough: no runtime code needed, but keep model deterministic.
                                    stacktop_reset_currpos_to_begin();
                                    stacktop_memory_count = codegen_operand_stack.size();
                                    stacktop_cache_count = 0uz;
                                    stacktop_cache_i32_count = 0uz;
                                    stacktop_cache_i64_count = 0uz;
                                    stacktop_cache_f32_count = 0uz;
                                    stacktop_cache_f64_count = 0uz;
                                }
                            }
                        }
                        if(frame.end_label_id != SIZE_MAX) { set_label_offset(frame.end_label_id, bytecode.size()); }
                        if(frame.type == block_type::if_)
                        {
                            // `if` without `else` (only valid for empty result) uses the end as the "else" target.
                            if(frame.else_label_id != SIZE_MAX) { set_label_offset(frame.else_label_id, bytecode.size()); }
                        }

                        operand_stack_truncate_to(base);
                        for(::std::size_t i{}; i != expected_count; ++i) { operand_stack_push(frame.result.begin[i]); }

                        bool const polymorphic_end_before_merge{is_polymorphic};
                        bool new_polymorphic_after_end{};
                        if(frame.type == block_type::else_)
                        {
                            new_polymorphic_after_end = frame.polymorphic_base || (frame.then_polymorphic_end && is_polymorphic);
                        }
                        else if(frame.type == block_type::loop)
                        {
                            // Loop end is only reachable via fallthrough; branches target the loop header, not `end`.
                            // If the fallthrough path is unreachable (polymorphic), code after `end` must remain unreachable.
                            new_polymorphic_after_end = frame.polymorphic_base || is_polymorphic;
                        }
                        else
                        {
                            new_polymorphic_after_end = frame.polymorphic_base;
                        }
                        is_polymorphic = new_polymorphic_after_end;

                        if constexpr(stacktop_enabled)
                        {
                            if constexpr(strict_cf_entry_like_call)
                            {
                                // In strict CF-entry mode, all re-entry labels are compiled to expect an empty stack-top cache.
                                // This makes the post-`end` state deterministic regardless of how control reaches it.
                                codegen_operand_stack = operand_stack;
                                stacktop_reset_currpos_to_begin();
                                stacktop_memory_count = codegen_operand_stack.size();
                                stacktop_cache_count = 0uz;
                                stacktop_cache_i32_count = 0uz;
                                stacktop_cache_i64_count = 0uz;
                                stacktop_cache_f32_count = 0uz;
                                stacktop_cache_f64_count = 0uz;
                            }
                            else
                            {
                                // If the current fallthrough path is unreachable at `end`, but the construct is reachable due to
                                // an earlier branch to this `end` label, restore the stack-top model to the reachable path state.
                                if(!new_polymorphic_after_end && polymorphic_end_before_merge)
                                {
                                    if(frame.type == block_type::if_ && !frame.polymorphic_base)
                                    {
                                        // `if` without `else` can be reachable after `end` via the condition-false path,
                                        // even if the then-path became unreachable before `end`.
                                        curr_stacktop = frame.stacktop_currpos_at_else_entry;
                                        stacktop_memory_count = frame.stacktop_memory_count_at_else_entry;
                                        stacktop_cache_count = frame.stacktop_cache_count_at_else_entry;
                                        stacktop_cache_i32_count = frame.stacktop_cache_i32_count_at_else_entry;
                                        stacktop_cache_i64_count = frame.stacktop_cache_i64_count_at_else_entry;
                                        stacktop_cache_f32_count = frame.stacktop_cache_f32_count_at_else_entry;
                                        stacktop_cache_f64_count = frame.stacktop_cache_f64_count_at_else_entry;
                                        sync_type_stacks_from_codegen_snapshot(frame.codegen_operand_stack_at_else_entry);
                                    }
                                    else if(frame.type == block_type::else_ && !frame.then_polymorphic_end && frame.stacktop_has_then_end_state)
                                    {
                                        // `if-else`: else-path is unreachable at `end`, but then-path reaches `end`.
                                        curr_stacktop = frame.stacktop_currpos_at_then_end;
                                        stacktop_memory_count = frame.stacktop_memory_count_at_then_end;
                                        stacktop_cache_count = frame.stacktop_cache_count_at_then_end;
                                        stacktop_cache_i32_count = frame.stacktop_cache_i32_count_at_then_end;
                                        stacktop_cache_i64_count = frame.stacktop_cache_i64_count_at_then_end;
                                        stacktop_cache_f32_count = frame.stacktop_cache_f32_count_at_then_end;
                                        stacktop_cache_f64_count = frame.stacktop_cache_f64_count_at_then_end;
                                        sync_type_stacks_from_codegen_snapshot(frame.codegen_operand_stack_at_then_end);
                                    }
                                    else if(frame.stacktop_has_end_state)
                                    {
                                        // Generic `block`/`loop`/`function` merge: fallthrough is unreachable at `end`,
                                        // but the construct is reachable via a branch to its end label.
                                        curr_stacktop = frame.stacktop_currpos_at_end;
                                        stacktop_memory_count = frame.stacktop_memory_count_at_end;
                                        stacktop_cache_count = frame.stacktop_cache_count_at_end;
                                        stacktop_cache_i32_count = frame.stacktop_cache_i32_count_at_end;
                                        stacktop_cache_i64_count = frame.stacktop_cache_i64_count_at_end;
                                        stacktop_cache_f32_count = frame.stacktop_cache_f32_count_at_end;
                                        stacktop_cache_f64_count = frame.stacktop_cache_f64_count_at_end;
                                        sync_type_stacks_from_codegen_snapshot(frame.codegen_operand_stack_at_end);
                                    }
                                }
                            }
                        }

                        control_flow_stack.pop_back_unchecked();

                        if(is_function_frame)
                        {
                            if(code_curr != code_end) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_code = code_validation_error_code::trailing_code_after_end;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }

                            // Function end: emit `return` at the function end label.
                            emit_return_to(bytecode);

                            // Finalize thunks and patch all `[byte const*]` immediates:
                            // - First pass: fill rel_offset_t placeholders with absolute offsets from bytecode begin.
                            // - Second pass: turn rel_offset_t offsets into real `byte const*` pointers via `bit_cast`.
                            ::std::size_t const main_size{bytecode.size()};

                            if(!thunks.empty())
                            {
                                // Append thunks after main bytecode so previously recorded main offsets remain valid.
                                emit_bytes_to(bytecode, thunks.data(), thunks.size());
                            }

                            // bytecode.data() (stable after append) ...
                            // [             safe            ] | unsafe (no further realloc allowed)
                            // ^^ bytecode_begin_ptr
                            ::std::byte* const bytecode_begin_mut_ptr{bytecode.data()};
                            ::std::byte const* const bytecode_begin_ptr{bytecode_begin_mut_ptr};

                            for(auto const& fx: ptr_fixups)
                            {
                                auto const& lbl{labels.index_unchecked(fx.label_id)};
                                if(lbl.offset == SIZE_MAX) [[unlikely]]
                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                    ::fast_io::fast_terminate();
                                }

                                ::std::size_t const target_abs{lbl.in_thunk ? (main_size + lbl.offset) : lbl.offset};
                                ::std::size_t const site_abs{fx.in_thunk ? (main_size + fx.site) : fx.site};

                                // Patch the `[byte const*]` immediate directly with the absolute pointer bits.
                                ::std::byte const* const target_ptr{bytecode_begin_ptr + target_abs};
                                rel_offset_t const ptr_bits{::std::bit_cast<rel_offset_t>(target_ptr)};
                                ::std::memcpy(bytecode_begin_mut_ptr + site_abs, ::std::addressof(ptr_bits), sizeof(ptr_bits));
                            }

                            if(runtime_log_on) [[unlikely]]
                            {
                                ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                     u8"[uwvm-int-translator] fn=",
                                                     function_index,
                                                     u8" event=stats.func | wasm_ops=",
                                                     runtime_log_stats.wasm_op_count,
                                                     u8" bytecode{main=",
                                                     main_size,
                                                     u8",thunk=",
                                                     thunks.size(),
                                                     u8"} opfunc{main=",
                                                     runtime_log_stats.opfunc_main_count,
                                                     u8",thunk=",
                                                     runtime_log_stats.opfunc_thunk_count,
                                                     u8"} label_imm{main=",
                                                     runtime_log_stats.label_placeholder_main_count,
                                                     u8",thunk=",
                                                     runtime_log_stats.label_placeholder_thunk_count,
                                                     u8"} cf{br=",
                                                     runtime_log_stats.cf_br_count,
                                                     u8",br_tr=",
                                                     runtime_log_stats.cf_br_transform_count,
                                                     u8",br_if=",
                                                     runtime_log_stats.cf_br_if_count,
                                                     u8",loop_tr=",
                                                     runtime_log_stats.cf_loop_entry_transform_count,
                                                     u8",loop_mem=",
                                                     runtime_log_stats.cf_loop_entry_canonicalize_to_mem_count,
                                                     u8"} stacktop{spill1=",
                                                     runtime_log_stats.stacktop_spill1_count,
                                                     u8",spillN=",
                                                     runtime_log_stats.stacktop_spillN_count,
                                                     u8",fill1=",
                                                     runtime_log_stats.stacktop_fill1_count,
                                                     u8",fillN=",
                                                     runtime_log_stats.stacktop_fillN_count,
                                                     u8"}\n");
                            }

                            local_func_symbol.operand_stack_max = runtime_operand_stack_max;
                            local_func_symbol.operand_stack_byte_max = runtime_operand_stack_byte_max;
                            local_func_symbol.local_bytes_zeroinit_end = static_cast<::std::size_t>(
                                local_bytes_zeroinit_end <= internal_temp_local_off ? local_bytes_zeroinit_end : internal_temp_local_off);
                            storage.local_bytes_max = ::std::max(storage.local_bytes_max, local_func_symbol.local_bytes_max);
                            storage.local_count = ::std::max(storage.local_count, local_func_symbol.local_count);
                            storage.local_bytes_zeroinit_end = ::std::max(storage.local_bytes_zeroinit_end, local_func_symbol.local_bytes_zeroinit_end);
                            storage.operand_stack_max = ::std::max(storage.operand_stack_max, runtime_operand_stack_max);
                            storage.operand_stack_byte_max = ::std::max(storage.operand_stack_byte_max, runtime_operand_stack_byte_max);
                            // IMPORTANT: bytecode contains self-referential absolute pointers (patched from rel offsets).
                            // Copying would produce a new buffer with pointers still targeting the old buffer (UAF).
                            storage.local_funcs.push_back(::std::move(local_func_symbol));

                            finished_current_func = true;
                            break;
                        }

                        break;
                    }
                    case wasm1_code::br:
                    {
                        // br     label_index ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // br     label_index ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // br     label_index ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        wasm_u32 label_index;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [label_next, label_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                    reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                    ::fast_io::mnp::leb128_get(label_index))};
                        if(label_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_label_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(label_err);
                        }

                        // br     label_index ...
                        // [     safe       ] unsafe (could be the section_end)
                        //        ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(label_next);

                        // br     label_index ...
                        // [     safe       ] unsafe (could be the section_end)
                        //                    ^^ code_curr

                        auto const all_label_count_uz{control_flow_stack.size()};
                        auto const label_index_uz{static_cast<::std::size_t>(label_index)};
                        if(label_index_uz >= all_label_count_uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_label_index.label_index = label_index;
                            err.err_selectable.illegal_label_index.all_label_count = static_cast<wasm_u32>(all_label_count_uz);
                            err.err_code = code_validation_error_code::illegal_label_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const target_frame_index{all_label_count_uz - 1uz - label_index_uz};
                        auto& target_frame{control_flow_stack.index_unchecked(target_frame_index)};
                        // Label arity = label_types count. IMPORTANT: for `loop`, label types are parameters (MVP: none),
                        // not result types.
                        auto const target_arity{
                            target_frame.type == block_type::loop ? 0uz : static_cast<::std::size_t>(target_frame.result.end - target_frame.result.begin)};

                        if(!is_polymorphic && operand_stack.size() < target_arity) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = u8"br";
                            err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                            err.err_selectable.operand_stack_underflow.stack_size_required = target_arity;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(!is_polymorphic && target_arity != 0uz && operand_stack.size() >= target_arity)
                        {
                            auto const expected_type{*target_frame.result.begin};
                            auto const actual_type{operand_stack.back_unchecked().type};
                            if(actual_type != expected_type) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.br_value_type_mismatch.op_code_name = u8"br";
                                err.err_selectable.br_value_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                                err.err_selectable.br_value_type_mismatch.actual_type = static_cast<wasm_value_type_u>(actual_type);
                                err.err_code = code_validation_error_code::br_value_type_mismatch;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        // Translate: `br` requires stack-shape repair before jumping because the interpreter `br` opcode does not unwind the operand stack.
                        // In polymorphic (unreachable) regions we can skip repair.
                        auto const target_label_id{get_branch_target_label_id(target_frame)};
                        if(!is_polymorphic)
                        {
                            auto const target_base{target_frame.operand_stack_base};
                            auto const curr_size{operand_stack.size()};

                            if(target_arity == 0uz)
                            {
                                bool fused_extra_heavy_loop_run{};
#if defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS)
                                // Extra-heavy: mega-fuse the full `test7`-style i32 sum loop into a single opfunc that keeps
                                // `i/sum` in registers and performs at most one bounds check per slot.
                                if(target_frame.type == block_type::loop && label_index_uz == 0uz && curr_size == target_base &&
                                   target_frame.wasm_code_curr_at_start_label != nullptr)
                                {
                                    bool match_ok{true};
                                    if constexpr(stacktop_enabled) { match_ok = (stacktop_cache_count == 0uz); }

                                    if(match_ok)
                                    {
                                        auto p{target_frame.wasm_code_curr_at_start_label};
                                        auto const endp{op_begin};

                                        auto const consume_op{[&](wasm1_code expected) constexpr noexcept -> bool
                                                              {
                                                                  if(p >= endp) [[unlikely]] { return false; }
                                                                  wasm1_code op;  // no init
                                                                  ::std::memcpy(::std::addressof(op), p, sizeof(op));
                                                                  if(op != expected) { return false; }
                                                                  ++p;
                                                                  return true;
                                                              }};

                                        auto const consume_u32_leb{[&](wasm_u32& v) constexpr noexcept -> bool
                                                                   {
                                                                       using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                                                       auto const [next, err]{
                                                                           ::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(p),
                                                                                                    reinterpret_cast<char8_t_const_may_alias_ptr>(endp),
                                                                                                    ::fast_io::mnp::leb128_get(v))};
                                                                       if(err != ::fast_io::parse_code::ok) [[unlikely]] { return false; }
                                                                       p = reinterpret_cast<::std::byte const*>(next);
                                                                       return true;
                                                                   }};

                                        auto const consume_i32_leb{[&](wasm_i32& v) constexpr noexcept -> bool
                                                                   {
                                                                       using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                                                       auto const [next, err]{
                                                                           ::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(p),
                                                                                                    reinterpret_cast<char8_t_const_may_alias_ptr>(endp),
                                                                                                    ::fast_io::mnp::leb128_get(v))};
                                                                       if(err != ::fast_io::parse_code::ok) [[unlikely]] { return false; }
                                                                       p = reinterpret_cast<::std::byte const*>(next);
                                                                       return true;
                                                                   }};

                                        wasm_u32 sp_local_idx{};      // init
                                        wasm_u32 off_i{};             // init
                                        wasm_u32 off_sum{};           // init
                                        wasm_i32 end_i{};             // init
                                        wasm_i32 one_i{};             // init
                                        wasm_u32 break_lbl_idx{};     // init
                                        wasm_i32 step_i{};            // init
                                        wasm_u32 memarg_align{};      // init
                                        wasm_u32 tmp_local_idx{};     // init
                                        wasm_u32 tmp_memarg_align{};  // init
                                        wasm_u32 tmp_memarg_off{};    // init
                                        wasm_u32 tmp_store_align{};   // init
                                        wasm_u32 tmp_store_off{};     // init

                                        auto const consume_local_get_sp{
                                            [&]() constexpr noexcept -> bool
                                            { return consume_op(wasm1_code::local_get) && consume_u32_leb(tmp_local_idx) && tmp_local_idx == sp_local_idx; }};

                                        // Header: `local.get sp; i32.load off_i; i32.const end; i32.lt_s; i32.const 1; i32.and; i32.eqz; br_if 1`.
                                        match_ok = consume_op(wasm1_code::local_get) && consume_u32_leb(sp_local_idx) && consume_op(wasm1_code::i32_load) &&
                                                   consume_u32_leb(memarg_align) && consume_u32_leb(off_i) && consume_op(wasm1_code::i32_const) &&
                                                   consume_i32_leb(end_i) && consume_op(wasm1_code::i32_lt_s) && consume_op(wasm1_code::i32_const) &&
                                                   consume_i32_leb(one_i) && consume_op(wasm1_code::i32_and) && consume_op(wasm1_code::i32_eqz) &&
                                                   consume_op(wasm1_code::br_if) && consume_u32_leb(break_lbl_idx);
                                        if(match_ok) { match_ok = (one_i == wasm_i32{1} && break_lbl_idx == 1u); }

                                        // Sum update:
                                        // `local.get sp; local.get sp; i32.load off_sum; local.get sp; i32.load off_i; i32.add; i32.store off_sum;`
                                        if(match_ok)
                                        {
                                            match_ok = consume_local_get_sp() && consume_local_get_sp() && consume_op(wasm1_code::i32_load) &&
                                                       consume_u32_leb(tmp_memarg_align) && consume_u32_leb(off_sum) && consume_local_get_sp() &&
                                                       consume_op(wasm1_code::i32_load) && consume_u32_leb(tmp_memarg_align) &&
                                                       consume_u32_leb(tmp_memarg_off) && tmp_memarg_off == off_i && consume_op(wasm1_code::i32_add) &&
                                                       consume_op(wasm1_code::i32_store) && consume_u32_leb(tmp_store_align) &&
                                                       consume_u32_leb(tmp_store_off) && tmp_store_off == off_sum;
                                        }

                                        // i increment:
                                        // `local.get sp; local.get sp; i32.load off_i; i32.const step; i32.add; i32.store off_i;`
                                        if(match_ok)
                                        {
                                            match_ok = consume_local_get_sp() && consume_local_get_sp() && consume_op(wasm1_code::i32_load) &&
                                                       consume_u32_leb(tmp_memarg_align) && consume_u32_leb(tmp_memarg_off) && tmp_memarg_off == off_i &&
                                                       consume_op(wasm1_code::i32_const) && consume_i32_leb(step_i) && consume_op(wasm1_code::i32_add) &&
                                                       consume_op(wasm1_code::i32_store) && consume_u32_leb(tmp_store_align) &&
                                                       consume_u32_leb(tmp_store_off) && tmp_store_off == off_i;
                                        }

                                        if(match_ok) { match_ok = (p == endp); }

                                        if(match_ok)
                                        {
                                            ensure_memory0_resolved();

                                            auto const& loop_lbl{labels.index_unchecked(target_label_id)};
                                            if(!loop_lbl.in_thunk && loop_lbl.offset != SIZE_MAX)
                                            {
                                                // Remove all ptr-fixups in the to-be-rewritten loop region.
                                                while(!ptr_fixups.empty())
                                                {
                                                    auto const& fx{ptr_fixups.back_unchecked()};
                                                    if(fx.in_thunk || fx.site < loop_lbl.offset) { break; }
                                                    ptr_fixups.pop_back_unchecked();
                                                }

                                                bytecode.resize(loop_lbl.offset);

                                                namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_i32_sum_loop_run_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                                emit_imm_to(bytecode, local_offset_from_index(sp_local_idx));
                                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                                emit_imm_to(bytecode, off_i);
                                                emit_imm_to(bytecode, off_sum);
                                                emit_imm_to(bytecode, end_i);
                                                emit_imm_to(bytecode, step_i);

                                                fused_extra_heavy_loop_run = true;
                                            }
                                        }
                                    }
                                }

                                // Extra-heavy: mega-fuse `test10` hot affine inv-square f32 loop.
                                if constexpr(CompileOption.is_tail_call)
                                {
                                    if(!fused_extra_heavy_loop_run && target_frame.type == block_type::loop && label_index_uz == 0uz &&
                                       curr_size == target_base && target_frame.wasm_code_curr_at_start_label != nullptr)
                                    {
                                        bool match_ok{true};
                                        if constexpr(stacktop_enabled) { match_ok = (stacktop_cache_count == 0uz); }

                                        if(match_ok)
                                        {
                                            auto p{target_frame.wasm_code_curr_at_start_label};
                                            auto const endp{op_begin};

                                            auto const consume_op{[&](wasm1_code expected) constexpr noexcept -> bool
                                                                  {
                                                                      if(p >= endp) [[unlikely]] { return false; }
                                                                      wasm1_code op;  // no init
                                                                      ::std::memcpy(::std::addressof(op), p, sizeof(op));
                                                                      if(op != expected) { return false; }
                                                                      ++p;
                                                                      return true;
                                                                  }};

                                            auto const consume_u32_leb{[&](wasm_u32& v) constexpr noexcept -> bool
                                                                       {
                                                                           using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                                                           auto const [next, err]{
                                                                               ::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(p),
                                                                                                        reinterpret_cast<char8_t_const_may_alias_ptr>(endp),
                                                                                                        ::fast_io::mnp::leb128_get(v))};
                                                                           if(err != ::fast_io::parse_code::ok) [[unlikely]] { return false; }
                                                                           p = reinterpret_cast<::std::byte const*>(next);
                                                                           return true;
                                                                       }};

                                            auto const consume_i32_leb{[&](wasm_i32& v) constexpr noexcept -> bool
                                                                       {
                                                                           using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                                                           auto const [next, err]{
                                                                               ::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(p),
                                                                                                        reinterpret_cast<char8_t_const_may_alias_ptr>(endp),
                                                                                                        ::fast_io::mnp::leb128_get(v))};
                                                                           if(err != ::fast_io::parse_code::ok) [[unlikely]] { return false; }
                                                                           p = reinterpret_cast<::std::byte const*>(next);
                                                                           return true;
                                                                       }};

                                            auto const consume_f32_const_bits{[&](wasm_u32 expected_bits) constexpr noexcept -> bool
                                                                              {
                                                                                  if(!consume_op(wasm1_code::f32_const)) { return false; }
                                                                                  if(static_cast<::std::size_t>(endp - p) < 4uz) [[unlikely]] { return false; }
                                                                                  wasm_u32 bits;  // no init
                                                                                  ::std::memcpy(::std::addressof(bits), p, sizeof(bits));
                                                                                  p += 4;
                                                                                  return bits == expected_bits;
                                                                              }};

                                            constexpr wasm_u32 f32_one_bits{0x3f800000u};
                                            constexpr wasm_u32 f32_k_bits{0x3716feb5u};  // f32.const 0x1.2dfd6ap-17

                                            wasm_u32 sum_idx{};      // init
                                            wasm_u32 i_idx{};        // init
                                            wasm_u32 sum_out_idx{};  // init (local 3)
                                            wasm_u32 i1_idx{};       // init (local 4)
                                            wasm_i32 end_i{};        // init
                                            wasm_u32 tmp_u32{};      // init
                                            wasm_i32 tmp_i32{};      // init

                                            // 1 / (1 + i*k)^2 + sum -> sum_out
                                            match_ok = consume_f32_const_bits(f32_one_bits) && consume_op(wasm1_code::local_get) && consume_u32_leb(i_idx) &&
                                                       consume_op(wasm1_code::f32_convert_i32_u) && consume_f32_const_bits(f32_k_bits) &&
                                                       consume_op(wasm1_code::f32_mul) && consume_f32_const_bits(f32_one_bits) &&
                                                       consume_op(wasm1_code::f32_add) && consume_op(wasm1_code::local_tee) && consume_u32_leb(sum_out_idx) &&
                                                       consume_op(wasm1_code::local_get) && consume_u32_leb(tmp_u32) && tmp_u32 == sum_out_idx &&
                                                       consume_op(wasm1_code::f32_mul) && consume_op(wasm1_code::f32_div) &&
                                                       consume_op(wasm1_code::local_get) && consume_u32_leb(sum_idx) && consume_op(wasm1_code::f32_add) &&
                                                       consume_op(wasm1_code::local_set) && consume_u32_leb(tmp_u32) && tmp_u32 == sum_out_idx;

                                            // i1 = i+1; if(i1 == end) break;
                                            if(match_ok)
                                            {
                                                wasm_u32 brif_lbl_idx{};  // init
                                                match_ok = consume_op(wasm1_code::local_get) && consume_u32_leb(tmp_u32) && tmp_u32 == i_idx &&
                                                           consume_op(wasm1_code::i32_const) && consume_i32_leb(tmp_i32) && tmp_i32 == wasm_i32{1} &&
                                                           consume_op(wasm1_code::i32_add) && consume_op(wasm1_code::local_tee) && consume_u32_leb(i1_idx) &&
                                                           consume_op(wasm1_code::i32_const) && consume_i32_leb(end_i) && consume_op(wasm1_code::i32_eq) &&
                                                           consume_op(wasm1_code::br_if) && consume_u32_leb(brif_lbl_idx) && brif_lbl_idx == 1u;
                                            }

                                            // i = i1+1
                                            if(match_ok)
                                            {
                                                match_ok = consume_op(wasm1_code::local_get) && consume_u32_leb(tmp_u32) && tmp_u32 == i1_idx &&
                                                           consume_op(wasm1_code::i32_const) && consume_i32_leb(tmp_i32) && tmp_i32 == wasm_i32{1} &&
                                                           consume_op(wasm1_code::i32_add) && consume_op(wasm1_code::local_set) && consume_u32_leb(tmp_u32) &&
                                                           tmp_u32 == i_idx;
                                            }

                                            // 1 / (1 + i1*k)^2 + sum_out -> sum
                                            if(match_ok)
                                            {
                                                match_ok =
                                                    consume_f32_const_bits(f32_one_bits) && consume_op(wasm1_code::local_get) && consume_u32_leb(tmp_u32) &&
                                                    tmp_u32 == i1_idx && consume_op(wasm1_code::f32_convert_i32_u) && consume_f32_const_bits(f32_k_bits) &&
                                                    consume_op(wasm1_code::f32_mul) && consume_f32_const_bits(f32_one_bits) &&
                                                    consume_op(wasm1_code::f32_add) && consume_op(wasm1_code::local_tee) && consume_u32_leb(tmp_u32) &&
                                                    tmp_u32 == sum_idx && consume_op(wasm1_code::local_get) && consume_u32_leb(tmp_u32) && tmp_u32 == sum_idx &&
                                                    consume_op(wasm1_code::f32_mul) && consume_op(wasm1_code::f32_div) && consume_op(wasm1_code::local_get) &&
                                                    consume_u32_leb(tmp_u32) && tmp_u32 == sum_out_idx && consume_op(wasm1_code::f32_add) &&
                                                    consume_op(wasm1_code::local_set) && consume_u32_leb(tmp_u32) && tmp_u32 == sum_idx;
                                            }

                                            if(match_ok) { match_ok = (p == endp); }

                                            if(match_ok)
                                            {
                                                auto const& loop_lbl{labels.index_unchecked(target_label_id)};
                                                if(!loop_lbl.in_thunk && loop_lbl.offset != SIZE_MAX)
                                                {
                                                    while(!ptr_fixups.empty())
                                                    {
                                                        auto const& fx{ptr_fixups.back_unchecked()};
                                                        if(fx.in_thunk || fx.site < loop_lbl.offset) { break; }
                                                        ptr_fixups.pop_back_unchecked();
                                                    }

                                                    bytecode.resize(loop_lbl.offset);

                                                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_f32_affine_inv_square_sum_loop_run_fptr_from_tuple<CompileOption>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    emit_imm_to(bytecode, local_offset_from_index(sum_idx));
                                                    emit_imm_to(bytecode, local_offset_from_index(i_idx));
                                                    emit_imm_to(bytecode, local_offset_from_index(sum_out_idx));
                                                    emit_imm_to(bytecode, local_offset_from_index(i1_idx));
                                                    emit_imm_to(bytecode, end_i);

                                                    fused_extra_heavy_loop_run = true;
                                                }
                                            }
                                        }
                                    }
                                }
#endif
                                // Drop everything above target base.
                                // Safety: `target_base` must be <= `curr_size` in the non-polymorphic path.
                                if(!fused_extra_heavy_loop_run && curr_size > target_base)
                                {
                                    for(::std::size_t i{curr_size}; i > target_base; --i)
                                    {
                                        emit_drop_typed_to_no_fill(bytecode, operand_stack.index_unchecked(i - 1uz).type);
                                    }

                                    if constexpr(stacktop_enabled)
                                    {
                                        if constexpr(!strict_cf_entry_like_call) { stacktop_fill_to_canonical(bytecode); }
                                    }
                                }

                                if(!fused_extra_heavy_loop_run)
                                {
                                    if constexpr(stacktop_enabled)
                                    {
                                        if constexpr(strict_cf_entry_like_call) { stacktop_canonicalize_edge_to_memory(bytecode); }
                                    }
                                    if constexpr(stacktop_enabled)
                                    {
                                        if(target_frame.type == block_type::loop && stacktop_regtransform_cf_entry)
                                        {
                                            emit_br_to_with_stacktop_transform(bytecode, target_label_id, false);
                                        }
                                        else
                                        {
                                            emit_br_to(bytecode, target_label_id, false);
                                        }
                                    }
                                    else
                                    {
                                        emit_br_to(bytecode, target_label_id, false);
                                    }
                                }
                            }
                            else
                            {
                                // Wasm1: arity is 0 or 1.
                                auto const result_type{target_frame.result.begin[0]};

                                if(curr_size > target_base + 1uz)
                                {
                                    // Preserve the result value across dropping extra values.
                                    emit_local_set_typed_to_no_fill(bytecode, result_type, internal_temp_local_off);

                                    // Drop values between [target_base .. curr_size-2].
                                    for(::std::size_t i{curr_size - 1uz}; i-- > target_base;)
                                    {
                                        emit_drop_typed_to_no_fill(bytecode, operand_stack.index_unchecked(i).type);
                                    }

                                    if constexpr(stacktop_enabled)
                                    {
                                        if constexpr(!strict_cf_entry_like_call) { stacktop_fill_to_canonical(bytecode); }
                                    }
                                    emit_local_get_typed_to(bytecode, result_type, internal_temp_local_off);
                                }

                                if constexpr(stacktop_enabled)
                                {
                                    if constexpr(strict_cf_entry_like_call) { stacktop_canonicalize_edge_to_memory(bytecode); }
                                }
                                if constexpr(stacktop_enabled)
                                {
                                    if(target_frame.type == block_type::loop && stacktop_regtransform_cf_entry)
                                    {
                                        emit_br_to_with_stacktop_transform(bytecode, target_label_id, false);
                                    }
                                    else
                                    {
                                        emit_br_to(bytecode, target_label_id, false);
                                    }
                                }
                                else
                                {
                                    emit_br_to(bytecode, target_label_id, false);
                                }
                            }
                        }
                        else
                        {
                            emit_br_to(bytecode, target_label_id, false);
                        }

                        if constexpr(stacktop_enabled)
                        {
                            if constexpr(strict_cf_entry_like_call) { /* snapshots not needed */ }
                            else
                            {
                                // If this unconditional branch targets the end label of its frame, record the current
                                // stack-top state so the `end` handler can restore it when the fallthrough path becomes
                                // unreachable (polymorphic) before reaching `end`.
                                if(!is_polymorphic && target_label_id == target_frame.end_label_id)
                                {
                                    target_frame.stacktop_has_end_state = true;
                                    target_frame.stacktop_currpos_at_end = curr_stacktop;
                                    target_frame.stacktop_memory_count_at_end = stacktop_memory_count;
                                    target_frame.stacktop_cache_count_at_end = stacktop_cache_count;
                                    target_frame.stacktop_cache_i32_count_at_end = stacktop_cache_i32_count;
                                    target_frame.stacktop_cache_i64_count_at_end = stacktop_cache_i64_count;
                                    target_frame.stacktop_cache_f32_count_at_end = stacktop_cache_f32_count;
                                    target_frame.stacktop_cache_f64_count_at_end = stacktop_cache_f64_count;
                                    target_frame.codegen_operand_stack_at_end = codegen_operand_stack;
                                }
                            }
                        }

                        if(target_arity != 0uz) { operand_stack_pop_n(target_arity); }
                        auto const curr_frame_base{control_flow_stack.back_unchecked().operand_stack_base};
                        operand_stack_truncate_to(curr_frame_base);
                        is_polymorphic = true;

                        break;
                    }
                    case wasm1_code::br_if:
                    {
                        // br_if  label_index ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // br_if  label_index ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // br_if  label_index ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        wasm_u32 label_index;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [label_next, label_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                    reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                    ::fast_io::mnp::leb128_get(label_index))};
                        if(label_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_label_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(label_err);
                        }

                        // br_if  label_index ...
                        // [      safe      ] unsafe (could be the section_end)
                        //        ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(label_next);

                        // br_if  label_index ...
                        // [      safe      ] unsafe (could be the section_end)
                        //                    ^^ code_curr

                        auto const all_label_count_uz{control_flow_stack.size()};
                        auto const label_index_uz{static_cast<::std::size_t>(label_index)};
                        if(label_index_uz >= all_label_count_uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_label_index.label_index = label_index;
                            err.err_selectable.illegal_label_index.all_label_count = static_cast<wasm_u32>(all_label_count_uz);
                            err.err_code = code_validation_error_code::illegal_label_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const target_frame_index{all_label_count_uz - 1uz - label_index_uz};
                        auto const& target_frame{control_flow_stack.index_unchecked(target_frame_index)};
                        auto& target_frame_mut{control_flow_stack.index_unchecked(target_frame_index)};
                        // Label arity = label_types count. IMPORTANT: for `loop`, label types are parameters (MVP: none),
                        // not result types.
                        auto const target_arity{
                            target_frame.type == block_type::loop ? 0uz : static_cast<::std::size_t>(target_frame.result.end - target_frame.result.begin)};

                        if(!is_polymorphic && operand_stack.size() < target_arity + 1uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = u8"br_if";
                            err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                            err.err_selectable.operand_stack_underflow.stack_size_required = target_arity + 1uz;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(!operand_stack.empty())
                        {
                            auto const cond{operand_stack.back_unchecked()};
                            operand_stack_pop_unchecked();
                            if(!is_polymorphic && cond.type != curr_operand_stack_value_type::i32) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.br_cond_type_not_i32.op_code_name = u8"br_if";
                                err.err_selectable.br_cond_type_not_i32.cond_type = static_cast<wasm_value_type_u>(cond.type);
                                err.err_code = code_validation_error_code::br_cond_type_not_i32;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        if(!is_polymorphic && target_arity != 0uz && operand_stack.size() >= target_arity)
                        {
                            auto const expected_type{*target_frame.result.begin};
                            auto const actual_type{operand_stack.back_unchecked().type};
                            if(actual_type != expected_type) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.br_value_type_mismatch.op_code_name = u8"br_if";
                                err.err_selectable.br_value_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                                err.err_selectable.br_value_type_mismatch.actual_type = static_cast<wasm_value_type_u>(actual_type);
                                err.err_code = code_validation_error_code::br_value_type_mismatch;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        // Translate: `br_if` needs stack repair on the taken path only. If repair is necessary, emit a thunk target.
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        // When stack-top caching is enabled, the i32 condition may still reside in operand stack memory
                        // (e.g. tiny rings / merged scalar rings). `br_if` must pop from the correct source to keep the
                        // runtime stack pointer consistent with the compiler-side model.
                        bool brif_cond_cached_at_site{true};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS

                        // Conbine: `local.get(i32); i32.eqz; br_if` and `local.get(i32); i32.const; cmp; br_if`.
                        bool conbine_brif_local_eqz{};
                        bool conbine_brif_i32_cmp_imm{};

                        local_offset_t conbine_brif_local_off{};
                        wasm_i32 conbine_brif_imm{};
                        conbine_brif_cmp_kind conbine_brif_cmp{conbine_brif_cmp_kind::none};

# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        bool conbine_brif_i32_rem_u_eqz_2localget{};
                        local_offset_t conbine_brif_local_off2{};
                        bool conbine_brif_for_i32_inc_f64_lt_u_eqz{};
                        wasm_i32 conbine_brif_step{};
#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                        bool conbine_brif_for_i32_inc_lt_u{};
                        bool conbine_brif_for_ptr_inc_ne{};
                        wasm_i32 conbine_brif_end{};
#  endif
# endif

                        if(conbine_pending.kind == conbine_pending_kind::local_get_eqz_i32)
                        {
                            conbine_brif_local_eqz = true;
                            conbine_brif_local_off = conbine_pending.off1;
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                        }
                        else if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32_cmp_brif)
                        {
                            conbine_brif_i32_cmp_imm = true;
                            conbine_brif_local_off = conbine_pending.off1;
                            conbine_brif_imm = conbine_pending.imm_i32;
                            conbine_brif_cmp = conbine_pending.brif_cmp;
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        else if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::i32_rem_u_eqz_2localget_wait_brif)
                        {
                            conbine_brif_i32_rem_u_eqz_2localget = true;
                            conbine_brif_local_off = conbine_pending.off1;
                            conbine_brif_local_off2 = conbine_pending.off2;
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                        }
                        else if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_eqz)
                        {
                            conbine_brif_for_i32_inc_f64_lt_u_eqz = true;
                            conbine_brif_local_off = conbine_pending.off1;
                            conbine_brif_local_off2 = conbine_pending.off2;
                            conbine_brif_step = conbine_pending.imm_i32;
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                        }
#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                        else if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::for_i32_inc_after_cmp)
                        {
                            conbine_brif_for_i32_inc_lt_u = true;
                            conbine_brif_local_off = conbine_pending.off1;
                            conbine_brif_step = conbine_pending.imm_i32;
                            conbine_brif_end = conbine_pending.imm_i32_2;
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                        }
                        else if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::for_ptr_inc_after_cmp)
                        {
                            conbine_brif_for_ptr_inc_ne = true;
                            conbine_brif_local_off = conbine_pending.off1;
                            conbine_brif_local_off2 = conbine_pending.off2;
                            conbine_brif_step = conbine_pending.imm_i32;
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                        }
#  endif
# endif

                        auto const fuse_kind{br_if_fuse.kind};
                        auto const fuse_site{br_if_fuse.site};
                        auto const fuse_end{br_if_fuse.end};
                        auto const fuse_stacktop_currpos{br_if_fuse.stacktop_currpos_at_site};

                        br_if_fuse.kind = br_if_fuse_kind::none;
                        br_if_fuse.site = SIZE_MAX;
                        br_if_fuse.end = SIZE_MAX;
                        br_if_fuse.stacktop_currpos_at_site = {};

                        bool fused_brif{};
                        auto const patch_fused_brif{
                            [&]() constexpr UWVM_THROWS
                            {
                                if(fused_brif || fuse_kind == br_if_fuse_kind::none) { return; }
                                if constexpr(stacktop_enabled)
                                {
                                    // Fused br_if opfuncs read the i32 condition from stack-top cache. With tiny rings,
                                    // the condition can be materialized in operand-stack memory (cache empty), in which
                                    // case fusing would desync the runtime stack pointer.
                                    if(!brif_cond_cached_at_site) { return; }
                                }

                                using fptr_t = decltype(translate::get_uwvmint_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                if(fuse_site == SIZE_MAX) { return; }
                                if(fuse_end != SIZE_MAX)
                                {
                                    if(fuse_end != bytecode.size()) { return; }
                                }
                                else
                                {
                                    if(fuse_site + sizeof(fptr_t) != bytecode.size()) { return; }
                                }

                                fptr_t fused_fptr{};
                                switch(fuse_kind)
                                {
                                    case br_if_fuse_kind::i32_eqz:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_eqz_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::local_tee_nz:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_local_tee_nz_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_eq:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_eq_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_ne:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_ne_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_lt_s:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_lt_s_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_lt_u:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_lt_u_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_gt_u:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_gt_u_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_ge_s:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_ge_s_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_ge_u:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_ge_u_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_le_u:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_le_u_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_gt_s:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_gt_s_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_le_s:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_le_s_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i32_and_nz:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i32_and_nz_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i64_eqz:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i64_eqz_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i64_ne:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i64_ne_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i64_gt_u:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i64_gt_u_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::i64_lt_u:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_i64_lt_u_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                    case br_if_fuse_kind::f32_eq:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f32_eq_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::f32_ne:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f32_ne_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::f32_lt:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f32_lt_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::f32_gt:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f32_gt_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::f32_le:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f32_le_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::f32_ge:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f32_ge_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::f64_eq:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f64_eq_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::f64_lt:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f64_lt_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
                                    case br_if_fuse_kind::f64_lt_eqz:
                                    {
                                        fused_fptr =
                                            translate::get_uwvmint_br_if_f64_lt_eqz_fptr_from_tuple<CompileOption>(fuse_stacktop_currpos, interpreter_tuple);
                                        break;
                                    }
# endif
                                    case br_if_fuse_kind::none:
                                        [[fallthrough]];
                                    [[unlikely]] default:
                                    {
# if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                        ::uwvm2::utils::debug::trap_and_inform_bug_pos();
# endif
                                        return;
                                    }
                                }

                                ::std::byte tmp[sizeof(fused_fptr)];
                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                ::std::memcpy(bytecode.data() + fuse_site, tmp, sizeof(fused_fptr));
                                fused_brif = true;
                            }};

                        auto const emit_br_if_jump{
                            [&](::std::size_t label_id) constexpr UWVM_THROWS
                            {
                                patch_fused_brif();
                                if(!fused_brif)
                                {
                                    if constexpr(stacktop_enabled)
                                    {
                                        if(!brif_cond_cached_at_site)
                                        {
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_br_if_pop_from_memory_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                        }
                                        else
                                        {
                                            emit_opfunc_to(bytecode,
                                                           translate::get_uwvmint_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                        }
                                    }
                                    else
                                    {
                                        emit_opfunc_to(bytecode, translate::get_uwvmint_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    }
                                }
                                emit_ptr_label_placeholder(label_id, false);
                            }};

                        auto const emit_br_if_jump_conbine{
                            [&](::std::size_t label_id) constexpr UWVM_THROWS
                            {
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                if(conbine_brif_i32_rem_u_eqz_2localget)
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_br_if_i32_rem_u_eqz_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, conbine_brif_local_off);
                                    emit_imm_to(bytecode, conbine_brif_local_off2);
                                    emit_ptr_label_placeholder(label_id, false);
                                    return;
                                }

                                if(conbine_brif_for_i32_inc_f64_lt_u_eqz)
                                {
#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                                    // Mega-fuse `test8` hot prime divisor loop:
                                    //   br_if (n % i == 0) -> break
                                    //   i += step; br_if (sqrt < i) == 0 -> loop
                                    //
                                    // When the loop body is exactly the above two fused br_if opfuncs and the second br_if
                                    // targets the loop start label, we can emit a single opfunc that runs the whole loop
                                    // internally and keeps `n/sqrt/i` in registers.
                                    {
                                        using prev_fptr_t =
                                            decltype(translate::get_uwvmint_br_if_i32_rem_u_eqz_2localget_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                         interpreter_tuple));

                                        constexpr ::std::size_t prev_inst_size{sizeof(prev_fptr_t) + sizeof(local_offset_t) * 2uz + sizeof(rel_offset_t)};
                                        if(bytecode.size() >= prev_inst_size && label_id < labels.size())
                                        {
                                            auto const prev_start{bytecode.size() - prev_inst_size};
                                            auto const& loop_label_info{labels.index_unchecked(label_id)};
                                            if(!loop_label_info.in_thunk && loop_label_info.offset == prev_start)
                                            {
                                                prev_fptr_t stored_prev{};  // init
                                                ::std::memcpy(::std::addressof(stored_prev), bytecode.data() + prev_start, sizeof(stored_prev));

                                                auto const expected_prev{
                                                    translate::get_uwvmint_br_if_i32_rem_u_eqz_2localget_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                        interpreter_tuple)};
                                                if(stored_prev == expected_prev)
                                                {
                                                    local_offset_t n_off{};  // init
                                                    local_offset_t i_off{};  // init
                                                    ::std::memcpy(::std::addressof(n_off), bytecode.data() + prev_start + sizeof(prev_fptr_t), sizeof(n_off));
                                                    ::std::memcpy(::std::addressof(i_off),
                                                                  bytecode.data() + prev_start + sizeof(prev_fptr_t) + sizeof(n_off),
                                                                  sizeof(i_off));
                                                    if(i_off == conbine_brif_local_off2 && !ptr_fixups.empty())
                                                    {
                                                        auto const prev_label_site{prev_start + sizeof(prev_fptr_t) + sizeof(local_offset_t) * 2uz};
                                                        auto const last_fixup{ptr_fixups.back_unchecked()};
                                                        if(!last_fixup.in_thunk && last_fixup.site == prev_label_site)
                                                        {
                                                            auto const break_label_id{last_fixup.label_id};

                                                            // Rewind previous br_if opfunc and its ptr-fixup, then emit the
                                                            // mega-fused opfunc.
                                                            bytecode.resize(prev_start);
                                                            ptr_fixups.pop_back_unchecked();

                                                            emit_opfunc_to(bytecode,
                                                                           translate::get_uwvmint_prime_divisor_loop_run_fptr_from_tuple<CompileOption>(
                                                                               curr_stacktop,
                                                                               interpreter_tuple));
                                                            emit_imm_to(bytecode, n_off);
                                                            emit_imm_to(bytecode, i_off);
                                                            emit_imm_to(bytecode, conbine_brif_local_off);  // sqrt_off
                                                            emit_imm_to(bytecode, conbine_brif_step);       // step
                                                            emit_ptr_label_placeholder(break_label_id, false);
                                                            return;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
#  endif

                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_for_i32_inc_f64_lt_u_eqz_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, conbine_brif_local_off);
                                    emit_imm_to(bytecode, conbine_brif_local_off2);
                                    emit_imm_to(bytecode, conbine_brif_step);
                                    emit_ptr_label_placeholder(label_id, false);
                                    return;
                                }

#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                                if(conbine_brif_for_i32_inc_lt_u)
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_for_i32_inc_lt_u_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, conbine_brif_local_off);
                                    emit_imm_to(bytecode, conbine_brif_step);
                                    emit_imm_to(bytecode, conbine_brif_end);
                                    emit_ptr_label_placeholder(label_id, false);
                                    return;
                                }

                                if(conbine_brif_for_ptr_inc_ne)
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_for_ptr_inc_ne_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, conbine_brif_local_off);
                                    emit_imm_to(bytecode, conbine_brif_local_off2);
                                    emit_imm_to(bytecode, conbine_brif_step);
                                    emit_ptr_label_placeholder(label_id, false);
                                    return;
                                }
#  endif
# endif
                                if(conbine_brif_local_eqz)
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_br_if_local_eqz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, conbine_brif_local_off);
                                    emit_ptr_label_placeholder(label_id, false);
                                    return;
                                }

                                if(conbine_brif_i32_cmp_imm)
                                {
                                    switch(conbine_brif_cmp)
                                    {
                                        case conbine_brif_cmp_kind::i32_eq:
                                        {
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_br_if_i32_eq_imm_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                            break;
                                        }
                                        case conbine_brif_cmp_kind::i32_lt_s:
                                        {
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_br_if_i32_lt_s_imm_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                            break;
                                        }
                                        case conbine_brif_cmp_kind::i32_lt_u:
                                        {
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_br_if_i32_lt_u_imm_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                            break;
                                        }
                                        case conbine_brif_cmp_kind::i32_ge_s:
                                        {
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_br_if_i32_ge_s_imm_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                            break;
                                        }
                                        case conbine_brif_cmp_kind::i32_ge_u:
                                        {
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_br_if_i32_ge_u_imm_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                            break;
                                        }
                                        case conbine_brif_cmp_kind::none:
                                            [[fallthrough]];
                                        [[unlikely]] default:
                                        {
# if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                            ::uwvm2::utils::debug::trap_and_inform_bug_pos();
# endif
                                            ::fast_io::fast_terminate();
                                        }
                                    }

                                    emit_imm_to(bytecode, conbine_brif_local_off);
                                    emit_imm_to(bytecode, conbine_brif_imm);
                                    emit_ptr_label_placeholder(label_id, false);
                                    return;
                                }

                                emit_br_if_jump(label_id);
                            }};

                        auto const emit_br_if_jump_any{[&](::std::size_t label_id) constexpr UWVM_THROWS
                                                       {
                                                           if(runtime_log_on) [[unlikely]]
                                                           {
                                                               ++runtime_log_stats.cf_br_if_count;
                                                               if(runtime_log_emit_cf)
                                                               {
                                                                   ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                                                        u8"[uwvm-int-translator] fn=",
                                                                                        function_index,
                                                                                        u8" ip=",
                                                                                        runtime_log_curr_ip,
                                                                                        u8" event=bytecode.emit.cf | op=br_if bc=main off=",
                                                                                        bytecode.size(),
                                                                                        u8" label_id=",
                                                                                        label_id,
                                                                                        u8"\n");
                                                               }
                                                           }
                                                           emit_br_if_jump_conbine(label_id);
                                                       }};

                        auto const target_label_id{get_branch_target_label_id(target_frame)};

                        bool const brif_consumes_stack_cond{!(conbine_brif_local_eqz || conbine_brif_i32_cmp_imm
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                                              || conbine_brif_i32_rem_u_eqz_2localget || conbine_brif_for_i32_inc_f64_lt_u_eqz
#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                                                              || conbine_brif_for_i32_inc_lt_u || conbine_brif_for_ptr_inc_ne
#  endif
# endif
                                                              )};
#else
                        // Combine disabled: `br_if` always consumes an i32 condition from the operand stack.
                        auto const emit_br_if_jump_any{
                            [&](::std::size_t label_id) constexpr UWVM_THROWS
                            {
                                if(runtime_log_on) [[unlikely]]
                                {
                                    ++runtime_log_stats.cf_br_if_count;
                                    if(runtime_log_emit_cf)
                                    {
                                        ::fast_io::io::print(::uwvm2::uwvm::io::u8runtime_log_output,
                                                             u8"[uwvm-int-translator] fn=",
                                                             function_index,
                                                             u8" ip=",
                                                             runtime_log_curr_ip,
                                                             u8" event=bytecode.emit.cf | op=br_if bc=main off=",
                                                             bytecode.size(),
                                                             u8" label_id=",
                                                             label_id,
                                                             u8"\n");
                                    }
                                }
                                if constexpr(stacktop_enabled)
                                {
                                    if(!brif_cond_cached_at_site)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_br_if_pop_from_memory_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    }
                                    else
                                    {
                                        emit_opfunc_to(bytecode, translate::get_uwvmint_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    }
                                }
                                else
                                {
                                    emit_opfunc_to(bytecode, translate::get_uwvmint_br_if_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                }
                                emit_ptr_label_placeholder(label_id, false);
                            }};

                        auto const target_label_id{get_branch_target_label_id(target_frame)};
                        bool const brif_consumes_stack_cond{true};
#endif
                        if(is_polymorphic) { emit_br_if_jump_any(target_label_id); }
                        else
                        {
                            auto const target_base{target_frame.operand_stack_base};
                            auto const curr_size{operand_stack.size()};  // condition already popped

                            bool const need_repair{curr_size > target_base + target_arity};

#if defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS)
                            // Extra-heavy: mega-fuse `test9`-like hot f32 loops into a single opfunc dispatch.
                            // This removes huge threaded-interpreter dispatch overhead from the tight arithmetic loops.
                            if(!need_repair && target_arity == 0uz && target_frame.type == block_type::loop && label_index_uz == 0uz &&
                               curr_size == target_base && target_base == 0uz && target_frame.wasm_code_curr_at_start_label != nullptr)
                            {
                                bool fused_extra_heavy_loop_run{};

                                auto const startp{target_frame.wasm_code_curr_at_start_label};
                                auto const endp{op_begin};

                                if(startp < endp)
                                {
                                    auto const consume_op{[&](wasm1_code expected, ::std::byte const*& p) constexpr noexcept -> bool
                                                          {
                                                              if(p >= endp) [[unlikely]] { return false; }
                                                              wasm1_code op;  // no init
                                                              ::std::memcpy(::std::addressof(op), p, sizeof(op));
                                                              if(op != expected) { return false; }
                                                              ++p;
                                                              return true;
                                                          }};

                                    auto const consume_u32_leb{[&](wasm_u32& v, ::std::byte const*& p) constexpr noexcept -> bool
                                                               {
                                                                   using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                                                   auto const [next, err]{
                                                                       ::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(p),
                                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(endp),
                                                                                                ::fast_io::mnp::leb128_get(v))};
                                                                   if(err != ::fast_io::parse_code::ok) [[unlikely]] { return false; }
                                                                   p = reinterpret_cast<::std::byte const*>(next);
                                                                   return true;
                                                               }};

                                    auto const consume_i32_leb{[&](wasm_i32& v, ::std::byte const*& p) constexpr noexcept -> bool
                                                               {
                                                                   using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                                                   auto const [next, err]{
                                                                       ::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(p),
                                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(endp),
                                                                                                ::fast_io::mnp::leb128_get(v))};
                                                                   if(err != ::fast_io::parse_code::ok) [[unlikely]] { return false; }
                                                                   p = reinterpret_cast<::std::byte const*>(next);
                                                                   return true;
                                                               }};

                                    auto const consume_f32_const_bits{[&](wasm_u32 expected_bits, ::std::byte const*& p) constexpr noexcept -> bool
                                                                      {
                                                                          if(!consume_op(wasm1_code::f32_const, p)) { return false; }
                                                                          if(static_cast<::std::size_t>(endp - p) < 4uz) [[unlikely]] { return false; }
                                                                          wasm_u32 bits;  // no init
                                                                          ::std::memcpy(::std::addressof(bits), p, sizeof(bits));
                                                                          p += 4;
                                                                          return bits == expected_bits;
                                                                      }};

                                    constexpr wasm_u32 f32_one_bits{0x3f800000u};
                                    constexpr wasm_u32 f32_half_bits{0x3f000000u};

                                    wasm_u32 fused_sum_idx{};   // init
                                    wasm_u32 fused_i_idx{};     // init
                                    wasm_u32 fused_prod_idx{};  // init
                                    wasm_u32 fused_ip4_idx{};   // init
                                    wasm_i32 fused_end{};       // init

                                    enum class test9_loop_kind : unsigned
                                    {
                                        none,
                                        f32_inv_square_sum,
                                        f32_mul_chain_sum,
                                        f32_inv_cube_sum,
                                    };
                                    test9_loop_kind fused_kind{test9_loop_kind::none};

                                    auto const try_match_inv_square{
                                        [&]() constexpr noexcept -> bool
                                        {
                                            auto p{startp};
                                            wasm_u32 sum_idx{};  // init
                                            wasm_u32 i_idx{};    // init
                                            wasm_u32 tmp_idx{};  // init
                                            wasm_i32 end_i{};    // init
                                            wasm_u32 tmp_u32{};  // init
                                            wasm_i32 tmp_i32{};  // init

                                            bool ok = consume_f32_const_bits(f32_one_bits, p) && consume_op(wasm1_code::local_get, p) &&
                                                      consume_u32_leb(i_idx, p) && consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) &&
                                                      tmp_u32 == i_idx && consume_op(wasm1_code::i32_mul, p) && consume_op(wasm1_code::f32_convert_i32_u, p) &&
                                                      consume_op(wasm1_code::f32_div, p) && consume_f32_const_bits(f32_one_bits, p) &&
                                                      consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                      consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) && tmp_i32 == wasm_i32{-1} &&
                                                      consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::local_tee, p) &&
                                                      consume_u32_leb(tmp_idx, p) && consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) &&
                                                      tmp_u32 == tmp_idx && consume_op(wasm1_code::i32_mul, p) &&
                                                      consume_op(wasm1_code::f32_convert_i32_u, p) && consume_op(wasm1_code::f32_div, p) &&
                                                      consume_op(wasm1_code::local_get, p) && consume_u32_leb(sum_idx, p) &&
                                                      consume_op(wasm1_code::f32_add, p) && consume_op(wasm1_code::f32_add, p) &&
                                                      consume_op(wasm1_code::local_set, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == sum_idx &&
                                                      consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                      consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) && tmp_i32 == wasm_i32{2} &&
                                                      consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::local_tee, p) &&
                                                      consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx && consume_op(wasm1_code::i32_const, p) &&
                                                      consume_i32_leb(end_i, p) && consume_op(wasm1_code::i32_ne, p) && (p == endp);

                                            if(!ok) { return false; }

                                            fused_sum_idx = sum_idx;
                                            fused_i_idx = i_idx;
                                            fused_end = end_i;
                                            fused_kind = test9_loop_kind::f32_inv_square_sum;
                                            return true;
                                        }};

                                    auto const try_match_inv_cube{
                                        [&]() constexpr noexcept -> bool
                                        {
                                            auto p{startp};
                                            wasm_u32 sum_idx{};  // init
                                            wasm_u32 i_idx{};    // init
                                            wasm_u32 tmp_idx{};  // init
                                            wasm_i32 end_i{};    // init
                                            wasm_u32 tmp_u32{};  // init
                                            wasm_i32 tmp_i32{};  // init

                                            bool ok =
                                                consume_f32_const_bits(f32_one_bits, p) && consume_op(wasm1_code::local_get, p) && consume_u32_leb(i_idx, p) &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                consume_op(wasm1_code::i32_mul, p) && consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) &&
                                                tmp_u32 == i_idx && consume_op(wasm1_code::i32_mul, p) && consume_op(wasm1_code::f32_convert_i32_u, p) &&
                                                consume_op(wasm1_code::f32_div, p) && consume_f32_const_bits(f32_one_bits, p) &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) && tmp_i32 == wasm_i32{-1} &&
                                                consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::local_tee, p) && consume_u32_leb(tmp_idx, p) &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == tmp_idx &&
                                                consume_op(wasm1_code::i32_mul, p) && consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) &&
                                                tmp_u32 == tmp_idx && consume_op(wasm1_code::i32_mul, p) && consume_op(wasm1_code::f32_convert_i32_u, p) &&
                                                consume_op(wasm1_code::f32_div, p) && consume_op(wasm1_code::local_get, p) && consume_u32_leb(sum_idx, p) &&
                                                consume_op(wasm1_code::f32_add, p) && consume_op(wasm1_code::f32_add, p) &&
                                                consume_op(wasm1_code::local_set, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == sum_idx &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) && tmp_i32 == wasm_i32{2} &&
                                                consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::local_tee, p) && consume_u32_leb(tmp_u32, p) &&
                                                tmp_u32 == i_idx && consume_op(wasm1_code::i32_const, p) && consume_i32_leb(end_i, p) &&
                                                consume_op(wasm1_code::i32_ne, p) && (p == endp);

                                            if(!ok) { return false; }

                                            fused_sum_idx = sum_idx;
                                            fused_i_idx = i_idx;
                                            fused_end = end_i;
                                            fused_kind = test9_loop_kind::f32_inv_cube_sum;
                                            return true;
                                        }};

                                    auto const try_match_mul_chain{
                                        [&]() constexpr noexcept -> bool
                                        {
                                            auto p{startp};
                                            wasm_u32 sum_idx{};   // init
                                            wasm_u32 i_idx{};     // init
                                            wasm_u32 prod_idx{};  // init
                                            wasm_u32 ip4_idx{};   // init
                                            wasm_u32 t5{};        // init
                                            wasm_u32 t6{};        // init
                                            wasm_u32 t7{};        // init
                                            wasm_u32 t8{};        // init
                                            wasm_i32 end_i{};     // init
                                            wasm_u32 tmp_u32{};   // init
                                            wasm_i32 tmp_i32{};   // init

                                            bool ok =
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(prod_idx, p) &&
                                                consume_f32_const_bits(f32_half_bits, p) && consume_op(wasm1_code::f32_mul, p) &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(i_idx, p) &&
                                                consume_op(wasm1_code::f32_convert_i32_u, p) && consume_op(wasm1_code::f32_mul, p) &&
                                                consume_op(wasm1_code::local_tee, p) && consume_u32_leb(t5, p) && consume_f32_const_bits(f32_half_bits, p) &&
                                                consume_op(wasm1_code::f32_mul, p) && consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) &&
                                                tmp_u32 == i_idx && consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) &&
                                                tmp_i32 == wasm_i32{1} && consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::f32_convert_i32_u, p) &&
                                                consume_op(wasm1_code::f32_mul, p) && consume_op(wasm1_code::local_tee, p) && consume_u32_leb(t6, p) &&
                                                consume_f32_const_bits(f32_half_bits, p) && consume_op(wasm1_code::f32_mul, p) &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) && tmp_i32 == wasm_i32{2} &&
                                                consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::f32_convert_i32_u, p) &&
                                                consume_op(wasm1_code::f32_mul, p) && consume_op(wasm1_code::local_tee, p) && consume_u32_leb(t7, p) &&
                                                consume_f32_const_bits(f32_half_bits, p) && consume_op(wasm1_code::f32_mul, p) &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) && tmp_i32 == wasm_i32{3} &&
                                                consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::f32_convert_i32_u, p) &&
                                                consume_op(wasm1_code::f32_mul, p) && consume_op(wasm1_code::local_tee, p) && consume_u32_leb(t8, p) &&
                                                consume_f32_const_bits(f32_half_bits, p) && consume_op(wasm1_code::f32_mul, p) &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) && tmp_i32 == wasm_i32{4} &&
                                                consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::local_tee, p) && consume_u32_leb(ip4_idx, p) &&
                                                consume_op(wasm1_code::f32_convert_i32_u, p) && consume_op(wasm1_code::f32_mul, p) &&
                                                consume_op(wasm1_code::local_tee, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == prod_idx &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == t8 &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == t7 &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == t6 &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == t5 &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(sum_idx, p) && consume_op(wasm1_code::f32_add, p) &&
                                                consume_op(wasm1_code::f32_add, p) && consume_op(wasm1_code::f32_add, p) &&
                                                consume_op(wasm1_code::f32_add, p) && consume_op(wasm1_code::f32_add, p) &&
                                                consume_op(wasm1_code::local_set, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == sum_idx &&
                                                consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == i_idx &&
                                                consume_op(wasm1_code::i32_const, p) && consume_i32_leb(tmp_i32, p) && tmp_i32 == wasm_i32{5} &&
                                                consume_op(wasm1_code::i32_add, p) && consume_op(wasm1_code::local_set, p) && consume_u32_leb(tmp_u32, p) &&
                                                tmp_u32 == i_idx && consume_op(wasm1_code::local_get, p) && consume_u32_leb(tmp_u32, p) && tmp_u32 == ip4_idx &&
                                                consume_op(wasm1_code::i32_const, p) && consume_i32_leb(end_i, p) && consume_op(wasm1_code::i32_ne, p) &&
                                                (p == endp);

                                            if(!ok) { return false; }

                                            fused_sum_idx = sum_idx;
                                            fused_i_idx = i_idx;
                                            fused_prod_idx = prod_idx;
                                            fused_ip4_idx = ip4_idx;
                                            fused_end = end_i;
                                            fused_kind = test9_loop_kind::f32_mul_chain_sum;
                                            return true;
                                        }};

                                    // Try match in descending "signature uniqueness" order.
                                    if(!try_match_mul_chain())
                                    {
                                        if(!try_match_inv_square()) { (void)try_match_inv_cube(); }
                                    }

                                    if(fused_kind != test9_loop_kind::none)
                                    {
                                        auto const target_label_id{get_branch_target_label_id(target_frame)};
                                        auto const& loop_lbl{labels.index_unchecked(target_label_id)};
                                        if(!loop_lbl.in_thunk && loop_lbl.offset != SIZE_MAX)
                                        {
                                            while(!ptr_fixups.empty())
                                            {
                                                auto const& fx{ptr_fixups.back_unchecked()};
                                                if(fx.in_thunk || fx.site < loop_lbl.offset) { break; }
                                                ptr_fixups.pop_back_unchecked();
                                            }

                                            bytecode.resize(loop_lbl.offset);

                                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                                            switch(fused_kind)
                                            {
                                                case test9_loop_kind::f32_inv_square_sum:
                                                {
                                                    emit_opfunc_to(
                                                        bytecode,
                                                        translate::get_uwvmint_f32_inv_square_sum_loop_run_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                          interpreter_tuple));
                                                    emit_imm_to(bytecode, local_offset_from_index(fused_sum_idx));
                                                    emit_imm_to(bytecode, local_offset_from_index(fused_i_idx));
                                                    emit_imm_to(bytecode, fused_end);
                                                    fused_extra_heavy_loop_run = true;
                                                    break;
                                                }
                                                case test9_loop_kind::f32_inv_cube_sum:
                                                {
                                                    emit_opfunc_to(
                                                        bytecode,
                                                        translate::get_uwvmint_f32_inv_cube_sum_loop_run_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                        interpreter_tuple));
                                                    emit_imm_to(bytecode, local_offset_from_index(fused_sum_idx));
                                                    emit_imm_to(bytecode, local_offset_from_index(fused_i_idx));
                                                    emit_imm_to(bytecode, fused_end);
                                                    fused_extra_heavy_loop_run = true;
                                                    break;
                                                }
                                                case test9_loop_kind::f32_mul_chain_sum:
                                                {
                                                    emit_opfunc_to(
                                                        bytecode,
                                                        translate::get_uwvmint_f32_mul_chain_sum_loop_run_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                         interpreter_tuple));
                                                    emit_imm_to(bytecode, local_offset_from_index(fused_sum_idx));
                                                    emit_imm_to(bytecode, local_offset_from_index(fused_i_idx));
                                                    emit_imm_to(bytecode, local_offset_from_index(fused_prod_idx));
                                                    emit_imm_to(bytecode, local_offset_from_index(fused_ip4_idx));
                                                    emit_imm_to(bytecode, fused_end);
                                                    fused_extra_heavy_loop_run = true;
                                                    break;
                                                }
                                                case test9_loop_kind::none:
                                                    [[fallthrough]];
                                                [[unlikely]] default:
                                                    break;
                                            }
                                        }
                                    }
                                }

                                if(fused_extra_heavy_loop_run)
                                {
                                    if constexpr(stacktop_enabled)
                                    {
                                        if(brif_consumes_stack_cond)
                                        {
                                            // Model the i32 condition pop (no runtime code needed because the entire loop
                                            // body (including the compare) is replaced by the mega-fused opfunc).
                                            stacktop_commit_pop_n(1uz);
                                            codegen_stack_pop_n(1uz);
                                        }
                                    }
                                    break;
                                }
                            }
#endif

                            if constexpr(stacktop_enabled)
                            {
                                if(brif_consumes_stack_cond)
                                {
                                    // With stack-top caching enabled, popping the condition may require fills to keep the
                                    // cache canonical. Those fills must run on both taken and fallthrough paths.
                                    //
                                    // Fast path: if the condition-pop cannot trigger any canonical fills, we can jump directly
                                    // without introducing a taken-path thunk.
                                    auto const brif_stacktop_currpos_at_site{curr_stacktop};
                                    brif_cond_cached_at_site = (stacktop_cache_count != 0uz);

                                    // Model the i32 condition pop (post-pop, pre-fill).
                                    stacktop_commit_pop_n(1uz);
                                    codegen_stack_pop_n(1uz);

                                    bool const need_fill_to_canonical{[&]() constexpr noexcept -> bool
                                                                      {
                                                                          if(stacktop_memory_count == 0uz) { return false; }
                                                                          auto const vt{
                                                                              codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};
                                                                          ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                                                                          ::std::size_t const end_pos{stacktop_range_end_pos(vt)};
                                                                          ::std::size_t const ring_size{end_pos - begin_pos};
                                                                          return stacktop_cache_count_for_range(begin_pos, end_pos) != ring_size;
                                                                      }()};

                                    if constexpr(strict_cf_entry_like_call)
                                    {
                                        // In strict mode, the taken path must enter re-entry labels with an empty cache.
                                        // If the post-pop cache is already empty and no repair is needed, jump directly.
                                        if(!need_repair && stacktop_cache_count == 0uz)
                                        {
                                            auto const saved_post_pop_stacktop{curr_stacktop};
                                            curr_stacktop = brif_stacktop_currpos_at_site;
                                            emit_br_if_jump_any(target_label_id);
                                            curr_stacktop = saved_post_pop_stacktop;
                                            // Fallthrough: refill to canonical after the condition pop.
                                            stacktop_fill_to_canonical(bytecode);
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if(!need_fill_to_canonical && !need_repair)
                                        {
                                            // Jump directly (no thunk needed). Emit using the pre-pop stacktop cursor.
                                            //
                                            // If the target is a loop start and we still have cached values after popping
                                            // the condition, we must transform the cache layout to the loop's begin-currpos
                                            // contract on the taken path (register-only; no spill/fill).
                                            ::std::size_t brif_target_label_id{target_label_id};
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                                            if constexpr(stacktop_enabled && CompileOption.is_tail_call && stacktop_regtransform_cf_entry &&
                                                         stacktop_regtransform_supported)
                                            {
                                                if(target_frame.type == block_type::loop && stacktop_cache_count != 0uz)
                                                {
                                                    auto const transform_thunk_label_id{new_label(true)};
                                                    set_label_offset(transform_thunk_label_id, thunks.size());
                                                    emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                                    brif_target_label_id = transform_thunk_label_id;
                                                }
                                            }
#endif

                                            // Emit using the pre-pop stacktop cursor (the br_if op reads the condition before the pop).
                                            auto const saved_post_pop_stacktop{curr_stacktop};
                                            curr_stacktop = brif_stacktop_currpos_at_site;
                                            emit_br_if_jump_any(brif_target_label_id);
                                            curr_stacktop = saved_post_pop_stacktop;

                                            if(target_label_id == target_frame.end_label_id)
                                            {
                                                target_frame_mut.stacktop_has_end_state = true;
                                                target_frame_mut.stacktop_currpos_at_end = curr_stacktop;
                                                target_frame_mut.stacktop_memory_count_at_end = stacktop_memory_count;
                                                target_frame_mut.stacktop_cache_count_at_end = stacktop_cache_count;
                                                target_frame_mut.stacktop_cache_i32_count_at_end = stacktop_cache_i32_count;
                                                target_frame_mut.stacktop_cache_i64_count_at_end = stacktop_cache_i64_count;
                                                target_frame_mut.stacktop_cache_f32_count_at_end = stacktop_cache_f32_count;
                                                target_frame_mut.stacktop_cache_f64_count_at_end = stacktop_cache_f64_count;
                                                target_frame_mut.codegen_operand_stack_at_end = codegen_operand_stack;
                                            }

                                            break;
                                        }
                                    }

                                    auto const taken_thunk_label_id{new_label(true)};

                                    // Emit the branch using the pre-pop stacktop cursor.
                                    {
                                        auto const saved_post_pop_stacktop{curr_stacktop};
                                        curr_stacktop = brif_stacktop_currpos_at_site;
                                        emit_br_if_jump_any(taken_thunk_label_id);
                                        curr_stacktop = saved_post_pop_stacktop;
                                    }

                                    auto const post_pop_curr_stacktop{curr_stacktop};
                                    auto const post_pop_memory_count{stacktop_memory_count};
                                    auto const post_pop_cache_count{stacktop_cache_count};
                                    auto const post_pop_cache_i32_count{stacktop_cache_i32_count};
                                    auto const post_pop_cache_i64_count{stacktop_cache_i64_count};
                                    auto const post_pop_cache_f32_count{stacktop_cache_f32_count};
                                    auto const post_pop_cache_f64_count{stacktop_cache_f64_count};
                                    auto const post_pop_codegen_operand_stack{codegen_operand_stack};

                                    // Emit taken thunk: fill-to-canonical, then optional repair, then jump.
                                    {
                                        set_label_offset(taken_thunk_label_id, thunks.size());

                                        // Do not let thunk codegen mutate the fallthrough compiler state.
                                        auto const saved_curr_stacktop{curr_stacktop};
                                        auto const saved_memory_count{stacktop_memory_count};
                                        auto const saved_cache_count{stacktop_cache_count};
                                        auto const saved_cache_i32_count{stacktop_cache_i32_count};
                                        auto const saved_cache_i64_count{stacktop_cache_i64_count};
                                        auto const saved_cache_f32_count{stacktop_cache_f32_count};
                                        auto const saved_cache_f64_count{stacktop_cache_f64_count};
                                        auto const saved_codegen_operand_stack{codegen_operand_stack};

                                        // Ensure thunk starts from the post-pop state.
                                        curr_stacktop = post_pop_curr_stacktop;
                                        stacktop_memory_count = post_pop_memory_count;
                                        stacktop_cache_count = post_pop_cache_count;
                                        stacktop_cache_i32_count = post_pop_cache_i32_count;
                                        stacktop_cache_i64_count = post_pop_cache_i64_count;
                                        stacktop_cache_f32_count = post_pop_cache_f32_count;
                                        stacktop_cache_f64_count = post_pop_cache_f64_count;
                                        codegen_operand_stack = post_pop_codegen_operand_stack;

                                        if constexpr(strict_cf_entry_like_call)
                                        {
                                            // Taken path: repair (if needed), then canonicalize (empty cache) before jumping.
                                            if(need_repair)
                                            {
                                                if(target_arity == 0uz)
                                                {
                                                    for(::std::size_t i{curr_size}; i > target_base; --i)
                                                    {
                                                        emit_drop_typed_to_no_fill(thunks, operand_stack.index_unchecked(i - 1uz).type);
                                                    }
                                                }
                                                else
                                                {
                                                    auto const result_type{target_frame.result.begin[0]};
                                                    emit_local_set_typed_to_no_fill(thunks, result_type, internal_temp_local_off);
                                                    for(::std::size_t i{curr_size - 1uz}; i-- > target_base;)
                                                    {
                                                        emit_drop_typed_to_no_fill(thunks, operand_stack.index_unchecked(i).type);
                                                    }
                                                    emit_local_get_typed_to(thunks, result_type, internal_temp_local_off);
                                                }
                                            }

                                            stacktop_canonicalize_edge_to_memory(thunks);
                                            if(target_frame.type == block_type::loop && stacktop_regtransform_cf_entry)
                                            {
                                                emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                            }
                                            else
                                            {
                                                emit_br_to(thunks, target_label_id, true);
                                            }
                                        }
                                        else
                                        {
                                            stacktop_fill_to_canonical(thunks);

                                            if(!need_repair)
                                            {
                                                if(target_frame.type == block_type::loop && stacktop_regtransform_cf_entry)
                                                {
                                                    emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                                }
                                                else
                                                {
                                                    emit_br_to(thunks, target_label_id, true);
                                                }
                                            }
                                            else if(target_arity == 0uz)
                                            {
                                                // Safety: `target_base` must be <= `curr_size` in the non-polymorphic path.
                                                for(::std::size_t i{curr_size}; i > target_base; --i)
                                                {
                                                    emit_drop_typed_to_no_fill(thunks, operand_stack.index_unchecked(i - 1uz).type);
                                                }
                                                stacktop_fill_to_canonical(thunks);
                                                if(target_frame.type == block_type::loop && stacktop_regtransform_cf_entry)
                                                {
                                                    emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                                }
                                                else
                                                {
                                                    emit_br_to(thunks, target_label_id, true);
                                                }
                                            }
                                            else
                                            {
                                                auto const result_type{target_frame.result.begin[0]};
                                                emit_local_set_typed_to_no_fill(thunks, result_type, internal_temp_local_off);

                                                for(::std::size_t i{curr_size - 1uz}; i-- > target_base;)
                                                {
                                                    emit_drop_typed_to_no_fill(thunks, operand_stack.index_unchecked(i).type);
                                                }

                                                stacktop_fill_to_canonical(thunks);
                                                emit_local_get_typed_to(thunks, result_type, internal_temp_local_off);
                                                if(target_frame.type == block_type::loop && stacktop_regtransform_cf_entry)
                                                {
                                                    emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                                }
                                                else
                                                {
                                                    emit_br_to(thunks, target_label_id, true);
                                                }
                                            }

                                            if(target_label_id == target_frame.end_label_id)
                                            {
                                                target_frame_mut.stacktop_has_end_state = true;
                                                target_frame_mut.stacktop_currpos_at_end = curr_stacktop;
                                                target_frame_mut.stacktop_memory_count_at_end = stacktop_memory_count;
                                                target_frame_mut.stacktop_cache_count_at_end = stacktop_cache_count;
                                                target_frame_mut.stacktop_cache_i32_count_at_end = stacktop_cache_i32_count;
                                                target_frame_mut.stacktop_cache_i64_count_at_end = stacktop_cache_i64_count;
                                                target_frame_mut.stacktop_cache_f32_count_at_end = stacktop_cache_f32_count;
                                                target_frame_mut.stacktop_cache_f64_count_at_end = stacktop_cache_f64_count;
                                                target_frame_mut.codegen_operand_stack_at_end = codegen_operand_stack;
                                            }
                                        }

                                        curr_stacktop = saved_curr_stacktop;
                                        stacktop_memory_count = saved_memory_count;
                                        stacktop_cache_count = saved_cache_count;
                                        stacktop_cache_i32_count = saved_cache_i32_count;
                                        stacktop_cache_i64_count = saved_cache_i64_count;
                                        stacktop_cache_f32_count = saved_cache_f32_count;
                                        stacktop_cache_f64_count = saved_cache_f64_count;
                                        codegen_operand_stack = saved_codegen_operand_stack;
                                    }

                                    // Fallthrough: refill to canonical after the condition pop.
                                    stacktop_fill_to_canonical(bytecode);

                                    break;
                                }
                            }

                            bool const strict_need_taken_thunk{[&]() constexpr noexcept -> bool
                                                               {
                                                                   if constexpr(stacktop_enabled && strict_cf_entry_like_call)
                                                                   {
                                                                       return need_repair || (stacktop_cache_count != 0uz);
                                                                   }
                                                                   else
                                                                   {
                                                                       return need_repair;
                                                                   }
                                                               }()};

                            if(!strict_need_taken_thunk)
                            {
                                ::std::size_t brif_target_label_id{target_label_id};
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                                if constexpr(stacktop_enabled && CompileOption.is_tail_call && stacktop_regtransform_cf_entry &&
                                             stacktop_regtransform_supported)
                                {
                                    if(!is_polymorphic && target_frame.type == block_type::loop && stacktop_cache_count != 0uz)
                                    {
                                        auto const transform_thunk_label_id{new_label(true)};
                                        set_label_offset(transform_thunk_label_id, thunks.size());
                                        emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                        brif_target_label_id = transform_thunk_label_id;
                                    }
                                }
#endif
                                emit_br_if_jump_any(brif_target_label_id);

                                if constexpr(stacktop_enabled)
                                {
                                    if constexpr(strict_cf_entry_like_call) { /* snapshots not needed */ }
                                    else
                                    {
                                        // If this branch targets the end label of its frame, record the current stack-top state
                                        // so `end` can restore it when the fallthrough path becomes unreachable later.
                                        //
                                        // Note: This must also happen for fused `br_if` forms that do not consume a condition from
                                        // the operand stack (e.g. `local.get; i32.eqz; br_if` fused to a local-based `br_if`),
                                        // because in that case the taken path still reaches the end label even though no stack pop
                                        // triggers the thunk-based snapshot logic above.
                                        if(!is_polymorphic && target_label_id == target_frame.end_label_id)
                                        {
                                            target_frame_mut.stacktop_has_end_state = true;
                                            target_frame_mut.stacktop_currpos_at_end = curr_stacktop;
                                            target_frame_mut.stacktop_memory_count_at_end = stacktop_memory_count;
                                            target_frame_mut.stacktop_cache_count_at_end = stacktop_cache_count;
                                            target_frame_mut.stacktop_cache_i32_count_at_end = stacktop_cache_i32_count;
                                            target_frame_mut.stacktop_cache_i64_count_at_end = stacktop_cache_i64_count;
                                            target_frame_mut.stacktop_cache_f32_count_at_end = stacktop_cache_f32_count;
                                            target_frame_mut.stacktop_cache_f64_count_at_end = stacktop_cache_f64_count;
                                            target_frame_mut.codegen_operand_stack_at_end = codegen_operand_stack;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                // Create a taken-path thunk: repair stack then jump.
                                auto const thunk_label_id{new_label(true)};
                                set_label_offset(thunk_label_id, thunks.size());

                                // The thunk is emitted into a separate buffer; do not let its stack-top state mutations
                                // affect the main bytecode generation state.
                                auto const saved_curr_stacktop{curr_stacktop};
                                auto const saved_memory_count{stacktop_memory_count};
                                auto const saved_cache_count{stacktop_cache_count};
                                auto const saved_cache_i32_count{stacktop_cache_i32_count};
                                auto const saved_cache_i64_count{stacktop_cache_i64_count};
                                auto const saved_cache_f32_count{stacktop_cache_f32_count};
                                auto const saved_cache_f64_count{stacktop_cache_f64_count};
                                auto const saved_codegen_operand_stack{codegen_operand_stack};

                                if(need_repair)
                                {
                                    if(target_arity == 0uz)
                                    {
                                        for(::std::size_t i{curr_size}; i > target_base; --i)
                                        {
                                            emit_drop_typed_to_no_fill(thunks, operand_stack.index_unchecked(i - 1uz).type);
                                        }
                                        if constexpr(stacktop_enabled)
                                        {
                                            if constexpr(!strict_cf_entry_like_call) { stacktop_fill_to_canonical(thunks); }
                                        }
                                    }
                                    else
                                    {
                                        auto const result_type{target_frame.result.begin[0]};
                                        emit_local_set_typed_to_no_fill(thunks, result_type, internal_temp_local_off);
                                        for(::std::size_t i{curr_size - 1uz}; i-- > target_base;)
                                        {
                                            emit_drop_typed_to_no_fill(thunks, operand_stack.index_unchecked(i).type);
                                        }
                                        if constexpr(stacktop_enabled)
                                        {
                                            if constexpr(!strict_cf_entry_like_call) { stacktop_fill_to_canonical(thunks); }
                                        }
                                        emit_local_get_typed_to(thunks, result_type, internal_temp_local_off);
                                    }
                                }

                                if constexpr(stacktop_enabled)
                                {
                                    if constexpr(strict_cf_entry_like_call) { stacktop_canonicalize_edge_to_memory(thunks); }
                                }
                                if constexpr(stacktop_enabled)
                                {
                                    if(target_frame.type == block_type::loop && stacktop_regtransform_cf_entry)
                                    {
                                        emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                    }
                                    else
                                    {
                                        emit_br_to(thunks, target_label_id, true);
                                    }
                                }
                                else
                                {
                                    emit_br_to(thunks, target_label_id, true);
                                }

                                if constexpr(stacktop_enabled)
                                {
                                    if constexpr(strict_cf_entry_like_call) { /* snapshots not needed */ }
                                    else
                                    {
                                        // Same rationale as the `!need_repair` path: ensure `end` has a reachable snapshot even
                                        // when the taken path is lowered via a repair thunk and the condition is not popped from
                                        // the operand stack.
                                        if(!is_polymorphic && target_label_id == target_frame.end_label_id)
                                        {
                                            target_frame_mut.stacktop_has_end_state = true;
                                            target_frame_mut.stacktop_currpos_at_end = curr_stacktop;
                                            target_frame_mut.stacktop_memory_count_at_end = stacktop_memory_count;
                                            target_frame_mut.stacktop_cache_count_at_end = stacktop_cache_count;
                                            target_frame_mut.stacktop_cache_i32_count_at_end = stacktop_cache_i32_count;
                                            target_frame_mut.stacktop_cache_i64_count_at_end = stacktop_cache_i64_count;
                                            target_frame_mut.stacktop_cache_f32_count_at_end = stacktop_cache_f32_count;
                                            target_frame_mut.stacktop_cache_f64_count_at_end = stacktop_cache_f64_count;
                                            target_frame_mut.codegen_operand_stack_at_end = codegen_operand_stack;
                                        }
                                    }
                                }

                                curr_stacktop = saved_curr_stacktop;
                                stacktop_memory_count = saved_memory_count;
                                stacktop_cache_count = saved_cache_count;
                                stacktop_cache_i32_count = saved_cache_i32_count;
                                stacktop_cache_i64_count = saved_cache_i64_count;
                                stacktop_cache_f32_count = saved_cache_f32_count;
                                stacktop_cache_f64_count = saved_cache_f64_count;
                                codegen_operand_stack = saved_codegen_operand_stack;

                                emit_br_if_jump_any(thunk_label_id);
                            }
                        }

                        break;
                    }
                    case wasm1_code::br_table:
                    {
                        // br_table  target_count ...
                        // [ safe ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // br_table  target_count ...
                        // [ safe ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // br_table  target_count ...
                        // [ safe ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;

                        wasm_u32 target_count;
                        auto const [cnt_next, cnt_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                ::fast_io::mnp::leb128_get(target_count))};
                        if(cnt_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_label_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(cnt_err);
                        }

                        // br_table  target_count ...
                        // [       safe         ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(cnt_next);

                        // br_table  target_count ...
                        // [       safe         ] unsafe (could be the section_end)
                        //                       ^^ code_curr

                        auto const all_label_count_uz{control_flow_stack.size()};
                        auto const validate_label{[&](wasm_u32 li) constexpr UWVM_THROWS
                                                  {
                                                      if(static_cast<::std::size_t>(li) >= all_label_count_uz) [[unlikely]]
                                                      {
                                                          err.err_curr = op_begin;
                                                          err.err_selectable.illegal_label_index.label_index = li;
                                                          err.err_selectable.illegal_label_index.all_label_count = static_cast<wasm_u32>(all_label_count_uz);
                                                          err.err_code = code_validation_error_code::illegal_label_index;
                                                          ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                                                      }
                                                  }};

                        struct get_sig_result_t
                        {
                            ::std::size_t arity{};
                            curr_operand_stack_value_type type{};
                        };

                        auto const get_sig{[&](wasm_u32 li) constexpr noexcept
                                           {
                                               auto const& frame{control_flow_stack.index_unchecked(all_label_count_uz - 1uz - static_cast<::std::size_t>(li))};
                                               ::std::size_t arity{};
                                               curr_operand_stack_value_type type{};
                                               if(frame.type != block_type::loop)
                                               {
                                                   arity = static_cast<::std::size_t>(frame.result.end - frame.result.begin);
                                                   if(arity != 0uz) { type = frame.result.begin[0]; }
                                               }
                                               return get_sig_result_t{arity, type};
                                           }};

                        bool have_expected_sig{};
                        wasm_u32 expected_label{};
                        ::std::size_t expected_arity{};
                        curr_operand_stack_value_type expected_type{};

                        ::uwvm2::utils::container::vector<wasm_u32> br_table_label_indices{};
                        br_table_label_indices.reserve(static_cast<::std::size_t>(target_count) + 1uz);

                        for(wasm_u32 i{}; i != target_count; ++i)
                        {
                            // ...    | curr_target ...
                            // [safe] | unsafe (could be the section_end)
                            //          ^^ code_curr

                            wasm_u32 li;
                            auto const [li_next, li_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                  reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                  ::fast_io::mnp::leb128_get(li))};
                            if(li_err != ::fast_io::parse_code::ok) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_code = code_validation_error_code::invalid_label_index;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(li_err);
                            }

                            // ...   | curr_target ...
                            // [safe | safe      ] unsafe (could be the section_end)
                            //         ^^ code_curr

                            code_curr = reinterpret_cast<::std::byte const*>(li_next);

                            // ...   | curr_target ...
                            // [safe | safe      ] unsafe (could be the section_end)
                            //                     ^^ code_curr

                            validate_label(li);
                            // Safe: reserved exactly `target_count + 1` above.
                            br_table_label_indices.push_back_unchecked(li);

                            auto const [arity, type]{get_sig(li)};
                            if(!have_expected_sig)
                            {
                                have_expected_sig = true;
                                expected_label = li;
                                expected_arity = arity;
                                expected_type = type;
                            }
                            else if(arity != expected_arity || (expected_arity != 0uz && type != expected_type)) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.br_table_target_type_mismatch.expected_label_index = expected_label;
                                err.err_selectable.br_table_target_type_mismatch.mismatched_label_index = li;
                                err.err_selectable.br_table_target_type_mismatch.expected_arity = static_cast<wasm_u32>(expected_arity);
                                err.err_selectable.br_table_target_type_mismatch.actual_arity = static_cast<wasm_u32>(arity);
                                err.err_selectable.br_table_target_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                                err.err_selectable.br_table_target_type_mismatch.actual_type = static_cast<wasm_value_type_u>(type);
                                err.err_code = code_validation_error_code::br_table_target_type_mismatch;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        // ... last_target | default_label ...
                        // [   safe      ]   unsafe (could be the section_end)
                        //                   ^^ code_curr

                        wasm_u32 default_label;
                        auto const [def_next, def_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                ::fast_io::mnp::leb128_get(default_label))};
                        if(def_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_label_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(def_err);
                        }

                        // ... last_target | default_label ...
                        // [         safe  |      safe   ] unsafe (could be the section_end)
                        //                   ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(def_next);

                        // ... last_target | default_label ...
                        // [         safe  |      safe   ] unsafe (could be the section_end)
                        //                                 ^^ code_curr

                        validate_label(default_label);
                        // Safe: reserved exactly `target_count + 1` above.
                        br_table_label_indices.push_back_unchecked(default_label);

                        auto const [default_arity, default_type]{get_sig(default_label)};
                        if(!have_expected_sig)
                        {
                            have_expected_sig = true;
                            expected_label = default_label;
                            expected_arity = default_arity;
                            expected_type = default_type;
                        }
                        else if(default_arity != expected_arity || (expected_arity != 0uz && default_type != expected_type)) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.br_table_target_type_mismatch.expected_label_index = expected_label;
                            err.err_selectable.br_table_target_type_mismatch.mismatched_label_index = default_label;
                            err.err_selectable.br_table_target_type_mismatch.expected_arity = static_cast<wasm_u32>(expected_arity);
                            err.err_selectable.br_table_target_type_mismatch.actual_arity = static_cast<wasm_u32>(default_arity);
                            err.err_selectable.br_table_target_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                            err.err_selectable.br_table_target_type_mismatch.actual_type = static_cast<wasm_value_type_u>(default_type);
                            err.err_code = code_validation_error_code::br_table_target_type_mismatch;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(!is_polymorphic && operand_stack.size() < expected_arity + 1uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = u8"br_table";
                            err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                            err.err_selectable.operand_stack_underflow.stack_size_required = expected_arity + 1uz;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(!operand_stack.empty())
                        {
                            auto const idx{operand_stack.back_unchecked()};
                            operand_stack_pop_unchecked();
                            if(!is_polymorphic && idx.type != curr_operand_stack_value_type::i32) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.br_cond_type_not_i32.op_code_name = u8"br_table";
                                err.err_selectable.br_cond_type_not_i32.cond_type = static_cast<wasm_value_type_u>(idx.type);
                                err.err_code = code_validation_error_code::br_cond_type_not_i32;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        // Stack-top caching: `br_table` reads the selector index from the stack-top cache (tail-call opfunc).
                        // The bytecode opfunc does not pop the selector at runtime; instead the translator models the pop by advancing
                        // the stack-top cursor and decrementing cache depth, so the consumed selector is treated as dead and will not
                        // be spilled across the branch edge.
                        //
                        // IMPORTANT: the opfunc must read the selector from the **pre-pop** stack-top slot; use a snapshot for fptr selection.
                        auto br_table_stacktop_currpos_at_site{curr_stacktop};
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                // In strict CF-entry mode, the cache can be empty at re-entry labels; ensure the selector is resident in cache.
                                if(stacktop_cache_count == 0uz) { stacktop_fill_to_canonical(bytecode); }
                                br_table_stacktop_currpos_at_site = curr_stacktop;

                                stacktop_commit_pop_n(1uz);
                                codegen_stack_pop_n(1uz);
                            }
                        }

                        if(!is_polymorphic && expected_arity != 0uz && operand_stack.size() >= expected_arity)
                        {
                            auto const actual_type{operand_stack.back_unchecked().type};
                            if(actual_type != expected_type) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.br_value_type_mismatch.op_code_name = u8"br_table";
                                err.err_selectable.br_value_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                                err.err_selectable.br_value_type_mismatch.actual_type = static_cast<wasm_value_type_u>(actual_type);
                                err.err_code = code_validation_error_code::br_value_type_mismatch;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        // Translate: `br_table` always branches. Use per-target thunks when stack repair is required.
                        {
                            auto const curr_size{operand_stack.size()};  // selector already popped
                            emit_opfunc_to(bytecode,
                                           ::uwvm2::runtime::compiler::uwvm_int::optable::translate::get_uwvmint_br_table_fptr_from_tuple<CompileOption>(
                                               br_table_stacktop_currpos_at_site,
                                               interpreter_tuple));
                            emit_imm_to(bytecode, static_cast<::std::size_t>(target_count));

                            for(auto const li: br_table_label_indices)
                            {
                                auto& target_frame_mut{control_flow_stack.index_unchecked(all_label_count_uz - 1uz - static_cast<::std::size_t>(li))};
                                auto const& target_frame{target_frame_mut};
                                auto const target_label_id{get_branch_target_label_id(target_frame)};

                                if(is_polymorphic)
                                {
                                    emit_ptr_label_placeholder(target_label_id, false);
                                    continue;
                                }

                                auto const target_base{target_frame.operand_stack_base};
                                bool const need_repair{curr_size > target_base + expected_arity};
                                bool const strict_need_thunk{[&]() constexpr noexcept -> bool
                                                             {
                                                                 if constexpr(stacktop_enabled && strict_cf_entry_like_call)
                                                                 {
                                                                     return need_repair || (stacktop_cache_count != 0uz);
                                                                 }
                                                                 else
                                                                 {
                                                                     return need_repair;
                                                                 }
                                                             }()};
                                if(!strict_need_thunk)
                                {
                                    if constexpr(stacktop_enabled)
                                    {
                                        if constexpr(strict_cf_entry_like_call) { /* snapshots not needed */ }
                                        else
                                        {
                                            // Record reachable end-label state for constructs that are reached via this `br_table`
                                            // when their fallthrough becomes unreachable before `end`.
                                            if(!is_polymorphic && target_label_id == target_frame.end_label_id)
                                            {
                                                target_frame_mut.stacktop_has_end_state = true;
                                                target_frame_mut.stacktop_currpos_at_end = curr_stacktop;
                                                target_frame_mut.stacktop_memory_count_at_end = stacktop_memory_count;
                                                target_frame_mut.stacktop_cache_count_at_end = stacktop_cache_count;
                                                target_frame_mut.stacktop_cache_i32_count_at_end = stacktop_cache_i32_count;
                                                target_frame_mut.stacktop_cache_i64_count_at_end = stacktop_cache_i64_count;
                                                target_frame_mut.stacktop_cache_f32_count_at_end = stacktop_cache_f32_count;
                                                target_frame_mut.stacktop_cache_f64_count_at_end = stacktop_cache_f64_count;
                                                target_frame_mut.codegen_operand_stack_at_end = codegen_operand_stack;
                                            }
                                        }
                                    }
                                    ::std::size_t br_table_target_label_id{target_label_id};
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                                    if constexpr(stacktop_enabled && CompileOption.is_tail_call && stacktop_regtransform_cf_entry &&
                                                 stacktop_regtransform_supported)
                                    {
                                        if(!is_polymorphic && target_frame.type == block_type::loop && stacktop_cache_count != 0uz)
                                        {
                                            auto const transform_thunk_label_id{new_label(true)};
                                            set_label_offset(transform_thunk_label_id, thunks.size());
                                            emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                            br_table_target_label_id = transform_thunk_label_id;
                                        }
                                    }
#endif
                                    emit_ptr_label_placeholder(br_table_target_label_id, false);
                                    continue;
                                }

                                auto const thunk_label_id{new_label(true)};
                                set_label_offset(thunk_label_id, thunks.size());

                                // Thunk emission must not mutate the main stack-top codegen state.
                                auto const saved_curr_stacktop{curr_stacktop};
                                auto const saved_memory_count{stacktop_memory_count};
                                auto const saved_cache_count{stacktop_cache_count};
                                auto const saved_cache_i32_count{stacktop_cache_i32_count};
                                auto const saved_cache_i64_count{stacktop_cache_i64_count};
                                auto const saved_cache_f32_count{stacktop_cache_f32_count};
                                auto const saved_cache_f64_count{stacktop_cache_f64_count};
                                auto const saved_codegen_operand_stack{codegen_operand_stack};

                                if(need_repair)
                                {
                                    if(expected_arity == 0uz)
                                    {
                                        for(::std::size_t i{curr_size}; i > target_base; --i)
                                        {
                                            emit_drop_typed_to_no_fill(thunks, operand_stack.index_unchecked(i - 1uz).type);
                                        }
                                        if constexpr(stacktop_enabled)
                                        {
                                            if constexpr(!strict_cf_entry_like_call) { stacktop_fill_to_canonical(thunks); }
                                        }
                                    }
                                    else
                                    {
                                        emit_local_set_typed_to_no_fill(thunks, expected_type, internal_temp_local_off);
                                        for(::std::size_t i{curr_size - 1uz}; i-- > target_base;)
                                        {
                                            emit_drop_typed_to_no_fill(thunks, operand_stack.index_unchecked(i).type);
                                        }
                                        if constexpr(stacktop_enabled)
                                        {
                                            if constexpr(!strict_cf_entry_like_call) { stacktop_fill_to_canonical(thunks); }
                                        }
                                        emit_local_get_typed_to(thunks, expected_type, internal_temp_local_off);
                                    }
                                }

                                if constexpr(stacktop_enabled)
                                {
                                    if constexpr(strict_cf_entry_like_call) { stacktop_canonicalize_edge_to_memory(thunks); }
                                }
                                if constexpr(stacktop_enabled)
                                {
                                    if(target_frame.type == block_type::loop && stacktop_regtransform_cf_entry)
                                    {
                                        emit_br_to_with_stacktop_transform(thunks, target_label_id, true);
                                    }
                                    else
                                    {
                                        emit_br_to(thunks, target_label_id, true);
                                    }
                                }
                                else
                                {
                                    emit_br_to(thunks, target_label_id, true);
                                }

                                if constexpr(stacktop_enabled)
                                {
                                    if constexpr(strict_cf_entry_like_call) { /* snapshots not needed */ }
                                    else
                                    {
                                        if(!is_polymorphic && target_label_id == target_frame.end_label_id)
                                        {
                                            target_frame_mut.stacktop_has_end_state = true;
                                            target_frame_mut.stacktop_currpos_at_end = curr_stacktop;
                                            target_frame_mut.stacktop_memory_count_at_end = stacktop_memory_count;
                                            target_frame_mut.stacktop_cache_count_at_end = stacktop_cache_count;
                                            target_frame_mut.stacktop_cache_i32_count_at_end = stacktop_cache_i32_count;
                                            target_frame_mut.stacktop_cache_i64_count_at_end = stacktop_cache_i64_count;
                                            target_frame_mut.stacktop_cache_f32_count_at_end = stacktop_cache_f32_count;
                                            target_frame_mut.stacktop_cache_f64_count_at_end = stacktop_cache_f64_count;
                                            target_frame_mut.codegen_operand_stack_at_end = codegen_operand_stack;
                                        }
                                    }
                                }

                                curr_stacktop = saved_curr_stacktop;
                                stacktop_memory_count = saved_memory_count;
                                stacktop_cache_count = saved_cache_count;
                                stacktop_cache_i32_count = saved_cache_i32_count;
                                stacktop_cache_i64_count = saved_cache_i64_count;
                                stacktop_cache_f32_count = saved_cache_f32_count;
                                stacktop_cache_f64_count = saved_cache_f64_count;
                                codegen_operand_stack = saved_codegen_operand_stack;

                                emit_ptr_label_placeholder(thunk_label_id, false);
                            }
                        }

                        if(expected_arity != 0uz) { operand_stack_pop_n(expected_arity); }
                        auto const curr_frame_base{control_flow_stack.back_unchecked().operand_stack_base};
                        operand_stack_truncate_to(curr_frame_base);
                        is_polymorphic = true;

                        break;
                    }
                    case wasm1_code::return_:
                    {
                        // return ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // return ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // return ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        auto const& func_frame{control_flow_stack.index_unchecked(0u)};
                        ::std::size_t const return_arity{static_cast<::std::size_t>(func_frame.result.end - func_frame.result.begin)};

                        if(!is_polymorphic && operand_stack.size() < return_arity) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = u8"return";
                            err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                            err.err_selectable.operand_stack_underflow.stack_size_required = return_arity;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const operator_stack_size{operand_stack.size()};
                        if(!is_polymorphic && return_arity != 0uz && operator_stack_size >= return_arity)
                        {
                            for(::std::size_t i{}; i != return_arity; ++i)
                            {
                                auto const expected_type{func_frame.result.begin[return_arity - 1uz - i]};
                                auto const actual_type{operand_stack.index_unchecked(operator_stack_size - 1uz - i).type};
                                if(actual_type != expected_type) [[unlikely]]
                                {
                                    err.err_curr = op_begin;
                                    err.err_selectable.br_value_type_mismatch.op_code_name = u8"return";
                                    err.err_selectable.br_value_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                                    err.err_selectable.br_value_type_mismatch.actual_type = static_cast<wasm_value_type_u>(actual_type);
                                    err.err_code = code_validation_error_code::br_value_type_mismatch;
                                    ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                                }
                            }
                        }

                        // Translate: `return` terminates the function. Repair the operand stack so it contains only the function results.
                        if(is_polymorphic) { emit_return_to(bytecode); }
                        else
                        {
                            auto const target_base{func_frame.operand_stack_base};  // function base (0)
                            auto const curr_size{operand_stack.size()};

                            if(return_arity == 0uz)
                            {
                                // Safety: `target_base` must be <= `curr_size` in the non-polymorphic path.
                                for(::std::size_t i{curr_size}; i > target_base; --i)
                                {
                                    emit_drop_typed_to_no_fill(bytecode, operand_stack.index_unchecked(i - 1uz).type);
                                }
                                emit_return_to(bytecode);
                            }
                            else
                            {
                                auto const result_type{func_frame.result.begin[0]};

                                if(curr_size > target_base + 1uz)
                                {
                                    emit_local_set_typed_to_no_fill(bytecode, result_type, internal_temp_local_off);
                                    for(::std::size_t i{curr_size - 1uz}; i-- > target_base;)
                                    {
                                        emit_drop_typed_to_no_fill(bytecode, operand_stack.index_unchecked(i).type);
                                    }
                                    emit_local_get_typed_to(bytecode, result_type, internal_temp_local_off);
                                }

                                emit_return_to(bytecode);
                            }
                        }

                        if(return_arity != 0uz) { operand_stack_pop_n(return_arity); }

                        auto const curr_frame_base{control_flow_stack.back_unchecked().operand_stack_base};
                        operand_stack_truncate_to(curr_frame_base);
                        is_polymorphic = true;

                        break;
                    }
                    case wasm1_code::call:
                    {
                        // call     func_index ...
                        // [ safe ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // call     func_index ...
                        // [ safe ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // call     func_index ...
                        // [ safe ] unsafe (could be the section_end)
                        //          ^^ code_curr

                        wasm_u32 func_index;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [func_next, func_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                  reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                  ::fast_io::mnp::leb128_get(func_index))};
                        if(func_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_function_index_encoding;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(func_err);
                        }

                        // call func_index ...
                        // [      safe   ] unsafe (could be the section_end)
                        //      ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(func_next);

                        // call func_index ...
                        // [      safe   ] unsafe (could be the section_end)
                        //                ^^ code_curr

                        auto const all_function_size{import_func_count + local_func_count};
                        if(static_cast<::std::size_t>(func_index) >= all_function_size) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.invalid_function_index.function_index = static_cast<::std::size_t>(func_index);
                            err.err_selectable.invalid_function_index.all_function_size = all_function_size;
                            err.err_code = code_validation_error_code::invalid_function_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        ::uwvm2::uwvm::runtime::storage::wasm_binfmt1_final_function_type_t const* callee_type_ptr{};
                        if(static_cast<::std::size_t>(func_index) < import_func_count)
                        {
                            auto const& imported_rec{curr_module.imported_function_vec_storage.index_unchecked(static_cast<::std::size_t>(func_index))};
                            auto const imported_func_ptr{imported_rec.import_type_ptr};
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            if(imported_func_ptr == nullptr) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                            callee_type_ptr = imported_func_ptr->imports.storage.function;
                        }
                        else
                        {
                            auto const local_idx{static_cast<::std::size_t>(func_index) - import_func_count};
                            callee_type_ptr = curr_module.local_defined_function_vec_storage.index_unchecked(local_idx).function_type_ptr;
                        }

#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                        if(callee_type_ptr == nullptr) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif

                        auto const& callee_type{*callee_type_ptr};
                        auto const param_count{static_cast<::std::size_t>(callee_type.parameter.end - callee_type.parameter.begin)};
                        auto const result_count{static_cast<::std::size_t>(callee_type.result.end - callee_type.result.begin)};
                        bool const allow_call_fusion{param_count <= 3uz};
                        auto const func_index_uz{static_cast<::std::size_t>(func_index)};
                        ::std::size_t call_module_id{options.curr_wasm_id};
                        ::std::size_t call_function_imm{func_index_uz};
                        if(func_index_uz >= import_func_count)
                        {
                            auto const local_idx{func_index_uz - import_func_count};
                            auto const* const info_ptr{::std::addressof(storage.local_defined_call_info.index_unchecked(local_idx))};
                            call_module_id = SIZE_MAX;
                            call_function_imm = reinterpret_cast<::std::size_t>(info_ptr);
                        }

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        // Conbine must be flushed before `call` because the runtime call bridge requires a fully materialized operand stack.
                        flush_conbine_pending();
#endif

                        if(!is_polymorphic && operand_stack.size() < param_count) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = u8"call";
                            err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                            err.err_selectable.operand_stack_underflow.stack_size_required = param_count;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const stack_size{operand_stack.size()};
                        if(!is_polymorphic && param_count != 0uz && stack_size >= param_count)
                        {
                            for(::std::size_t i{}; i != param_count; ++i)
                            {
                                auto const expected_type{callee_type.parameter.begin[param_count - 1uz - i]};
                                auto const actual_type{operand_stack.index_unchecked(stack_size - 1uz - i).type};
                                if(actual_type != expected_type) [[unlikely]]
                                {
                                    err.err_curr = op_begin;
                                    err.err_selectable.br_value_type_mismatch.op_code_name = u8"call";
                                    err.err_selectable.br_value_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                                    err.err_selectable.br_value_type_mismatch.actual_type = static_cast<wasm_value_type_u>(actual_type);
                                    err.err_code = code_validation_error_code::br_value_type_mismatch;
                                    ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                                }
                            }
                        }

                        // Optional: stack-top fast-path `call` for hot same-type signatures.
                        bool use_stacktop_call_fast{};
                        bool use_stacktop_call0_void_fast{};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        curr_operand_stack_value_type stacktop_call_fast_vt{curr_operand_stack_value_type::i32};

                        if constexpr(stacktop_enabled && CompileOption.is_tail_call)
                        {
                            if(!is_polymorphic)
                            {
                                // Fast path constraints:
                                // - all operand stack values are cached (no memory segment),
                                // - signature: (T x N) -> (T | void) where T is i32/f32/f64 (and some f32<->f64 when merged),
                                // - we only support small N.
                                bool const n_ok{param_count != 0uz && param_count <= 4uz};
                                bool const state_ok{stacktop_memory_count == 0uz && stacktop_cache_count == stack_size && stack_size >= param_count};

                                if(n_ok && state_ok)
                                {
                                    auto const param_vt{callee_type.parameter.begin[0]};
                                    bool all_same_type_params{true};
                                    for(::std::size_t i{}; i != param_count; ++i)
                                    {
                                        if(callee_type.parameter.begin[i] != param_vt)
                                        {
                                            all_same_type_params = false;
                                            break;
                                        }
                                    }

                                    bool const vt_ok{param_vt == value_type_enum::i32 || param_vt == value_type_enum::f32 || param_vt == value_type_enum::f64};

                                    // Fast-path return types:
                                    // - i32  -> i32|void
                                    // - f32  -> f32|void (and optionally f64 when f32/f64 are merged)
                                    // - f64  -> f64|void (and optionally f32 when f32/f64 are merged)
                                    constexpr bool fp_ranges_merged{stacktop_f32_enabled && stacktop_f64_enabled &&
                                                                    CompileOption.f32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                                    CompileOption.f32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                                    bool res_ok{};
                                    if(result_count == 0uz) { res_ok = true; }
                                    else if(result_count == 1uz)
                                    {
                                        auto const ret_vt{callee_type.result.begin[0]};
                                        if(param_vt == value_type_enum::i32) { res_ok = (ret_vt == value_type_enum::i32); }
                                        else if(param_vt == value_type_enum::f32)
                                        {
                                            res_ok = (ret_vt == value_type_enum::f32) || (fp_ranges_merged && ret_vt == value_type_enum::f64);
                                        }
                                        else if(param_vt == value_type_enum::f64)
                                        {
                                            res_ok = (ret_vt == value_type_enum::f64) || (fp_ranges_merged && ret_vt == value_type_enum::f32);
                                        }
                                    }

                                    if(all_same_type_params && res_ok && vt_ok)
                                    {
                                        use_stacktop_call_fast = true;
                                        stacktop_call_fast_vt = param_vt;
                                    }
                                }
                            }
                        }

                        // Special-case: `call` with 0 params and 0 results does not need operand-stack materialization.
                        // If we have no operand-stack memory segment, we can skip the pre-call spill and post-call fill.
                        if constexpr(stacktop_enabled && CompileOption.is_tail_call)
                        {
                            if(!is_polymorphic)
                            {
                                bool const state_ok{stacktop_memory_count == 0uz && stacktop_cache_count == stack_size};
                                if(param_count == 0uz && result_count == 0uz && state_ok) { use_stacktop_call0_void_fast = true; }
                            }
                        }
#endif

                        // Stack-top optimization: default `call` requires all args in operand-stack memory (optable/call.h contract).
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                if(!use_stacktop_call_fast && !use_stacktop_call0_void_fast)
                                {
                                    // Spill all cached values so `type...[1u]` points at the full operand stack.
                                    stacktop_flush_all_to_operand_stack(bytecode);
                                }
                            }
                        }

                        // Translate: `call` bridge (module_id + function_index).
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        bool fuse_call_drop{};
                        bool fuse_call_local_set{};
                        [[maybe_unused]] bool fuse_call_local_tee{};
                        [[maybe_unused]] local_offset_t fused_local_off{};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(allow_call_fusion && result_count == 1uz && code_curr != code_end)
                        {
                            if(use_stacktop_call_fast)
                            {
                                // Stack-top fast-path currently only supports fused `drop` / `local.set` for i32->i32 hot signatures.
                                if(stacktop_call_fast_vt == curr_operand_stack_value_type::i32 &&
                                   callee_type.result.begin[0] == curr_operand_stack_value_type::i32)
                                {
                                    wasm1_code next_op;  // no init
                                    ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));

                                    if(next_op == wasm1_code::drop)
                                    {
                                        fuse_call_drop = true;
                                        ++code_curr;
                                    }
                                    else if(next_op == wasm1_code::local_set)
                                    {
                                        wasm_u32 local_index{};
                                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                        auto const [local_index_next,
                                                    local_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1),
                                                                                              reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                              ::fast_io::mnp::leb128_get(local_index))};
                                        if(local_index_err == ::fast_io::parse_code::ok && local_index < all_local_count)
                                        {
                                            auto const local_type{local_type_from_index(local_index)};
                                            if(local_type == callee_type.result.begin[0])
                                            {
                                                fused_local_off = local_offset_from_index(local_index);
                                                fuse_call_local_set = true;
                                                code_curr = reinterpret_cast<::std::byte const*>(local_index_next);
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                wasm1_code next_op;  // no init
                                ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));

                                if(next_op == wasm1_code::drop)
                                {
                                    fuse_call_drop = true;
                                    ++code_curr;
                                }
                                else if(next_op == wasm1_code::local_set || next_op == wasm1_code::local_tee)
                                {
                                    wasm_u32 local_index{};
                                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                    auto const [local_index_next,
                                                local_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1),
                                                                                          reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                          ::fast_io::mnp::leb128_get(local_index))};
                                    if(local_index_err == ::fast_io::parse_code::ok && local_index < all_local_count)
                                    {
                                        auto const local_type{local_type_from_index(local_index)};

                                        if(local_type == callee_type.result.begin[0])
                                        {
                                            fused_local_off = local_offset_from_index(local_index);
                                            if(next_op == wasm1_code::local_set) { fuse_call_local_set = true; }
                                            else
                                            {
                                                fuse_call_local_tee = true;
                                            }
                                            code_curr = reinterpret_cast<::std::byte const*>(local_index_next);
                                        }
                                    }
                                }
                            }
                        }
#endif

                        auto const result_type_ok{result_count == 1uz && (callee_type.result.begin[0] == curr_operand_stack_value_type::i32 ||
                                                                          callee_type.result.begin[0] == curr_operand_stack_value_type::i64 ||
                                                                          callee_type.result.begin[0] == curr_operand_stack_value_type::f32 ||
                                                                          callee_type.result.begin[0] == curr_operand_stack_value_type::f64)};
                        if(!allow_call_fusion || !result_type_ok)
                        {
                            fuse_call_drop = false;
                            fuse_call_local_set = false;
                            fuse_call_local_tee = false;
                        }

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(use_stacktop_call0_void_fast)
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_call_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, call_module_id);
                            emit_imm_to(bytecode, call_function_imm);
                        }
                        else if(use_stacktop_call_fast)
                        {
                            switch(stacktop_call_fast_vt)
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    if(result_count == 0uz)
                                    {
                                        switch(param_count)
                                        {
                                            case 1uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_i32_fptr_from_tuple<CompileOption, 1uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_i32_fptr_from_tuple<CompileOption, 2uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_i32_fptr_from_tuple<CompileOption, 3uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_i32_fptr_from_tuple<CompileOption, 4uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    else
                                    {
                                        if(fuse_call_drop)
                                        {
                                            switch(param_count)
                                            {
                                                case 1uz:
                                                    emit_opfunc_to(
                                                        bytecode,
                                                        translate::get_uwvmint_call_stacktop_i32_drop_fptr_from_tuple<CompileOption, 1uz>(curr_stacktop,
                                                                                                                                          interpreter_tuple));
                                                    break;
                                                case 2uz:
                                                    emit_opfunc_to(
                                                        bytecode,
                                                        translate::get_uwvmint_call_stacktop_i32_drop_fptr_from_tuple<CompileOption, 2uz>(curr_stacktop,
                                                                                                                                          interpreter_tuple));
                                                    break;
                                                case 3uz:
                                                    emit_opfunc_to(
                                                        bytecode,
                                                        translate::get_uwvmint_call_stacktop_i32_drop_fptr_from_tuple<CompileOption, 3uz>(curr_stacktop,
                                                                                                                                          interpreter_tuple));
                                                    break;
                                                case 4uz:
                                                    emit_opfunc_to(
                                                        bytecode,
                                                        translate::get_uwvmint_call_stacktop_i32_drop_fptr_from_tuple<CompileOption, 4uz>(curr_stacktop,
                                                                                                                                          interpreter_tuple));
                                                    break;
                                                [[unlikely]] default:
                                                    ::fast_io::fast_terminate();
                                            }
                                        }
                                        else if(fuse_call_local_set)
                                        {
                                            switch(param_count)
                                            {
                                                case 1uz:
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_call_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 1uz>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    break;
                                                case 2uz:
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_call_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 2uz>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    break;
                                                case 3uz:
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_call_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 3uz>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    break;
                                                case 4uz:
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_call_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 4uz>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    break;
                                                [[unlikely]] default:
                                                    ::fast_io::fast_terminate();
                                            }
                                        }
                                        else
                                        {
                                            switch(param_count)
                                            {
                                                case 1uz:
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_call_stacktop_i32_fptr_from_tuple<CompileOption, 1uz, wasm_i32>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    break;
                                                case 2uz:
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_call_stacktop_i32_fptr_from_tuple<CompileOption, 2uz, wasm_i32>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    break;
                                                case 3uz:
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_call_stacktop_i32_fptr_from_tuple<CompileOption, 3uz, wasm_i32>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    break;
                                                case 4uz:
                                                    emit_opfunc_to(bytecode,
                                                                   translate::get_uwvmint_call_stacktop_i32_fptr_from_tuple<CompileOption, 4uz, wasm_i32>(
                                                                       curr_stacktop,
                                                                       interpreter_tuple));
                                                    break;
                                                [[unlikely]] default:
                                                    ::fast_io::fast_terminate();
                                            }
                                        }
                                    }
                                    break;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    if(result_count == 0uz)
                                    {
                                        switch(param_count)
                                        {
                                            case 1uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 1uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 2uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 3uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 4uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    else if(callee_type.result.begin[0] == curr_operand_stack_value_type::f32)
                                    {
                                        switch(param_count)
                                        {
                                            case 1uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 1uz, wasm_f32>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 2uz, wasm_f32>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 3uz, wasm_f32>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 4uz, wasm_f32>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    else
                                    {
                                        // f32 -> f64 (requires merged fp ranges; enforced in selector/opfunc static_asserts)
                                        switch(param_count)
                                        {
                                            case 1uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 1uz, wasm_f64>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 2uz, wasm_f64>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 3uz, wasm_f64>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f32_fptr_from_tuple<CompileOption, 4uz, wasm_f64>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    break;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    if(result_count == 0uz)
                                    {
                                        switch(param_count)
                                        {
                                            case 1uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 1uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 2uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 3uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 4uz, void>(curr_stacktop,
                                                                                                                                       interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    else if(callee_type.result.begin[0] == curr_operand_stack_value_type::f64)
                                    {
                                        switch(param_count)
                                        {
                                            case 1uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 1uz, wasm_f64>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 2uz, wasm_f64>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 3uz, wasm_f64>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 4uz, wasm_f64>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    else
                                    {
                                        // f64 -> f32 (requires merged fp ranges; enforced in selector/opfunc static_asserts)
                                        switch(param_count)
                                        {
                                            case 1uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 1uz, wasm_f32>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 2uz, wasm_f32>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 3uz, wasm_f32>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(
                                                    bytecode,
                                                    translate::get_uwvmint_call_stacktop_f64_fptr_from_tuple<CompileOption, 4uz, wasm_f32>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    break;
                                }
                                [[unlikely]] default:
                                {
# if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
# endif
                                    ::fast_io::fast_terminate();
                                }
                            }

                            emit_imm_to(bytecode, call_module_id);
                            emit_imm_to(bytecode, call_function_imm);
                            if(fuse_call_local_set || fuse_call_local_tee) { emit_imm_to(bytecode, fused_local_off); }
                        }
                        else if(fuse_call_drop || fuse_call_local_set || fuse_call_local_tee)
                        {
                            switch(callee_type.result.begin[0])
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    if(fuse_call_drop)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_drop_fptr_from_tuple<CompileOption, wasm_i32>(curr_stacktop, interpreter_tuple));
                                    }
                                    else if(fuse_call_local_set)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_local_set_fptr_from_tuple<CompileOption, wasm_i32>(curr_stacktop, interpreter_tuple));
                                    }
                                    else
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_local_tee_fptr_from_tuple<CompileOption, wasm_i32>(curr_stacktop, interpreter_tuple));
                                    }
                                    break;
                                }
                                case curr_operand_stack_value_type::i64:
                                {
                                    if(fuse_call_drop)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_drop_fptr_from_tuple<CompileOption, wasm_i64>(curr_stacktop, interpreter_tuple));
                                    }
                                    else if(fuse_call_local_set)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_local_set_fptr_from_tuple<CompileOption, wasm_i64>(curr_stacktop, interpreter_tuple));
                                    }
                                    else
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_local_tee_fptr_from_tuple<CompileOption, wasm_i64>(curr_stacktop, interpreter_tuple));
                                    }
                                    break;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    if(fuse_call_drop)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_drop_fptr_from_tuple<CompileOption, wasm_f32>(curr_stacktop, interpreter_tuple));
                                    }
                                    else if(fuse_call_local_set)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_local_set_fptr_from_tuple<CompileOption, wasm_f32>(curr_stacktop, interpreter_tuple));
                                    }
                                    else
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_local_tee_fptr_from_tuple<CompileOption, wasm_f32>(curr_stacktop, interpreter_tuple));
                                    }
                                    break;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    if(fuse_call_drop)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_drop_fptr_from_tuple<CompileOption, wasm_f64>(curr_stacktop, interpreter_tuple));
                                    }
                                    else if(fuse_call_local_set)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_local_set_fptr_from_tuple<CompileOption, wasm_f64>(curr_stacktop, interpreter_tuple));
                                    }
                                    else
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_call_local_tee_fptr_from_tuple<CompileOption, wasm_f64>(curr_stacktop, interpreter_tuple));
                                    }
                                    break;
                                }
                                [[unlikely]] default:
                                {
# if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
# endif
                                    emit_opfunc_to(bytecode, translate::get_uwvmint_call_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    fuse_call_drop = false;
                                    fuse_call_local_set = false;
                                    fuse_call_local_tee = false;
                                    break;
                                }
                            }

                            emit_imm_to(bytecode, call_module_id);
                            emit_imm_to(bytecode, call_function_imm);
                            if(fuse_call_local_set || fuse_call_local_tee) { emit_imm_to(bytecode, fused_local_off); }
                        }
                        else
#endif
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_call_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, call_module_id);
                            emit_imm_to(bytecode, call_function_imm);
                        }

                        // Update the validation operand stack after the `call` is encoded.
                        if(param_count != 0uz) { operand_stack_pop_n(param_count); }
                        ::std::size_t const effective_result_count{(fuse_call_drop || fuse_call_local_set) ? 0uz : result_count};
                        if(effective_result_count != 0uz)
                        {
                            for(::std::size_t i{}; i != effective_result_count; ++i) { operand_stack_push(callee_type.result.begin[i]); }
                        }

                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                if(use_stacktop_call_fast || use_stacktop_call0_void_fast)
                                {
                                    // Fast path: call consumes cached params and produces cached result (if any).
                                    stacktop_commit_pop_n(param_count);
                                    codegen_stack_pop_n(param_count);

                                    for(::std::size_t i{}; i != effective_result_count; ++i)
                                    {
                                        stacktop_commit_push1_typed(callee_type.result.begin[i]);
                                        codegen_stack_push(callee_type.result.begin[i]);
                                    }
                                }
                                else
                                {
                                    // Slow path: model call stack effect on the memory-only operand stack (cache is empty after the pre-call spill).
                                    // Pop params (from memory stack): advance per-type cursors and adjust memory_count.
                                    stacktop_commit_pop_n(param_count);
                                    codegen_stack_pop_n(param_count);

                                    // Push results back to the memory stack (call bridge contract).
                                    auto const stacktop_commit_push1_to_memory{[&](curr_operand_stack_value_type vt) constexpr noexcept
                                                                               {
                                                                                   ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                                                                                   ::std::size_t const end_pos{stacktop_range_end_pos(vt)};
                                                                                   ::std::size_t const currpos{stacktop_currpos_for_range(begin_pos, end_pos)};
                                                                                   ::std::size_t const new_pos{stacktop_ring_prev(currpos, begin_pos, end_pos)};
                                                                                   stacktop_set_currpos_for_range(begin_pos, end_pos, new_pos);
                                                                                   ++stacktop_memory_count;
                                                                               }};

                                    for(::std::size_t i{}; i != effective_result_count; ++i)
                                    {
                                        codegen_stack_push(callee_type.result.begin[i]);
                                        stacktop_commit_push1_to_memory(callee_type.result.begin[i]);
                                    }

                                    // Call leaves cache empty; restore canonical cache after the call returns.
                                    stacktop_cache_count = 0uz;
                                    stacktop_cache_i32_count = 0uz;
                                    stacktop_cache_i64_count = 0uz;
                                    stacktop_cache_f32_count = 0uz;
                                    stacktop_cache_f64_count = 0uz;

                                    // Restore canonical cache after the call returns.
                                    stacktop_fill_to_canonical(bytecode);
                                }
                            }
                        }

                        break;
                    }
                    case wasm1_code::call_indirect:
                    {
                        // call_indirect  type_index table_index ...
                        // [ safe      ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // call_indirect  type_index table_index ...
                        // [ safe      ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // call_indirect type_index table_index ...
                        // [    safe   ] unsafe (could be the section_end)
                        //               ^^ code_curr

                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;

                        wasm_u32 type_index;
                        auto const [type_next, type_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                  reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                  ::fast_io::mnp::leb128_get(type_index))};
                        if(type_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_type_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(type_err);
                        }

                        // call_indirect type_index table_index ...
                        // [          safe        ] unsafe (could be the section_end)
                        //               ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(type_next);

                        // call_indirect type_index table_index ...
                        // [          safe        ] unsafe (could be the section_end)
                        //                          ^^ code_curr

                        wasm_u32 table_index;
                        auto const [table_next, table_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                    reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                    ::fast_io::mnp::leb128_get(table_index))};
                        if(table_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_table_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(table_err);
                        }

                        // call_indirect type_index table_index ...
                        // [                safe              ] unsafe (could be the section_end)
                        //                          ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(table_next);

                        // call_indirect type_index table_index ...
                        // [                safe              ] unsafe (could be the section_end)
                        //                                      ^^ code_curr

                        if(table_index >= all_table_count) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_table_index.table_index = table_index;
                            err.err_selectable.illegal_table_index.all_table_count = all_table_count;
                            err.err_code = code_validation_error_code::illegal_table_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto types_begin{curr_module.type_section_storage.type_section_begin};
                        auto types_end{curr_module.type_section_storage.type_section_end};

                        auto const all_type_count_uz{static_cast<::std::size_t>(types_end - types_begin)};
                        if(static_cast<::std::size_t>(type_index) >= all_type_count_uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_type_index.type_index = type_index;
                            err.err_selectable.illegal_type_index.all_type_count = static_cast<wasm_u32>(all_type_count_uz);
                            err.err_code = code_validation_error_code::illegal_type_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const& callee_type{types_begin[static_cast<::std::size_t>(type_index)]};
                        auto const param_count{static_cast<::std::size_t>(callee_type.parameter.end - callee_type.parameter.begin)};
                        auto const result_count{static_cast<::std::size_t>(callee_type.result.end - callee_type.result.begin)};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        // Conbine must be flushed before `call_indirect` because the runtime call bridge requires a fully materialized operand stack.
                        flush_conbine_pending();
#endif

                        if(!is_polymorphic && operand_stack.size() < param_count + 1uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = u8"call_indirect";
                            err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                            err.err_selectable.operand_stack_underflow.stack_size_required = param_count + 1uz;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(!operand_stack.empty())
                        {
                            auto const idx{operand_stack.back_unchecked()};
                            if(!is_polymorphic && idx.type != curr_operand_stack_value_type::i32) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.br_cond_type_not_i32.op_code_name = u8"call_indirect";
                                err.err_selectable.br_cond_type_not_i32.cond_type = static_cast<wasm_value_type_u>(idx.type);
                                err.err_code = code_validation_error_code::br_cond_type_not_i32;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        // Stack layout (validated above): [args..., idx]
                        auto const stack_size{operand_stack.size()};
                        auto const arg_stack_size{stack_size == 0uz ? 0uz : (stack_size - 1uz)};
                        if(!is_polymorphic && param_count != 0uz && arg_stack_size >= param_count)
                        {
                            for(::std::size_t i{}; i != param_count; ++i)
                            {
                                auto const expected_type{callee_type.parameter.begin[param_count - 1uz - i]};
                                auto const actual_type{operand_stack.index_unchecked(arg_stack_size - 1uz - i).type};
                                if(actual_type != expected_type) [[unlikely]]
                                {
                                    err.err_curr = op_begin;
                                    err.err_selectable.br_value_type_mismatch.op_code_name = u8"call_indirect";
                                    err.err_selectable.br_value_type_mismatch.expected_type = static_cast<wasm_value_type_u>(expected_type);
                                    err.err_selectable.br_value_type_mismatch.actual_type = static_cast<wasm_value_type_u>(actual_type);
                                    err.err_code = code_validation_error_code::br_value_type_mismatch;
                                    ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                                }
                            }
                        }

                        // Optional: stack-top fast-path `call_indirect` for hot i32 signatures.
                        bool use_stacktop_call_indirect_fast{};
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        bool fuse_call_indirect_drop{};
                        bool fuse_call_indirect_local_set{};
                        [[maybe_unused]] local_offset_t fused_local_off{};
#endif
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if constexpr(stacktop_enabled && CompileOption.is_tail_call)
                        {
                            if(!is_polymorphic)
                            {
                                bool const n_ok{param_count <= 4uz};
                                bool const state_ok{stacktop_memory_count == 0uz && stacktop_cache_count == stack_size && stack_size >= (param_count + 1uz)};

                                if(n_ok && state_ok)
                                {
                                    bool all_i32_params{true};
                                    for(::std::size_t i{}; i != param_count; ++i)
                                    {
                                        if(callee_type.parameter.begin[i] != value_type_enum::i32)
                                        {
                                            all_i32_params = false;
                                            break;
                                        }
                                    }

                                    bool res_ok{result_count == 0uz};
                                    if(result_count == 1uz) { res_ok = (callee_type.result.begin[0] == value_type_enum::i32); }

                                    if(all_i32_params && res_ok) { use_stacktop_call_indirect_fast = true; }
                                }
                            }
                        }

                        // Optional fusion: `call_indirect (i32...) -> i32` + `drop`/`local.set`.
                        // Only valid when stack-top fast-path is used (selector+params in cache; no spill) and result is i32.
                        if constexpr(stacktop_enabled && CompileOption.is_tail_call)
                        {
                            if(use_stacktop_call_indirect_fast && result_count == 1uz && callee_type.result.begin[0] == value_type_enum::i32)
                            {
                                if(code_curr != code_end)
                                {
                                    wasm1_code next_op;  // no init
                                    ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));

                                    if(next_op == wasm1_code::drop)
                                    {
                                        fuse_call_indirect_drop = true;
                                        ++code_curr;
                                    }
                                    else if(next_op == wasm1_code::local_set)
                                    {
                                        wasm_u32 local_index{};
                                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                        auto const [local_index_next,
                                                    local_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1),
                                                                                              reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                              ::fast_io::mnp::leb128_get(local_index))};
                                        if(local_index_err == ::fast_io::parse_code::ok && local_index < all_local_count)
                                        {
                                            auto const local_type{local_type_from_index(local_index)};
                                            if(local_type == value_type_enum::i32)
                                            {
                                                fused_local_off = local_offset_from_index(local_index);
                                                fuse_call_indirect_local_set = true;
                                                code_curr = reinterpret_cast<::std::byte const*>(local_index_next);
                                            }
                                        }
                                    }
                                }
                            }
                        }
#endif

                        // Stack-top optimization: default `call_indirect` requires all args and the selector index in operand-stack memory (optable/call.h
                        // contract).
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                if(!use_stacktop_call_indirect_fast)
                                {
                                    // Spill all cached values so `type...[1u]` points at the full operand stack.
                                    stacktop_flush_all_to_operand_stack(bytecode);
                                }
                            }
                        }

                        // Translate: `call_indirect` bridge (module_id + type_index + table_index).
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        auto const emit_call_indirect_normal{
                            [&]() noexcept
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_call_indirect_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, options.curr_wasm_id);
                                emit_imm_to(bytecode, static_cast<::std::size_t>(type_index));
                                emit_imm_to(bytecode, static_cast<::std::size_t>(table_index));
                            }};
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if constexpr(CompileOption.is_tail_call)
                        {
                            if(use_stacktop_call_indirect_fast)
                            {
                                if(result_count == 0uz)
                                {
                                    switch(param_count)
                                    {
                                        case 0uz:
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 0uz, void>(curr_stacktop,
                                                                                                                                            interpreter_tuple));
                                            break;
                                        case 1uz:
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 1uz, void>(curr_stacktop,
                                                                                                                                            interpreter_tuple));
                                            break;
                                        case 2uz:
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 2uz, void>(curr_stacktop,
                                                                                                                                            interpreter_tuple));
                                            break;
                                        case 3uz:
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 3uz, void>(curr_stacktop,
                                                                                                                                            interpreter_tuple));
                                            break;
                                        case 4uz:
                                            emit_opfunc_to(
                                                bytecode,
                                                translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 4uz, void>(curr_stacktop,
                                                                                                                                            interpreter_tuple));
                                            break;
                                        [[unlikely]] default:
                                            ::fast_io::fast_terminate();
                                    }
                                }
                                else
                                {
                                    // i32 -> i32
                                    if(fuse_call_indirect_drop)
                                    {
                                        switch(param_count)
                                        {
                                            case 0uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_drop_fptr_from_tuple<CompileOption, 0uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 1uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_drop_fptr_from_tuple<CompileOption, 1uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_drop_fptr_from_tuple<CompileOption, 2uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_drop_fptr_from_tuple<CompileOption, 3uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_drop_fptr_from_tuple<CompileOption, 4uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    else if(fuse_call_indirect_local_set)
                                    {
                                        switch(param_count)
                                        {
                                            case 0uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 0uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 1uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 1uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 2uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 3uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_local_set_fptr_from_tuple<CompileOption, 4uz>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                    else
                                    {
                                        switch(param_count)
                                        {
                                            case 0uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 0uz, wasm_i32>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 1uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 1uz, wasm_i32>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 2uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 2uz, wasm_i32>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 3uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 3uz, wasm_i32>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            case 4uz:
                                                emit_opfunc_to(bytecode,
                                                               translate::get_uwvmint_call_indirect_stacktop_i32_fptr_from_tuple<CompileOption, 4uz, wasm_i32>(
                                                                   curr_stacktop,
                                                                   interpreter_tuple));
                                                break;
                                            [[unlikely]] default:
                                                ::fast_io::fast_terminate();
                                        }
                                    }
                                }

                                emit_imm_to(bytecode, options.curr_wasm_id);
                                emit_imm_to(bytecode, static_cast<::std::size_t>(type_index));
                                emit_imm_to(bytecode, static_cast<::std::size_t>(table_index));
                                if(fuse_call_indirect_local_set) { emit_imm_to(bytecode, fused_local_off); }
                            }
                            else
                            {
                                emit_call_indirect_normal();
                            }
                        }
                        else
#endif
                        {
                            emit_call_indirect_normal();
                        }

                        // Update the validation operand stack after the `call_indirect` is encoded.
                        operand_stack_pop_unchecked();  // pop selector index
                        if(param_count != 0uz) { operand_stack_pop_n(param_count); }
                        ::std::size_t effective_result_count{result_count};
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if constexpr(CompileOption.is_tail_call)
                        {
                            if(use_stacktop_call_indirect_fast && (fuse_call_indirect_drop || fuse_call_indirect_local_set)) { effective_result_count = 0uz; }
                        }
#endif
                        if(effective_result_count != 0uz)
                        {
                            for(::std::size_t i{}; i != effective_result_count; ++i) { operand_stack_push(callee_type.result.begin[i]); }
                        }

                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                ::std::size_t const pop_count{param_count + 1uz};
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                                if(use_stacktop_call_indirect_fast)
                                {
                                    // Fast path: indirect call consumes cached selector+params and produces cached result (if any).
                                    stacktop_commit_pop_n(pop_count);
                                    codegen_stack_pop_n(pop_count);

                                    ::std::size_t effective_stacktop_result_count{result_count};
                                    if(fuse_call_indirect_drop || fuse_call_indirect_local_set) { effective_stacktop_result_count = 0uz; }
                                    for(::std::size_t i{}; i != effective_stacktop_result_count; ++i)
                                    {
                                        stacktop_commit_push1_typed(callee_type.result.begin[i]);
                                        codegen_stack_push(callee_type.result.begin[i]);
                                    }
                                }
                                else
#endif
                                {
                                    // Slow path: model call_indirect stack effect on the memory-only operand stack (cache is empty after the pre-call spill).
                                    stacktop_commit_pop_n(pop_count);
                                    codegen_stack_pop_n(pop_count);

                                    // Push results back to the memory stack (call bridge contract).
                                    auto const stacktop_commit_push1_to_memory{[&](curr_operand_stack_value_type vt) constexpr noexcept
                                                                               {
                                                                                   ::std::size_t const begin_pos{stacktop_range_begin_pos(vt)};
                                                                                   ::std::size_t const end_pos{stacktop_range_end_pos(vt)};
                                                                                   ::std::size_t const currpos{stacktop_currpos_for_range(begin_pos, end_pos)};
                                                                                   ::std::size_t const new_pos{stacktop_ring_prev(currpos, begin_pos, end_pos)};
                                                                                   stacktop_set_currpos_for_range(begin_pos, end_pos, new_pos);
                                                                                   ++stacktop_memory_count;
                                                                               }};

                                    for(::std::size_t i{}; i != result_count; ++i)
                                    {
                                        codegen_stack_push(callee_type.result.begin[i]);
                                        stacktop_commit_push1_to_memory(callee_type.result.begin[i]);
                                    }

                                    stacktop_cache_count = 0uz;
                                    stacktop_cache_i32_count = 0uz;
                                    stacktop_cache_i64_count = 0uz;
                                    stacktop_cache_f32_count = 0uz;
                                    stacktop_cache_f64_count = 0uz;

                                    stacktop_fill_to_canonical(bytecode);
                                }
                            }
                        }

                        break;
                    }
                    case wasm1_code::drop:
                    {
                        // drop   ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // drop   ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ op_begin

                        ++code_curr;

                        // drop   ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        bool have_drop_operand{};
                        curr_operand_stack_value_type drop_operand_type{};

                        if(operand_stack.empty()) [[unlikely]]
                        {
                            if(!is_polymorphic)
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.operand_stack_underflow.op_code_name = u8"drop";
                                err.err_selectable.operand_stack_underflow.stack_size_actual = 0uz;
                                err.err_selectable.operand_stack_underflow.stack_size_required = 1uz;
                                err.err_code = code_validation_error_code::operand_stack_underflow;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }
                        else
                        {
                            have_drop_operand = true;
                            drop_operand_type = operand_stack.back_unchecked().type;
                            operand_stack_pop_unchecked();
                        }

                        // Translate: typed `drop`.
                        if(have_drop_operand) { emit_drop_typed_to(bytecode, drop_operand_type); }

                        break;
                    }
                    case wasm1_code::select:
                    {
                        // select ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // select ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // select ...
                        // [safe] unsafe (could be the section_end)
                        //        ^^ code_curr

                        if(!is_polymorphic && operand_stack.size() < 3uz) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.operand_stack_underflow.op_code_name = u8"select";
                            err.err_selectable.operand_stack_underflow.stack_size_actual = operand_stack.size();
                            err.err_selectable.operand_stack_underflow.stack_size_required = 3uz;
                            err.err_code = code_validation_error_code::operand_stack_underflow;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        bool cond_from_stack{};
                        curr_operand_stack_value_type cond_type{};
                        if(!operand_stack.empty())
                        {
                            auto const cond{operand_stack.back_unchecked()};
                            operand_stack_pop_unchecked();
                            cond_from_stack = true;
                            cond_type = cond.type;
                        }

                        if(cond_from_stack && cond_type != curr_operand_stack_value_type::i32) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.select_cond_type_not_i32.cond_type = cond_type;
                            err.err_code = code_validation_error_code::select_cond_type_not_i32;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        bool v2_from_stack{};
                        curr_operand_stack_value_type v2_type{};
                        if(!operand_stack.empty())
                        {
                            auto const v2{operand_stack.back_unchecked()};
                            operand_stack_pop_unchecked();
                            v2_from_stack = true;
                            v2_type = v2.type;
                        }

                        bool v1_from_stack{};
                        curr_operand_stack_value_type v1_type{};
                        if(!operand_stack.empty())
                        {
                            auto const v1{operand_stack.back_unchecked()};
                            v1_from_stack = true;
                            v1_type = v1.type;
                        }

                        if(v1_from_stack && v2_from_stack && v1_type != v2_type) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.select_type_mismatch.type_v1 = v1_type;
                            err.err_selectable.select_type_mismatch.type_v2 = v2_type;
                            err.err_code = code_validation_error_code::select_type_mismatch;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        // Translate: typed `select`.
                        if(v1_from_stack)
                        {
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                            if(conbine_pending.kind == conbine_pending_kind::select_localget3 && v1_type == conbine_pending.vt &&
                               (v1_type == curr_operand_stack_value_type::i32 || v1_type == curr_operand_stack_value_type::f32))
                            {
                                conbine_pending.kind = conbine_pending_kind::select_after_select;
                                break;
                            }
#endif
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            switch(v1_type)
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_select_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case curr_operand_stack_value_type::i64:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_select_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_select_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_select_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                [[unlikely]] default:
                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                    break;
                                }
                            }
                        }

                        // Stack-top cache model: `select` consumes (v2, cond) and keeps v1 (net -2).
                        if(v1_from_stack) { stacktop_after_pop_n_if_reachable(bytecode, 2uz); }

                        if(!v1_from_stack && v2_from_stack) { operand_stack_push(v2_type); }

                        break;
                    }
                    case wasm1_code::local_get:
                    {
                        // local.get ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // local.get ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // local.get local_index ...
                        // [ safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        wasm_u32 local_index;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [local_index_next, local_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                                ::fast_io::mnp::leb128_get(local_index))};
                        if(local_index_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_local_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(local_index_err);
                        }

                        // local.get local_index ...
                        // [     safe          ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(local_index_next);

                        // local.get local_index ...
                        // [     safe          ] unsafe (could be the section_end)
                        //                       ^^ code_curr

                        if(local_index >= all_local_count) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_local_index.local_index = local_index;
                            err.err_selectable.illegal_local_index.all_local_count = all_local_count;
                            err.err_code = code_validation_error_code::illegal_local_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const curr_local_type{local_type_from_index(local_index)};

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        // Heavy combine: `local.get` xN + `add` x(N-1) -> one fused "add-reduce" opfunc (push 1).
                        // This eliminates deep stack spill/fill traffic for large local-get expression trees (e.g. `stack_spill_*` benches).
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::none &&
                           (curr_local_type == curr_operand_stack_value_type::i32 || curr_local_type == curr_operand_stack_value_type::i64 ||
                            curr_local_type == curr_operand_stack_value_type::f64))
                        {
                            wasm1_code const add_op{curr_local_type == curr_operand_stack_value_type::i32   ? wasm1_code::i32_add
                                                    : curr_local_type == curr_operand_stack_value_type::i64 ? wasm1_code::i64_add
                                                                                                            : wasm1_code::f64_add};

                            auto const try_add_reduce{
                                [&](::std::size_t want) constexpr UWVM_THROWS -> bool
                                {
                                    ::std::array<local_offset_t, 12uz> offs{};  // max (f64)
                                    offs[0] = local_offset_from_index(local_index);

                                    ::std::byte const* scan{code_curr};
                                    bool ok{true};

                                    // Parse the remaining `local.get`s.
                                    for(::std::size_t i{1uz}; i < want; ++i)
                                    {
                                        if(scan == code_end)
                                        {
                                            ok = false;
                                            break;
                                        }

                                        wasm1_code op{};  // init
                                        ::std::memcpy(::std::addressof(op), scan, sizeof(op));
                                        if(op != wasm1_code::local_get)
                                        {
                                            ok = false;
                                            break;
                                        }

                                        wasm_u32 next_local_index{};
                                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                        auto const [next_local_index_next,
                                                    next_local_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(scan + 1u),
                                                                                                   reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                                   ::fast_io::mnp::leb128_get(next_local_index))};
                                        if(next_local_index_err != ::fast_io::parse_code::ok || next_local_index >= all_local_count ||
                                           local_type_from_index(next_local_index) != curr_local_type)
                                        {
                                            ok = false;
                                            break;
                                        }

                                        offs[i] = local_offset_from_index(next_local_index);
                                        scan = reinterpret_cast<::std::byte const*>(next_local_index_next);
                                    }

                                    // Parse the trailing adds.
                                    for(::std::size_t i{}; ok && i + 1uz < want; ++i)
                                    {
                                        if(scan == code_end)
                                        {
                                            ok = false;
                                            break;
                                        }
                                        wasm1_code op{};  // init
                                        ::std::memcpy(::std::addressof(op), scan, sizeof(op));
                                        if(op != add_op)
                                        {
                                            ok = false;
                                            break;
                                        }
                                        ++scan;
                                    }

                                    if(!ok) { return false; }

                                    // Net stack effect: push 1 value of `curr_local_type`.
                                    operand_stack_push(curr_local_type);

                                    // Ensure locals read by this fusion are covered by the zero-init prefix.
                                    auto const local_size{operand_stack_valtype_size(curr_local_type)};
                                    if(local_size != 0uz)
                                    {
                                        for(::std::size_t i{}; i < want; ++i)
                                        {
                                            auto const end_off{static_cast<local_offset_t>(offs[i] + local_size)};
                                            if(end_off > local_bytes_zeroinit_end) { local_bytes_zeroinit_end = end_off; }
                                        }
                                    }

                                    stacktop_prepare_push1_if_reachable(bytecode, curr_local_type);
                                    namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                                    if(curr_local_type == curr_operand_stack_value_type::i32)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_i32_add_reduce_8localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    }
                                    else if(curr_local_type == curr_operand_stack_value_type::i64)
                                    {
                                        emit_opfunc_to(
                                            bytecode,
                                            translate::get_uwvmint_i64_add_reduce_8localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    }
                                    else
                                    {
                                        if(want == 12uz)
                                        {
                                            emit_opfunc_to(bytecode,
                                                           translate::get_uwvmint_f64_add_reduce_12localget_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                           interpreter_tuple));
                                        }
                                        else
                                        {
                                            emit_opfunc_to(bytecode,
                                                           translate::get_uwvmint_f64_add_reduce_7localget_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                          interpreter_tuple));
                                        }
                                    }

                                    for(::std::size_t i{}; i < want; ++i) { emit_imm_to(bytecode, offs[i]); }
                                    stacktop_commit_push1_typed_if_reachable(curr_local_type);

                                    code_curr = scan;
                                    return true;
                                }};

                            if(curr_local_type == curr_operand_stack_value_type::f64)
                            {
                                if(try_add_reduce(12uz) || try_add_reduce(7uz)) { break; }
                            }
                            else
                            {
                                if(try_add_reduce(8uz)) { break; }
                            }
                        }
#endif

                        operand_stack_push(curr_local_type);

                        auto const local_off{local_offset_from_index(local_index)};
                        {
                            auto const local_size{operand_stack_valtype_size(curr_local_type)};
                            if(local_size != 0uz)
                            {
                                auto const end_off{static_cast<local_offset_t>(local_off + local_size)};
                                if(end_off > local_bytes_zeroinit_end) { local_bytes_zeroinit_end = end_off; }
                            }
                        }
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        // Conbine: delay `local.get` emission to enable `local.get + ...` fusions.
                        switch(conbine_pending.kind)
                        {
                            case conbine_pending_kind::none:
                            {
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
                            case conbine_pending_kind::local_get:
                            {
                                if(conbine_pending.vt == curr_local_type)
                                {
                                    conbine_pending.kind = conbine_pending_kind::local_get2;
                                    conbine_pending.off2 = local_off;
                                }
                                else
                                {
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                    // Heavy (test8 hot loop): start `local.get(f64); local.get(i32); i32.const ...` fusion chain.
                                    if(!is_polymorphic && conbine_pending.vt == curr_operand_stack_value_type::f64 &&
                                       curr_local_type == curr_operand_stack_value_type::i32)
                                    {
                                        wasm1_code next_op{};  // init
                                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op)); }
                                        if(next_op == wasm1_code::i32_const)
                                        {
                                            conbine_pending.kind = conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_gets;
                                            conbine_pending.off2 = local_off;
                                            break;
                                        }
                                    }
# endif
                                    flush_conbine_pending();
                                    conbine_pending.kind = conbine_pending_kind::local_get;
                                    conbine_pending.vt = curr_local_type;
                                    conbine_pending.off1 = local_off;
                                }
                                break;
                            }
                            case conbine_pending_kind::local_get2:
                            {
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                // Heavy: `local.get a; local.get b; local.get cond; select` and `local.get acc; local.get x; local.get y; mul; add; local.set
                                // acc`. Lookahead is safe: `code_curr` already points to the next opcode.
                                if(code_curr != code_end)
                                {
                                    wasm1_code next_op;  // no init
                                    ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));

                                    if(next_op == wasm1_code::select)
                                    {
                                        if((conbine_pending.vt == curr_operand_stack_value_type::i32 &&
                                            curr_local_type == curr_operand_stack_value_type::i32) ||
                                           (conbine_pending.vt == curr_operand_stack_value_type::f32 && curr_local_type == curr_operand_stack_value_type::i32))
                                        {
                                            conbine_pending.kind = conbine_pending_kind::select_localget3;
                                            conbine_pending.off3 = local_off;
                                            break;
                                        }
                                    }

                                    bool mac_candidate{};
                                    if(conbine_pending.vt == curr_operand_stack_value_type::i32 && curr_local_type == curr_operand_stack_value_type::i32 &&
                                       next_op == wasm1_code::i32_mul)
                                    {
                                        mac_candidate = true;
                                    }
                                    else if(conbine_pending.vt == curr_operand_stack_value_type::i64 && curr_local_type == curr_operand_stack_value_type::i64 &&
                                            next_op == wasm1_code::i64_mul)
                                    {
                                        mac_candidate = true;
                                    }
                                    else if(conbine_pending.vt == curr_operand_stack_value_type::f32 && curr_local_type == curr_operand_stack_value_type::f32 &&
                                            next_op == wasm1_code::f32_mul)
                                    {
                                        mac_candidate = true;
                                    }
                                    else if(conbine_pending.vt == curr_operand_stack_value_type::f64 && curr_local_type == curr_operand_stack_value_type::f64 &&
                                            next_op == wasm1_code::f64_mul)
                                    {
                                        mac_candidate = true;
                                    }

                                    if(mac_candidate)
                                    {
                                        conbine_pending.kind = conbine_pending_kind::mac_localget3;
                                        conbine_pending.off3 = local_off;
                                        break;
                                    }
                                }
# endif

                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
                            case conbine_pending_kind::local_get_const_i32_add:
                            {
                                if(curr_local_type == curr_operand_stack_value_type::i32
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                   || curr_local_type == curr_operand_stack_value_type::f32 || curr_local_type == curr_operand_stack_value_type::f64
# endif
                                )
                                {
                                    conbine_pending.kind = conbine_pending_kind::local_get_const_i32_add_localget;
                                    conbine_pending.vt = curr_local_type;
                                    conbine_pending.off2 = local_off;
                                    break;
                                }

                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
                            case conbine_pending_kind::local_get_const_i32_add_localget:
                            {
                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                            case conbine_pending_kind::const_f32:
                            {
                                if(curr_local_type == curr_operand_stack_value_type::f32)
                                {
                                    conbine_pending.kind = conbine_pending_kind::const_f32_localget;
                                    conbine_pending.off1 = local_off;
                                    conbine_pending.vt = curr_operand_stack_value_type::f32;
                                    break;
                                }

                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
                            case conbine_pending_kind::float_mul_2localget:
                            {
                                if(conbine_pending.vt == curr_local_type &&
                                   (curr_local_type == curr_operand_stack_value_type::f32 || curr_local_type == curr_operand_stack_value_type::f64))
                                {
                                    conbine_pending.kind = conbine_pending_kind::float_mul_2localget_local3;
                                    conbine_pending.off3 = local_off;
                                    break;
                                }

                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
                            case conbine_pending_kind::float_mul_2localget_local3:
                            {
                                if(conbine_pending.vt == curr_local_type &&
                                   (curr_local_type == curr_operand_stack_value_type::f32 || curr_local_type == curr_operand_stack_value_type::f64))
                                {
                                    conbine_pending.kind = conbine_pending_kind::float_2mul_wait_second_mul;
                                    conbine_pending.off4 = local_off;
                                    break;
                                }

                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }

#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                            case conbine_pending_kind::for_ptr_inc_after_tee:
                            {
                                if(curr_local_type == curr_operand_stack_value_type::i32)
                                {
                                    conbine_pending.kind = conbine_pending_kind::for_ptr_inc_after_pend_get;
                                    conbine_pending.off2 = local_off;
                                    break;
                                }

                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
#  endif

                            case conbine_pending_kind::xorshift_after_xor1:
                            {
                                if(curr_local_type == curr_operand_stack_value_type::i32 && local_off == conbine_pending.off1)
                                {
                                    conbine_pending.kind = conbine_pending_kind::xorshift_after_xor1_getx;
                                    break;
                                }

                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
                            case conbine_pending_kind::rot_xor_add_after_rotl:
                            {
                                if(curr_local_type == curr_operand_stack_value_type::i32)
                                {
                                    conbine_pending.kind = conbine_pending_kind::rot_xor_add_after_gety;
                                    conbine_pending.off2 = local_off;
                                    break;
                                }

                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
# endif
                            [[unlikely]] default:
                            {
                                flush_conbine_pending();
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.vt = curr_local_type;
                                conbine_pending.off1 = local_off;
                                break;
                            }
                        }
#else
                        emit_local_get_typed_to(bytecode, curr_local_type, local_off);
#endif
                        break;
                    }
                    case wasm1_code::local_set:
                    {
                        // local.set ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // local.set ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // local.set local_index ...
                        // [ safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        wasm_u32 local_index;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [local_index_next, local_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                                ::fast_io::mnp::leb128_get(local_index))};
                        if(local_index_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_local_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(local_index_err);
                        }

                        // local.set local_index ...
                        // [     safe          ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(local_index_next);

                        // local.set local_index ...
                        // [     safe          ] unsafe (could be the section_end)
                        //                       ^^ code_curr

                        if(local_index >= all_local_count) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_local_index.local_index = local_index;
                            err.err_selectable.illegal_local_index.all_local_count = all_local_count;
                            err.err_code = code_validation_error_code::illegal_local_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const curr_local_type{local_type_from_index(local_index)};

                        bool have_set_operand{};
                        curr_operand_stack_value_type set_operand_type{};
                        if(operand_stack.empty()) [[unlikely]]
                        {
                            if(!is_polymorphic)
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.operand_stack_underflow.op_code_name = u8"local.set";
                                err.err_selectable.operand_stack_underflow.stack_size_actual = 0uz;
                                err.err_selectable.operand_stack_underflow.stack_size_required = 1uz;
                                err.err_code = code_validation_error_code::operand_stack_underflow;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }
                        else
                        {
                            have_set_operand = true;
                            set_operand_type = operand_stack.back_unchecked().type;
                            if(!is_polymorphic && set_operand_type != curr_local_type) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.local_variable_type_mismatch.local_index = local_index;
                                err.err_selectable.local_variable_type_mismatch.expected_type = curr_local_type;
                                err.err_selectable.local_variable_type_mismatch.actual_type = set_operand_type;
                                err.err_code = code_validation_error_code::local_set_type_mismatch;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        auto const local_off{local_offset_from_index(local_index)};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        // Conbine (heavy): `select(local.get a,b,cond) ; local.set dst`
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::select_after_select && conbine_pending.vt == curr_local_type &&
                           (curr_local_type == curr_operand_stack_value_type::i32 || curr_local_type == curr_operand_stack_value_type::f32))
                        {
                            if(have_set_operand) { operand_stack_pop_unchecked(); }
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            if(curr_local_type == curr_operand_stack_value_type::i32)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_select_local_set_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f32_select_local_set_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }

                            // immediates: a_off, b_off, cond_off, dst_off
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            emit_imm_to(bytecode, local_off);

                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }

                        // Conbine (heavy): `mac(acc + x*y -> acc) ; local.set acc`
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::mac_after_add && conbine_pending.vt == curr_local_type &&
                           local_off == conbine_pending.off1)
                        {
                            if(have_set_operand) { operand_stack_pop_unchecked(); }
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            switch(curr_local_type)
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_i32_mac_local_set_acc_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case curr_operand_stack_value_type::i64:
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_i64_mac_local_set_acc_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_f32_mac_local_set_acc_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_f64_mac_local_set_acc_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    break;
                                }
                                [[unlikely]] default:
                                {
#  if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#  endif
                                    break;
                                }
                            }

                            // immediates: x_off, y_off, acc_off
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            emit_imm_to(bytecode, conbine_pending.off1);

                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
# endif
                        // Conbine: `local.get a; local.get b; i32.add; local.set dst`
                        if(curr_local_type == curr_operand_stack_value_type::i32 && conbine_pending.kind == conbine_pending_kind::i32_add_2localget_local_set &&
                           local_off == conbine_pending.off3)
                        {
                            if(have_set_operand) { operand_stack_pop_unchecked(); }
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_2localget_local_set_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
                        // Conbine: `local.get + const + add + local.set` (same local).
                        if(curr_local_type == curr_operand_stack_value_type::i32 &&
                           conbine_pending.kind == conbine_pending_kind::i32_add_imm_local_settee_same && local_off == conbine_pending.off1)
                        {
                            if(have_set_operand) { operand_stack_pop_unchecked(); }
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_local_set_same_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        // Conbine (heavy): `local.get a; local.get b; f32.add; local.set dst`
                        if(curr_local_type == curr_operand_stack_value_type::f32 && conbine_pending.kind == conbine_pending_kind::f32_add_2localget_local_set &&
                           local_off == conbine_pending.off3)
                        {
                            if(have_set_operand) { operand_stack_pop_unchecked(); }
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_add_2localget_local_set_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
                        // Conbine (heavy): `local.get a; local.get b; f64.add; local.set dst`
                        if(curr_local_type == curr_operand_stack_value_type::f64 && conbine_pending.kind == conbine_pending_kind::f64_add_2localget_local_set &&
                           local_off == conbine_pending.off3)
                        {
                            if(have_set_operand) { operand_stack_pop_unchecked(); }
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_add_2localget_local_set_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
                        // Conbine (heavy): `local.get y; local.get x; i32.const r; i32.rotl; i32.xor; local.set dst`
                        if(curr_local_type == curr_operand_stack_value_type::i32 && conbine_pending.kind == conbine_pending_kind::rotl_xor_local_set_after_xor)
                        {
                            if(have_set_operand) { operand_stack_pop_unchecked(); }
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rotl_xor_local_set_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, local_off);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::i32_add_imm_local_settee_same) { flush_conbine_pending(); }

# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::select_after_select || conbine_pending.kind == conbine_pending_kind::mac_after_add)
                        {
                            flush_conbine_pending();
                        }
# endif
#endif

                        if(have_set_operand) { operand_stack_pop_unchecked(); }

                        emit_local_set_typed_to(bytecode, curr_local_type, local_off);
                        break;
                    }
                    case wasm1_code::local_tee:
                    {
                        // local.tee ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // local.tee ...
                        // [safe] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // local.tee local_index ...
                        // [ safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        wasm_u32 local_index;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [local_index_next, local_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                                ::fast_io::mnp::leb128_get(local_index))};
                        if(local_index_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_local_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(local_index_err);
                        }

                        // local.tee local_index ...
                        // [     safe          ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(local_index_next);

                        // local.tee local_index ...
                        // [     safe          ] unsafe (could be the section_end)
                        //                       ^^ code_curr

                        if(local_index >= all_local_count) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_local_index.local_index = local_index;
                            err.err_selectable.illegal_local_index.all_local_count = all_local_count;
                            err.err_code = code_validation_error_code::illegal_local_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        auto const curr_local_type{local_type_from_index(local_index)};

                        if(operand_stack.empty()) [[unlikely]]
                        {
                            if(!is_polymorphic)
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.operand_stack_underflow.op_code_name = u8"local.tee";
                                err.err_selectable.operand_stack_underflow.stack_size_actual = 0uz;
                                err.err_selectable.operand_stack_underflow.stack_size_required = 1uz;
                                err.err_code = code_validation_error_code::operand_stack_underflow;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                            else
                            {
                                operand_stack_push(curr_local_type);
                            }
                        }
                        else
                        {
                            auto const value{operand_stack.back_unchecked()};
                            if(value.type != curr_local_type) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.local_variable_type_mismatch.local_index = local_index;
                                err.err_selectable.local_variable_type_mismatch.expected_type = curr_local_type;
                                err.err_selectable.local_variable_type_mismatch.actual_type = value.type;
                                err.err_code = code_validation_error_code::local_tee_type_mismatch;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        auto const local_off{local_offset_from_index(local_index)};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        // Heavy (test8 hot loop): `local.get(f64); local.get(i32); i32.const; i32.add; local.tee` chain.
                        if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_add)
                        {
                            if(!is_polymorphic && curr_local_type == curr_operand_stack_value_type::i32 && local_off == conbine_pending.off2)
                            {
                                conbine_pending.kind = conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_tee;
                                break;
                            }

                            // Pattern mismatch: flush the deferred ops so the `local.tee` below sees the correct stack shape.
                            flush_conbine_pending();
                        }

                        // Conbine (heavy): `f32.const imm; local.get src; f32.div; local.tee dst`
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::f32_div_from_imm_localtee_wait &&
                           curr_local_type == curr_operand_stack_value_type::f32)
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_div_from_imm_localtee_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                            // immediates: src_off, imm_f32, dst_off
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            emit_imm_to(bytecode, local_off);

                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }

                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }

                        // Conbine (heavy): `select(local.get a,b,cond) ; local.tee dst` (f32 only)
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::select_after_select &&
                           conbine_pending.vt == curr_operand_stack_value_type::f32 && curr_local_type == curr_operand_stack_value_type::f32)
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_select_local_tee_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                            // immediates: a_off, b_off, cond_off, dst_off
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            emit_imm_to(bytecode, local_off);

                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }

                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }

                        // Conbine (heavy): `mac(acc + x*y -> acc) ; local.tee acc` (f32 only)
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::mac_after_add &&
                           conbine_pending.vt == curr_operand_stack_value_type::f32 && curr_local_type == curr_operand_stack_value_type::f32 &&
                           local_off == conbine_pending.off1)
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_mac_local_tee_acc_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                            // immediates: x_off, y_off, acc_off
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            emit_imm_to(bytecode, conbine_pending.off1);

                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }

                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
# endif

                        // Conbine: `local.get a; local.get b; i32.add; local.tee dst`
                        if(curr_local_type == curr_operand_stack_value_type::i32 && conbine_pending.kind == conbine_pending_kind::i32_add_2localget_local_tee &&
                           local_off == conbine_pending.off3)
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_2localget_local_tee_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }

# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        // Conbine (heavy): `local.get a; local.get b; f32.add; local.tee dst`
                        if(curr_local_type == curr_operand_stack_value_type::f32 && conbine_pending.kind == conbine_pending_kind::f32_add_2localget_local_tee &&
                           local_off == conbine_pending.off3)
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_add_2localget_local_tee_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
                        // Conbine (heavy): `local.get a; local.get b; f64.add; local.tee dst`
                        if(curr_local_type == curr_operand_stack_value_type::f64 && conbine_pending.kind == conbine_pending_kind::f64_add_2localget_local_tee &&
                           local_off == conbine_pending.off3)
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_add_2localget_local_tee_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
                        // Conbine (heavy): `local.get y; local.get x; i32.const r; i32.rotl; i32.xor; local.tee dst`
                        if(curr_local_type == curr_operand_stack_value_type::i32 && conbine_pending.kind == conbine_pending_kind::rotl_xor_local_set_after_xor)
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rotl_xor_local_tee_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, local_off);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
# endif

                        // Conbine: `local.get + const + add + local.tee` (same local).
                        if(curr_local_type == curr_operand_stack_value_type::i32 &&
                           conbine_pending.kind == conbine_pending_kind::i32_add_imm_local_settee_same && local_off == conbine_pending.off1)
                        {
# if defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS)
                            // Heavy loop fusions: delay emission so we can potentially fold the following tight-loop skeleton
                            // into a single `for_*_br_if` combined opcode:
                            //
                            //  i32 loop:
                            //    local.get i; i32.const step; i32.add; local.tee i; i32.const end; i32.lt_u; br_if <loop>
                            //
                            //  ptr loop:
                            //    local.get p; i32.const step; i32.add; local.tee p; local.get pend; i32.ne; br_if <loop>
                            //
                            // If the pattern does not match, the pending state flushes back to the normal `i32_add_imm_local_tee_same` emission.
                            if(!is_polymorphic && code_curr != code_end)
                            {
                                wasm1_code next_op{};  // init
                                ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));
                                if(next_op == wasm1_code::i32_const)
                                {
                                    conbine_pending.kind = conbine_pending_kind::for_i32_inc_after_tee;
                                    conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                    break;
                                }
                                if(next_op == wasm1_code::local_get)
                                {
                                    conbine_pending.kind = conbine_pending_kind::for_ptr_inc_after_tee;
                                    conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                    break;
                                }
                            }
# endif
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_local_tee_same_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::i32_add_imm_local_settee_same) { flush_conbine_pending(); }

# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::select_after_select || conbine_pending.kind == conbine_pending_kind::mac_after_add ||
                           conbine_pending.kind == conbine_pending_kind::f32_div_from_imm_localtee_wait)
                        {
                            flush_conbine_pending();
                        }
# endif

                        auto const fuse_site{emit_local_tee_typed_to(bytecode, curr_local_type, local_off)};
                        if(curr_local_type == curr_operand_stack_value_type::i32)
                        {
                            br_if_fuse.kind = br_if_fuse_kind::local_tee_nz;
                            br_if_fuse.site = fuse_site;
                            br_if_fuse.end = bytecode.size();
                            br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
                        }
#else
                        static_cast<void>(emit_local_tee_typed_to(bytecode, curr_local_type, local_off));
#endif
                        break;
                    }
                    case wasm1_code::global_get:
                    {
                        // global.get ...
                        // [  safe  ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // global.get ...
                        // [ safe   ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // global.get global_index ...
                        // [ safe   ] unsafe (could be the section_end)
                        //            ^^ code_curr

                        wasm_u32 global_index;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [global_index_next, global_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                                  reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                                  ::fast_io::mnp::leb128_get(global_index))};
                        if(global_index_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_global_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(global_index_err);
                        }

                        // global.get global_index ...
                        // [     safe            ] unsafe (could be the section_end)
                        //            ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(global_index_next);

                        // global.get global_index ...
                        // [      safe           ] unsafe (could be the section_end)
                        //                         ^^ code_curr

                        if(global_index >= all_global_count) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_global_index.global_index = global_index;
                            err.err_selectable.illegal_global_index.all_global_count = all_global_count;
                            err.err_code = code_validation_error_code::illegal_global_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        curr_operand_stack_value_type curr_global_type{};
                        if(global_index < imported_global_count)
                        {
                            auto const& imported_global_rec{curr_module.imported_global_vec_storage.index_unchecked(static_cast<::std::size_t>(global_index))};
                            auto const imported_global_ptr{imported_global_rec.import_type_ptr};
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            if(imported_global_ptr == nullptr) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                            curr_global_type = imported_global_ptr->imports.storage.global.type;
                        }
                        else
                        {
                            auto const local_global_index{static_cast<::std::size_t>(global_index - imported_global_count)};
                            auto const& local_global_rec{curr_module.local_defined_global_vec_storage.index_unchecked(local_global_index)};
                            auto const local_global_ptr{local_global_rec.global_type_ptr};
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            if(local_global_ptr == nullptr) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                            curr_global_type = local_global_ptr->type;
                        }

                        operand_stack_push(curr_global_type);
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            wasm_global_storage_t* const global_p{resolve_global_storage_ptr(global_index)};

                            if constexpr(stacktop_enabled)
                            {
                                // global.get pushes 1 value to stack-top cache; spill if ring is full.
                                stacktop_prepare_push1_if_reachable(bytecode, curr_global_type);
                            }

                            switch(curr_global_type)
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_global_get_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, global_p);
                                    break;
                                }
                                case curr_operand_stack_value_type::i64:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_global_get_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, global_p);
                                    break;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_global_get_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, global_p);
                                    break;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_global_get_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, global_p);
                                    break;
                                }
                                [[unlikely]] default:
                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                    break;
                                }
                            }

                            if constexpr(stacktop_enabled)
                            {
                                // Model effects: 1 value pushed into stack-top cache.
                                stacktop_commit_push1_typed_if_reachable(curr_global_type);
                            }
                        }
                        break;
                    }
                    case wasm1_code::global_set:
                    {
                        // global.set ...
                        // [  safe  ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // global.set ...
                        // [ safe   ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // global.set global_index ...
                        // [ safe   ] unsafe (could be the section_end)
                        //            ^^ code_curr

                        wasm_u32 global_index;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [global_index_next, global_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                                  reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                                  ::fast_io::mnp::leb128_get(global_index))};
                        if(global_index_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_global_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(global_index_err);
                        }

                        // global.set global_index ...
                        // [     safe            ] unsafe (could be the section_end)
                        //            ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(global_index_next);

                        // global.set global_index ...
                        // [      safe           ] unsafe (could be the section_end)
                        //                         ^^ code_curr

                        if(global_index >= all_global_count) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_global_index.global_index = global_index;
                            err.err_selectable.illegal_global_index.all_global_count = all_global_count;
                            err.err_code = code_validation_error_code::illegal_global_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        curr_operand_stack_value_type curr_global_type{};
                        bool curr_global_mutable{};
                        if(global_index < imported_global_count)
                        {
                            auto const& imported_global_rec{curr_module.imported_global_vec_storage.index_unchecked(static_cast<::std::size_t>(global_index))};
                            auto const imported_global_ptr{imported_global_rec.import_type_ptr};
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            if(imported_global_ptr == nullptr) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                            auto const& imported_global{imported_global_ptr->imports.storage.global};
                            curr_global_type = imported_global.type;
                            curr_global_mutable = imported_global.is_mutable;
                        }
                        else
                        {
                            auto const local_global_index{static_cast<::std::size_t>(global_index - imported_global_count)};
                            auto const& local_global_rec{curr_module.local_defined_global_vec_storage.index_unchecked(local_global_index)};
                            auto const local_global_ptr{local_global_rec.global_type_ptr};
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                            if(local_global_ptr == nullptr) [[unlikely]] { ::uwvm2::utils::debug::trap_and_inform_bug_pos(); }
#endif
                            curr_global_type = local_global_ptr->type;
                            curr_global_mutable = local_global_ptr->is_mutable;
                        }

                        if(!curr_global_mutable) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.immutable_global_set.global_index = global_index;
                            err.err_code = code_validation_error_code::immutable_global_set;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(operand_stack.empty()) [[unlikely]]
                        {
                            if(!is_polymorphic)
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.operand_stack_underflow.op_code_name = u8"global.set";
                                err.err_selectable.operand_stack_underflow.stack_size_actual = 0uz;
                                err.err_selectable.operand_stack_underflow.stack_size_required = 1uz;
                                err.err_code = code_validation_error_code::operand_stack_underflow;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }
                        else
                        {
                            auto const value{operand_stack.back_unchecked()};
                            operand_stack_pop_unchecked();
                            if(value.type != curr_global_type) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.global_variable_type_mismatch.global_index = global_index;
                                err.err_selectable.global_variable_type_mismatch.expected_type = curr_global_type;
                                err.err_selectable.global_variable_type_mismatch.actual_type = value.type;
                                err.err_code = code_validation_error_code::global_set_type_mismatch;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }

                        // Translate: typed `global.set`.
                        {
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            wasm_global_storage_t* const global_p{resolve_global_storage_ptr(global_index)};
                            switch(curr_global_type)
                            {
                                case curr_operand_stack_value_type::i32:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_global_set_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, global_p);
                                    break;
                                }
                                case curr_operand_stack_value_type::i64:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_global_set_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, global_p);
                                    break;
                                }
                                case curr_operand_stack_value_type::f32:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_global_set_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, global_p);
                                    break;
                                }
                                case curr_operand_stack_value_type::f64:
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_global_set_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    emit_imm_to(bytecode, global_p);
                                    break;
                                }
                                [[unlikely]] default:
                                {
#if (defined(_DEBUG) || defined(DEBUG)) && defined(UWVM_ENABLE_DETAILED_DEBUG_CHECK)
                                    ::uwvm2::utils::debug::trap_and_inform_bug_pos();
#endif
                                    break;
                                }
                            }
                        }

                        // Stack-top cache model: `global.set` consumes 1 stack value.
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_load:
                    {
                        auto const offset{validate_mem_load(u8"i32.load", 2u, wasm_value_type_u::i32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            // Conbine: allow fusing the *top* `local.get` into this load even when there is a deeper `local.get`
                            // kept on the operand stack (e.g. `local.get p; local.get p; i32.load` as part of `i32.store` address/value ordering).
                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            conbine_pending.kind = conbine_pending_kind::local_get;
                            conbine_pending.off1 = conbine_pending.off2;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            // Conbine: `local.get addr; i32.load` fused into `i32_load_localget_off`.
                            // Stack effect: push 1 (result), because the address is taken from the local (not from the operand stack).
                            bool fuse_load_add_imm{};
                            bool fuse_load_and_imm{};
                            wasm_i32 fused_imm{};  // no init
                            ::std::byte const* fused_next_ip{code_curr};

                            // Further fuse: `local.get addr; i32.load; i32.const imm; (i32.add|i32.and)`.
                            // This remains a push-1 (result) fusion, because the address comes from the local.
                            if(code_curr != code_end)
                            {
                                wasm1_code next_op;  // no init
                                ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));
                                if(next_op == wasm1_code::i32_const)
                                {
                                    wasm_i32 imm{};
                                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                    auto const [imm_next, imm_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1),
                                                                                            reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                            ::fast_io::mnp::leb128_get(imm))};
                                    if(imm_err == ::fast_io::parse_code::ok)
                                    {
                                        auto const after_const{reinterpret_cast<::std::byte const*>(imm_next)};
                                        if(after_const != code_end)
                                        {
                                            wasm1_code op_after_const;  // no init
                                            ::std::memcpy(::std::addressof(op_after_const), after_const, sizeof(op_after_const));
                                            if(op_after_const == wasm1_code::i32_add)
                                            {
                                                fuse_load_add_imm = true;
                                                fused_imm = imm;
                                                fused_next_ip = after_const + 1;
                                            }
                                            else if(op_after_const == wasm1_code::i32_and)
                                            {
                                                fuse_load_and_imm = true;
                                                fused_imm = imm;
                                                fused_next_ip = after_const + 1;
                                            }
                                        }
                                    }
                                }
                            }

                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            if constexpr(CompileOption.is_tail_call)
                            {
                                if(fuse_load_add_imm)
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_i32_load_add_imm_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                          *resolved_memory0.memory_p,
                                                                                                                          interpreter_tuple));
                                }
                                else if(fuse_load_and_imm)
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_i32_load_and_imm_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                          *resolved_memory0.memory_p,
                                                                                                                          interpreter_tuple));
                                }
                                else
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_i32_load_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                               *resolved_memory0.memory_p,
                                                                                                                               interpreter_tuple));
                                }
                            }
                            else
                            {
                                if(fuse_load_add_imm)
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_i32_load_add_imm_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                                       curr_stacktop));
                                }
                                else if(fuse_load_and_imm)
                                {
                                    emit_opfunc_to(bytecode,
                                                   translate::get_uwvmint_i32_load_and_imm_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                                       curr_stacktop));
                                }
                                else
                                {
                                    emit_opfunc_to(
                                        bytecode,
                                        translate::get_uwvmint_i32_load_localget_off_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                            curr_stacktop));
                                }
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, resolved_memory0.memory_p);
                            emit_imm_to(bytecode, offset);
                            if(fuse_load_add_imm || fuse_load_and_imm)
                            {
                                emit_imm_to(bytecode, fused_imm);
                                code_curr = fused_next_ip;
                            }
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32_add)
                        {
                            // Conbine: `local.get addr; i32.const; i32.add; i32.load` fused into `i32_load_local_plus_imm`.
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_load_local_plus_imm_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                             *resolved_memory0.memory_p,
                                                                                                                             interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_i32_load_local_plus_imm_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                        curr_stacktop));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, resolved_memory0.memory_p);
                            emit_imm_to(bytecode, offset);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            break;
                        }
#endif
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_load_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_load_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        break;
                    }
                    case wasm1_code::i64_load:
                    {
                        auto const offset{validate_mem_load(u8"i64.load", 3u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_load_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_load_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }
                        break;
                    }
                    case wasm1_code::f32_load:
                    {
                        auto const offset{validate_mem_load(u8"f32.load", 2u, wasm_value_type_u::f32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32_add)
                        {
                            // Conbine (heavy): `local.get addr; i32.const; i32.add; f32.load` fused into `f32_load_local_plus_imm`.
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f32_load_local_plus_imm_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                             *resolved_memory0.memory_p,
                                                                                                                             interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_f32_load_local_plus_imm_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                        curr_stacktop));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, resolved_memory0.memory_p);
                            emit_imm_to(bytecode, offset);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                            break;
                        }
#endif
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32))
                        {
                            // f32.load is a pop(i32)+push(f32) op; the opfunc writes into the f32 ring.
                            // Ensure the destination ring has a free slot before emitting the opfunc, or the runtime write may overwrite
                            // the deepest cached value and corrupt subsequent computations (notably inside libc printf/vsnprintf paths).
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                        }
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_load_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_load_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32))
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f32); }
                            }
                            else
                            {
                                // i32 addr -> f32 result: cross-ring, depth unchanged => model as pop+push.
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f64_load:
                    {
                        auto const offset{validate_mem_load(u8"f64.load", 3u, wasm_value_type_u::f64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32_add)
                        {
                            // Conbine (heavy): `local.get addr; i32.const; i32.add; f64.load` fused into `f64_load_local_plus_imm`.
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64); }
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_load_local_plus_imm_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                             *resolved_memory0.memory_p,
                                                                                                                             interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_f64_load_local_plus_imm_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                        curr_stacktop));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, resolved_memory0.memory_p);
                            emit_imm_to(bytecode, offset);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                            break;
                        }
#endif
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64))
                        {
                            // f64.load is a pop(i32)+push(f64) op; ensure the destination ring has a free slot before emitting the opfunc.
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                        }
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_load_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_load_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64))
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f64); }
                            }
                            else
                            {
                                // i32 addr -> f64 result: cross-ring, depth unchanged => model as pop+push.
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f64);
                            }
                        }
                        break;
                    }
                    case wasm1_code::i32_load8_s:
                    {
                        auto const offset{validate_mem_load(u8"i32.load8_s", 0u, wasm_value_type_u::i32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                            if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.off1 = conbine_pending.off2;
                            }
                            if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                // Conbine: `local.get addr; i32.load8_s` fused into `i32_load8_s_localget_off`.
                                // Stack effect: push 1 (result), because the address is taken from the local.
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_load8_s_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                              *resolved_memory0.memory_p,
                                                                                                                              interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                                break;
                            }
#endif
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_load8_s_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                             *resolved_memory0.memory_p,
                                                                                                             interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_load8_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        break;
                    }
                    case wasm1_code::i32_load8_u:
                    {
                        auto const offset{validate_mem_load(u8"i32.load8_u", 0u, wasm_value_type_u::i32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                            if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.off1 = conbine_pending.off2;
                            }
                            if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                // Conbine: `local.get addr; i32.load8_u` fused into `i32_load8_u_localget_off`.
                                // Stack effect: push 1 (result), because the address is taken from the local.
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_load8_u_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                              *resolved_memory0.memory_p,
                                                                                                                              interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                                break;
                            }
#endif
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_load8_u_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                             *resolved_memory0.memory_p,
                                                                                                             interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_load8_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        break;
                    }
                    case wasm1_code::i32_load16_s:
                    {
                        auto const offset{validate_mem_load(u8"i32.load16_s", 1u, wasm_value_type_u::i32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                            if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.off1 = conbine_pending.off2;
                            }
                            if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                // Conbine: `local.get addr; i32.load16_s` fused into `i32_load16_s_localget_off`.
                                // Stack effect: push 1 (result), because the address is taken from the local.
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_load16_s_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                               *resolved_memory0.memory_p,
                                                                                                                               interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                                break;
                            }
#endif
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_load16_s_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                              *resolved_memory0.memory_p,
                                                                                                              interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_load16_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        break;
                    }
                    case wasm1_code::i32_load16_u:
                    {
                        auto const offset{validate_mem_load(u8"i32.load16_u", 1u, wasm_value_type_u::i32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                            if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                                conbine_pending.kind = conbine_pending_kind::local_get;
                                conbine_pending.off1 = conbine_pending.off2;
                            }
                            if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                // Conbine: `local.get addr; i32.load16_u` fused into `i32_load16_u_localget_off`.
                                // Stack effect: push 1 (result), because the address is taken from the local.
                                if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_load16_u_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                               *resolved_memory0.memory_p,
                                                                                                                               interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                                break;
                            }

# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                            if(conbine_pending.kind == conbine_pending_kind::u16_copy_scaled_index_after_shl)
                            {
                                conbine_pending.kind = conbine_pending_kind::u16_copy_scaled_index_after_load;
                                conbine_pending.imm_u32 = offset;
                                break;
                            }
# endif
#endif
                        }

                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_load16_u_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                              *resolved_memory0.memory_p,
                                                                                                              interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_load16_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        break;
                    }
                    case wasm1_code::i64_load8_s:
                    {
                        auto const offset{validate_mem_load(u8"i64.load8_s", 0u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_load8_s_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                             *resolved_memory0.memory_p,
                                                                                                             interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_load8_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }
                        break;
                    }
                    case wasm1_code::i64_load8_u:
                    {
                        auto const offset{validate_mem_load(u8"i64.load8_u", 0u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_load8_u_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                             *resolved_memory0.memory_p,
                                                                                                             interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_load8_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }
                        break;
                    }
                    case wasm1_code::i64_load16_s:
                    {
                        auto const offset{validate_mem_load(u8"i64.load16_s", 1u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_load16_s_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                              *resolved_memory0.memory_p,
                                                                                                              interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_load16_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }
                        break;
                    }
                    case wasm1_code::i64_load16_u:
                    {
                        auto const offset{validate_mem_load(u8"i64.load16_u", 1u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_load16_u_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                              *resolved_memory0.memory_p,
                                                                                                              interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_load16_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }
                        break;
                    }
                    case wasm1_code::i64_load32_s:
                    {
                        auto const offset{validate_mem_load(u8"i64.load32_s", 2u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_load32_s_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                              *resolved_memory0.memory_p,
                                                                                                              interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_load32_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }
                        break;
                    }
                    case wasm1_code::i64_load32_u:
                    {
                        auto const offset{validate_mem_load(u8"i64.load32_u", 2u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_load32_u_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                              *resolved_memory0.memory_p,
                                                                                                              interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_load32_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }
                        break;
                    }
                    case wasm1_code::i32_store:
                    {
                        auto const offset{validate_mem_store(u8"i32.store", 2u, wasm_value_type_u::i32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32_add_localget &&
                           conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            // Conbine: `local.get addr; i32.const; i32.add; local.get v; i32.store` fused into `i32_store_local_plus_imm`.
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_store_local_plus_imm_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                              *resolved_memory0.memory_p,
                                                                                                                              interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_i32_store_local_plus_imm_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                        curr_stacktop));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, resolved_memory0.memory_p);
                            emit_imm_to(bytecode, offset);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
                        if constexpr(CompileOption.is_tail_call)
                        {
                            if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                // Conbine: `local.get addr; local.get v; i32.store` fused into `i32_store_localget_off`.
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_store_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                            *resolved_memory0.memory_p,
                                                                                                                            interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                break;
                            }
                            if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                            {
                                // Conbine: `local.get addr; i32.const imm; i32.store` fused into `i32_store_imm_localget_off`.
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_store_imm_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                *resolved_memory0.memory_p,
                                                                                                                                interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                break;
                            }
                        }
#endif

                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_store_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_store_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::i64_store:
                    {
                        auto const offset{validate_mem_store(u8"i64.store", 3u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_store_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_store_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::f32_store:
                    {
                        auto const offset{validate_mem_store(u8"f32.store", 2u, wasm_value_type_u::f32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32_add_localget &&
                           conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            // Conbine (heavy): `local.get addr; i32.const; i32.add; local.get v; f32.store` fused into `f32_store_local_plus_imm`.
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f32_store_local_plus_imm_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                              *resolved_memory0.memory_p,
                                                                                                                              interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_f32_store_local_plus_imm_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                        curr_stacktop));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, resolved_memory0.memory_p);
                            emit_imm_to(bytecode, offset);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
#endif
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_store_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_store_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::f64_store:
                    {
                        auto const offset{validate_mem_store(u8"f64.store", 3u, wasm_value_type_u::f64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32_add_localget &&
                           conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            // Conbine (heavy): `local.get addr; i32.const; i32.add; local.get v; f64.store` fused into `f64_store_local_plus_imm`.
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_store_local_plus_imm_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                              *resolved_memory0.memory_p,
                                                                                                                              interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_f64_store_local_plus_imm_fptr<CompileOption, ::std::byte const*, ::std::byte*, ::std::byte*>(
                                        curr_stacktop));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, resolved_memory0.memory_p);
                            emit_imm_to(bytecode, offset);
                            conbine_pending.kind = conbine_pending_kind::none;
                            conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            break;
                        }
#endif

                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_store_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_store_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::i32_store8:
                    {
                        auto const offset{validate_mem_store(u8"i32.store8", 0u, wasm_value_type_u::i32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                            if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                // Conbine: `local.get addr; local.get v; i32.store8` fused into `i32_store8_localget_off`.
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_store8_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                             *resolved_memory0.memory_p,
                                                                                                                             interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                break;
                            }
                            if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                            {
                                // Conbine: `local.get addr; i32.const imm; i32.store8` fused into `i32_store8_imm_localget_off`.
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_store8_imm_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                 *resolved_memory0.memory_p,
                                                                                                                                 interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                break;
                            }
#endif
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_store8_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_store8_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::i32_store16:
                    {
                        auto const offset{validate_mem_store(u8"i32.store16", 1u, wasm_value_type_u::i32)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if constexpr(CompileOption.is_tail_call)
                        {
                            if(conbine_pending.kind == conbine_pending_kind::u16_copy_scaled_index_after_load)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_u16_copy_scaled_index_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                           *resolved_memory0.memory_p,
                                                                                                                           interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, conbine_pending.imm_u32);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                break;
                            }
                        }
#endif
                        if constexpr(CompileOption.is_tail_call)
                        {
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                            if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                            {
                                // Conbine: `local.get addr; local.get v; i32.store16` fused into `i32_store16_localget_off`.
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_store16_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                              *resolved_memory0.memory_p,
                                                                                                                              interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.off2);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                break;
                            }
                            if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                            {
                                // Conbine: `local.get addr; i32.const imm; i32.store16` fused into `i32_store16_imm_localget_off`.
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_store16_imm_localget_off_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                                                  *resolved_memory0.memory_p,
                                                                                                                                  interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                emit_imm_to(bytecode, resolved_memory0.memory_p);
                                emit_imm_to(bytecode, offset);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                                break;
                            }
#endif
                        }
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_store16_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                             *resolved_memory0.memory_p,
                                                                                                             interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_store16_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::i64_store8:
                    {
                        auto const offset{validate_mem_store(u8"i64.store8", 0u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_store8_fptr_from_tuple<CompileOption>(curr_stacktop, *resolved_memory0.memory_p, interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_store8_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::i64_store16:
                    {
                        auto const offset{validate_mem_store(u8"i64.store16", 1u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_store16_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                             *resolved_memory0.memory_p,
                                                                                                             interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_store16_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::i64_store32:
                    {
                        auto const offset{validate_mem_store(u8"i64.store32", 2u, wasm_value_type_u::i64)};
                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(CompileOption.is_tail_call)
                        {
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_store32_fptr_from_tuple<CompileOption>(curr_stacktop,
                                                                                                             *resolved_memory0.memory_p,
                                                                                                             interpreter_tuple));
                        }
                        else
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i64_store32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, offset);
                        stacktop_after_pop_n_if_reachable(bytecode, 2uz);
                        break;
                    }
                    case wasm1_code::memory_size:
                    {
                        // memory.size memidx ...
                        // [ safe    ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // memory.size memidx ...
                        // [ safe    ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // memory.size memidx ...
                        // [ safe    ] unsafe (could be the section_end)
                        //             ^^ code_curr

                        wasm_u32 memidx;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [mem_next, mem_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                ::fast_io::mnp::leb128_get(memidx))};
                        if(mem_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_memory_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(mem_err);
                        }

                        // memory.size memidx ...
                        // [ safe           ] unsafe (could be the section_end)
                        //             ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(mem_next);

                        // memory.size memidx ...
                        // [ safe           ] unsafe (could be the section_end)
                        //                    ^^ code_curr

                        if(memidx != 0u) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_memory_index.memory_index = memidx;
                            err.err_selectable.illegal_memory_index.all_memory_count = all_memory_count;
                            err.err_code = code_validation_error_code::illegal_memory_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(all_memory_count == 0u) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.no_memory.op_code_name = u8"memory.size";
                            err.err_selectable.no_memory.align = 0u;
                            err.err_selectable.no_memory.offset = 0u;
                            err.err_code = code_validation_error_code::no_memory;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        emit_opfunc_to(bytecode, translate::get_uwvmint_memory_size_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);

                        operand_stack_push(wasm_value_type_u::i32);
                        break;
                    }
                    case wasm1_code::memory_grow:
                    {
                        // memory.grow memidx ...
                        // [ safe    ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // memory.grow memidx ...
                        // [ safe    ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // memory.grow memidx ...
                        // [ safe    ] unsafe (could be the section_end)
                        //             ^^ code_curr

                        wasm_u32 memidx;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [mem_next, mem_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                ::fast_io::mnp::leb128_get(memidx))};
                        if(mem_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_code = code_validation_error_code::invalid_memory_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(mem_err);
                        }

                        // memory.grow memidx ...
                        // [        safe    ] unsafe (could be the section_end)
                        //             ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(mem_next);

                        // memory.grow memidx ...
                        // [        safe    ] unsafe (could be the section_end)
                        //                    ^^ code_curr

                        if(memidx != 0u) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.illegal_memory_index.memory_index = memidx;
                            err.err_selectable.illegal_memory_index.all_memory_count = all_memory_count;
                            err.err_code = code_validation_error_code::illegal_memory_index;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(all_memory_count == 0u) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.no_memory.op_code_name = u8"memory.grow";
                            err.err_selectable.no_memory.align = 0u;
                            err.err_selectable.no_memory.offset = 0u;
                            err.err_code = code_validation_error_code::no_memory;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                        }

                        if(!is_polymorphic)
                        {
                            if(operand_stack.empty()) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.operand_stack_underflow.op_code_name = u8"memory.grow";
                                err.err_selectable.operand_stack_underflow.stack_size_actual = 0uz;
                                err.err_selectable.operand_stack_underflow.stack_size_required = 1uz;
                                err.err_code = code_validation_error_code::operand_stack_underflow;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }

                            auto const delta{operand_stack.back_unchecked()};
                            operand_stack_pop_unchecked();

                            if(delta.type != wasm_value_type_u::i32) [[unlikely]]
                            {
                                err.err_curr = op_begin;
                                err.err_selectable.memory_grow_delta_type_not_i32.delta_type = delta.type;
                                err.err_code = code_validation_error_code::memory_grow_delta_type_not_i32;
                                ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                            }
                        }
                        else
                        {
                            operand_stack_pop_unchecked();
                        }

                        ensure_memory0_resolved();
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_memory_grow_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(bytecode, resolved_memory0.memory_p);
                        emit_imm_to(bytecode, resolved_memory0.max_limit_memory_length);

                        operand_stack_push(wasm_value_type_u::i32);
                        break;
                    }
                    case wasm1_code::i32_const:
                    {
                        // i32.const i32 ...
                        // [ safe  ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // i32.const i32 ...
                        // [ safe  ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // i32.const i32 ...
                        // [ safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        wasm_i32 imm;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [imm_next, imm_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                ::fast_io::mnp::leb128_get(imm))};
                        if(imm_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.invalid_const_immediate.op_code_name = u8"i32.const";
                            err.err_code = code_validation_error_code::invalid_const_immediate;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(imm_err);
                        }

                        // i32.const i32 ...
                        // [    safe   ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(imm_next);

                        // i32.const i32 ...
                        // [    safe   ] unsafe (could be the section_end)
                        //               ^^ code_curr

                        // Conbine: `local.get(i32) + i32.const` (delay emission for imm/localget fusions).
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_gets)
                        {
                            conbine_pending.kind = conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_step_const;
                            conbine_pending.imm_i32 = imm;
                        }
                        else
#  ifdef UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS
                            if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_after_tee)
                        {
                            conbine_pending.kind = conbine_pending_kind::for_i32_inc_after_end_const;
                            conbine_pending.imm_i32_2 = imm;
                        }
                        else
#  endif
                            if(conbine_pending.kind == conbine_pending_kind::rot_xor_add_after_xor)
                        {
                            conbine_pending.kind = conbine_pending_kind::rot_xor_add_after_xor_constc;
                            conbine_pending.imm_i32_2 = imm;
                        }
                        else if(conbine_pending.kind == conbine_pending_kind::xorshift_after_xor1_getx)
                        {
                            conbine_pending.kind = conbine_pending_kind::xorshift_after_xor1_getx_constb;
                            conbine_pending.imm_i32_2 = imm;
                        }
                        else if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32 &&
                                conbine_pending.off1 == conbine_pending.off2)
                        {
                            // Lookahead is safe: we do not advance `code_curr`.
                            // [ ... i32.const a ] | next_op ...
                            // [       safe      ] | unsafe
                            //                     ^^ code_curr
                            wasm1_code next_op{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op)); }
                            if(next_op == wasm1_code::i32_shr_u)
                            {
                                conbine_pending.kind = conbine_pending_kind::xorshift_pre_shr;
                                conbine_pending.imm_i32 = imm;
                            }
                            else
                            {
                                conbine_pending.kind = conbine_pending_kind::local_get2_const_i32;
                                conbine_pending.imm_i32 = imm;
                            }
                        }
                        else
# endif
                            if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            conbine_pending.kind = conbine_pending_kind::local_get2_const_i32;
                            conbine_pending.imm_i32 = imm;
                        }
                        else if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            conbine_pending.kind = conbine_pending_kind::local_get_const_i32;
                            conbine_pending.imm_i32 = imm;
                        }
                        else
                        {
                            flush_conbine_pending();
                            conbine_pending.kind = conbine_pending_kind::const_i32;
                            conbine_pending.imm_i32 = imm;
                        }
#else
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32); }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(bytecode, imm);
                        if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
#endif

                        operand_stack_push(wasm_value_type_u::i32);
                        break;
                    }
                    case wasm1_code::i64_const:
                    {
                        // i64.const i64 ...
                        // [ safe  ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // i64.const i64 ...
                        // [ safe  ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // i64.const i64 ...
                        // [ safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        wasm_i64 imm;
                        using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                        auto const [imm_next, imm_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr),
                                                                                reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                ::fast_io::mnp::leb128_get(imm))};
                        if(imm_err != ::fast_io::parse_code::ok) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.invalid_const_immediate.op_code_name = u8"i64.const";
                            err.err_code = code_validation_error_code::invalid_const_immediate;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(imm_err);
                        }

                        // i64.const i64 ...
                        // [     safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        code_curr = reinterpret_cast<::std::byte const*>(imm_next);

                        // i64.const i64 ...
                        // [     safe  ] unsafe (could be the section_end)
                        //               ^^ code_curr

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        // Conbine: `local.get(i64) + i64.const` (delay emission for imm/localget fusions).
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i64)
                        {
                            conbine_pending.kind = conbine_pending_kind::local_get_const_i64;
                            conbine_pending.imm_i64 = imm;
                        }
                        else
                        {
                            flush_conbine_pending();
                            conbine_pending.kind = conbine_pending_kind::const_i64;
                            conbine_pending.imm_i64 = imm;
                        }
#else
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64); }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(bytecode, imm);
                        if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i64); }
#endif

                        operand_stack_push(wasm_value_type_u::i64);
                        break;
                    }
                    case wasm1_code::f32_const:
                    {
                        // f32.const f32 ...
                        // [ safe  ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // f32.const f32 ...
                        // [ safe  ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // f32.const f32 ...
                        // [ safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        if(static_cast<::std::size_t>(code_end - code_curr) < sizeof(wasm_f32)) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.invalid_const_immediate.op_code_name = u8"f32.const";
                            err.err_code = code_validation_error_code::invalid_const_immediate;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::end_of_file);
                        }

                        // f32.const f32 ...
                        // [ safe      ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        wasm_f32 imm;
                        ::std::memcpy(::std::addressof(imm), code_curr, sizeof(imm));

                        code_curr += sizeof(imm);

                        // f32.const f32 ...
                        // [ safe      ] unsafe (could be the section_end)
                        //               ^^ code_curr

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        // Conbine (heavy): `local.get(f32) + f32.const` (delay emission for imm/localget fusions).
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            conbine_pending.kind = conbine_pending_kind::local_get_const_f32;
                            conbine_pending.imm_f32 = imm;
                        }
                        else if(conbine_pending.kind == conbine_pending_kind::none)
                        {
                            conbine_pending.kind = conbine_pending_kind::const_f32;
                            conbine_pending.imm_f32 = imm;
                        }
                        else
# endif
                        {
                            flush_conbine_pending();
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, imm);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
                        }
#else
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32); }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(bytecode, imm);
                        if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32); }
#endif

                        operand_stack_push(wasm_value_type_u::f32);
                        break;
                    }
                    case wasm1_code::f64_const:
                    {
                        // f64.const f64 ...
                        // [ safe  ] unsafe (could be the section_end)
                        // ^^ code_curr

                        auto const op_begin{code_curr};

                        // f64.const f64 ...
                        // [ safe  ] unsafe (could be the section_end)
                        // ^^ op_begin

                        ++code_curr;

                        // f64.const f64 ...
                        // [ safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        if(static_cast<::std::size_t>(code_end - code_curr) < sizeof(wasm_f64)) [[unlikely]]
                        {
                            err.err_curr = op_begin;
                            err.err_selectable.invalid_const_immediate.op_code_name = u8"f64.const";
                            err.err_code = code_validation_error_code::invalid_const_immediate;
                            ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::end_of_file);
                        }

                        // f64.const f64 ...
                        // [     safe  ] unsafe (could be the section_end)
                        //           ^^ code_curr

                        wasm_f64 imm;
                        ::std::memcpy(::std::addressof(imm), code_curr, sizeof(imm));

                        code_curr += sizeof(imm);

                        // f64.const f64 ...
                        // [     safe  ] unsafe (could be the section_end)
                        //               ^^ code_curr

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        // Conbine (heavy): `local.get(f64) + f64.const` (delay emission for imm/localget fusions).
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            conbine_pending.kind = conbine_pending_kind::local_get_const_f64;
                            conbine_pending.imm_f64 = imm;
                        }
                        else if(conbine_pending.kind == conbine_pending_kind::none)
                        {
                            conbine_pending.kind = conbine_pending_kind::const_f64;
                            conbine_pending.imm_f64 = imm;
                        }
                        else
# endif
                        {
                            flush_conbine_pending();
                            namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                            if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64); }
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, imm);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                        }
#else
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled) { stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64); }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_const_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        emit_imm_to(bytecode, imm);
                        if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
#endif

                        operand_stack_push(wasm_value_type_u::f64);
                        break;
                    }
                    case wasm1_code::i32_eqz:
                    {
                        validate_numeric_unary(u8"i32.eqz", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::i32_rem_u_2localget_wait_eqz)
                        {
                            conbine_pending.kind = conbine_pending_kind::i32_rem_u_eqz_2localget_wait_brif;
                            break;
                        }
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_cmp)
                        {
                            conbine_pending.kind = conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_eqz;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            // Conbine: if the next opcode is `br_if`, defer emission so `br_if_local_eqz` can be produced.
                            conbine_pending.kind = conbine_pending_kind::local_get_eqz_i32;
                        }
                        else
                        {
                            br_if_fuse.kind = br_if_fuse_kind::i32_eqz;
                            br_if_fuse.site = bytecode.size();
                            br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_eqz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        }
#else
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_eqz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
#endif
                        break;
                    }
                    case wasm1_code::i32_eq:
                    {
                        validate_numeric_binary(u8"i32.eq", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            // i32.eq ...
                            // [ safe ] unsafe (could be the section_end)
                            // ^^ code_curr

                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if)
                            {
                                conbine_pending.kind = conbine_pending_kind::local_get_const_i32_cmp_brif;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::i32_eq;
                            }
                            else
                            {
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_eq_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            }
                        }
                        else
                        {
                            br_if_fuse.kind = br_if_fuse_kind::i32_eq;
                            br_if_fuse.site = bytecode.size();
                            br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_eq_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                            else
                            {
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                        }
#else
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_eq_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
#endif
                        break;
                    }
                    case wasm1_code::i32_ne:
                    {
                        validate_numeric_binary(u8"i32.ne", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
# if defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::for_ptr_inc_after_pend_get)
                        {
                            conbine_pending.kind = conbine_pending_kind::for_ptr_inc_after_cmp;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_ne_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                        }
                        else
                        {
                            br_if_fuse.kind = br_if_fuse_kind::i32_ne;
                            br_if_fuse.site = bytecode.size();
                            br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ne_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                            else
                            {
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                        }
#else
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ne_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
#endif
                        break;
                    }
                    case wasm1_code::i32_lt_s:
                    {
                        validate_numeric_binary(u8"i32.lt_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if)
                            {
                                conbine_pending.kind = conbine_pending_kind::local_get_const_i32_cmp_brif;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::i32_lt_s;
                            }
                            else
                            {
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_lt_s_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            }
                        }
                        else
                        {
                            // Peephole: `i32.lt_s; i32.const 1; i32.and; i32.eqz; br_if` is a common LLVM/Clang boolean-normalize pattern.
                            // Because `i32.lt_s` already yields 0/1, `& 1` is redundant and `eqz` simply inverts the compare:
                            //   (lhs < rhs) & 1 == (lhs < rhs)
                            //   eqz(...)        == (lhs >= rhs)
                            //
                            // Rewrite into `i32.ge_s; br_if` so the existing compare+br_if fusion can fire (reduces dispatch in tight loops).

                            br_if_fuse_kind fuse_kind{br_if_fuse_kind::i32_lt_s};
                            auto fused_fptr{translate::get_uwvmint_i32_lt_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple)};

# if defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                            if(!is_polymorphic)
                            {
                                bool fuse_to_ge_s{};
                                ::std::byte const* brif_ip{};

                                do
                                {
                                    if(code_curr == code_end) { break; }
                                    wasm1_code op1{};  // init
                                    ::std::memcpy(::std::addressof(op1), code_curr, sizeof(op1));
                                    if(op1 != wasm1_code::i32_const) { break; }

                                    wasm_i32 imm{};
                                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                    auto const [imm_next, imm_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1),
                                                                                            reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                            ::fast_io::mnp::leb128_get(imm))};
                                    if(imm_err != ::fast_io::parse_code::ok || imm != 1) { break; }

                                    auto const after_const{reinterpret_cast<::std::byte const*>(imm_next)};
                                    if(after_const == code_end) { break; }
                                    wasm1_code op2{};  // init
                                    ::std::memcpy(::std::addressof(op2), after_const, sizeof(op2));
                                    if(op2 != wasm1_code::i32_and) { break; }

                                    auto const after_and{after_const + 1};
                                    if(after_and == code_end) { break; }
                                    wasm1_code op3{};  // init
                                    ::std::memcpy(::std::addressof(op3), after_and, sizeof(op3));
                                    if(op3 != wasm1_code::i32_eqz) { break; }

                                    auto const after_eqz{after_and + 1};
                                    if(after_eqz == code_end) { break; }
                                    wasm1_code op4{};  // init
                                    ::std::memcpy(::std::addressof(op4), after_eqz, sizeof(op4));
                                    if(op4 != wasm1_code::br_if) { break; }

                                    fuse_to_ge_s = true;
                                    brif_ip = after_eqz;  // skip const/and/eqz, re-enter at br_if
                                }
                                while(false);

                                if(fuse_to_ge_s)
                                {
                                    fuse_kind = br_if_fuse_kind::i32_ge_s;
                                    fused_fptr = translate::get_uwvmint_i32_ge_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple);
                                    code_curr = brif_ip;
                                }
                            }
# endif

                            br_if_fuse.kind = fuse_kind;
                            br_if_fuse.site = bytecode.size();
                            br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
                            emit_opfunc_to(bytecode, fused_fptr);
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                            else
                            {
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                        }
#else
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_lt_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
#endif
                        break;
                    }
                    case wasm1_code::i32_lt_u:
                    {
                        validate_numeric_binary(u8"i32.lt_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
# if defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_EXTRA_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::for_i32_inc_after_end_const)
                        {
                            conbine_pending.kind = conbine_pending_kind::for_i32_inc_after_cmp;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            // i32.lt_u ...
                            // [ safe ] unsafe (could be the section_end)
                            // ^^ code_curr

                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if)
                            {
                                conbine_pending.kind = conbine_pending_kind::local_get_const_i32_cmp_brif;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::i32_lt_u;
                            }
                            else
                            {
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_lt_u_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            }
                        }
                        else
                        {
                            // Same boolean-normalize peephole as `i32.lt_s` case, but for unsigned compares:
                            // `i32.lt_u; i32.const 1; i32.and; i32.eqz; br_if` => `i32.ge_u; br_if`

                            br_if_fuse_kind fuse_kind{br_if_fuse_kind::i32_lt_u};
                            auto fused_fptr{translate::get_uwvmint_i32_lt_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple)};

# if defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                            if(!is_polymorphic)
                            {
                                bool fuse_to_ge_u{};
                                ::std::byte const* brif_ip{};

                                do
                                {
                                    if(code_curr == code_end) { break; }
                                    wasm1_code op1{};  // init
                                    ::std::memcpy(::std::addressof(op1), code_curr, sizeof(op1));
                                    if(op1 != wasm1_code::i32_const) { break; }

                                    wasm_i32 imm{};
                                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                    auto const [imm_next, imm_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1),
                                                                                            reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                            ::fast_io::mnp::leb128_get(imm))};
                                    if(imm_err != ::fast_io::parse_code::ok || imm != 1) { break; }

                                    auto const after_const{reinterpret_cast<::std::byte const*>(imm_next)};
                                    if(after_const == code_end) { break; }
                                    wasm1_code op2{};  // init
                                    ::std::memcpy(::std::addressof(op2), after_const, sizeof(op2));
                                    if(op2 != wasm1_code::i32_and) { break; }

                                    auto const after_and{after_const + 1};
                                    if(after_and == code_end) { break; }
                                    wasm1_code op3{};  // init
                                    ::std::memcpy(::std::addressof(op3), after_and, sizeof(op3));
                                    if(op3 != wasm1_code::i32_eqz) { break; }

                                    auto const after_eqz{after_and + 1};
                                    if(after_eqz == code_end) { break; }
                                    wasm1_code op4{};  // init
                                    ::std::memcpy(::std::addressof(op4), after_eqz, sizeof(op4));
                                    if(op4 != wasm1_code::br_if) { break; }

                                    fuse_to_ge_u = true;
                                    brif_ip = after_eqz;
                                }
                                while(false);

                                if(fuse_to_ge_u)
                                {
                                    fuse_kind = br_if_fuse_kind::i32_ge_u;
                                    fused_fptr = translate::get_uwvmint_i32_ge_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple);
                                    code_curr = brif_ip;
                                }
                            }
# endif

                            br_if_fuse.kind = fuse_kind;
                            br_if_fuse.site = bytecode.size();
                            br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
                            emit_opfunc_to(bytecode, fused_fptr);
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                            else
                            {
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                        }
#else
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_lt_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
#endif
                        break;
                    }
                    case wasm1_code::i32_gt_s:
                    {
                        validate_numeric_binary(u8"i32.gt_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        br_if_fuse.kind = br_if_fuse_kind::i32_gt_s;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_gt_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
                        break;
                    }
                    case wasm1_code::i32_gt_u:
                    {
                        validate_numeric_binary(u8"i32.gt_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        br_if_fuse.kind = br_if_fuse_kind::i32_gt_u;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_gt_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
                        break;
                    }
                    case wasm1_code::i32_le_s:
                    {
                        validate_numeric_binary(u8"i32.le_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        br_if_fuse.kind = br_if_fuse_kind::i32_le_s;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_le_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
                        break;
                    }
                    case wasm1_code::i32_le_u:
                    {
                        validate_numeric_binary(u8"i32.le_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        br_if_fuse.kind = br_if_fuse_kind::i32_le_u;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_le_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
                        break;
                    }
                    case wasm1_code::i32_ge_s:
                    {
                        validate_numeric_binary(u8"i32.ge_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if)
                            {
                                conbine_pending.kind = conbine_pending_kind::local_get_const_i32_cmp_brif;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::i32_ge_s;
                            }
                            else
                            {
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_ge_s_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            }
                        }
                        else
                        {
                            br_if_fuse.kind = br_if_fuse_kind::i32_ge_s;
                            br_if_fuse.site = bytecode.size();
                            br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ge_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                            else
                            {
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                        }
#else
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ge_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
#endif
                        break;
                    }
                    case wasm1_code::i32_ge_u:
                    {
                        validate_numeric_binary(u8"i32.ge_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            // i32.ge_u ...
                            // [ safe ] unsafe (could be the section_end)
                            // ^^ code_curr

                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if)
                            {
                                conbine_pending.kind = conbine_pending_kind::local_get_const_i32_cmp_brif;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::i32_ge_u;
                            }
                            else
                            {
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_ge_u_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.off1);
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                                conbine_pending.kind = conbine_pending_kind::none;
                                conbine_pending.brif_cmp = conbine_brif_cmp_kind::none;
                            }
                        }
                        else
                        {
                            br_if_fuse.kind = br_if_fuse_kind::i32_ge_u;
                            br_if_fuse.site = bytecode.size();
                            br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ge_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                            else
                            {
                                stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                            }
                        }
#else
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ge_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }
#endif
                        break;
                    }
                    case wasm1_code::i64_eqz:
                    {
                        validate_numeric_unary(u8"i64.eqz", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        br_if_fuse.kind = br_if_fuse_kind::i64_eqz;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_eqz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                        }
                        break;
                    }
                    case wasm1_code::i64_eq:
                    {
                        validate_numeric_binary(u8"i64.eq", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_eq_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        break;
                    }
                    case wasm1_code::i64_ne:
                    {
                        validate_numeric_binary(u8"i64.ne", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        br_if_fuse.kind = br_if_fuse_kind::i64_ne;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_ne_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            stacktop_after_pop_n_no_fill_if_reachable(1uz);
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }
                        break;
                    }
                    case wasm1_code::i64_lt_s:
                    {
                        validate_numeric_binary(u8"i64.lt_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_lt_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        break;
                    }
                    case wasm1_code::i64_lt_u:
                    {
                        validate_numeric_binary(u8"i64.lt_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        br_if_fuse.kind = br_if_fuse_kind::i64_lt_u;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_lt_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            stacktop_after_pop_n_no_fill_if_reachable(1uz);
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }
                        break;
                    }
                    case wasm1_code::i64_gt_s:
                    {
                        validate_numeric_binary(u8"i64.gt_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_gt_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        break;
                    }
                    case wasm1_code::i64_gt_u:
                    {
                        validate_numeric_binary(u8"i64.gt_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        br_if_fuse.kind = br_if_fuse_kind::i64_gt_u;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_gt_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            stacktop_after_pop_n_no_fill_if_reachable(1uz);
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }
                        break;
                    }
                    case wasm1_code::i64_le_s:
                    {
                        validate_numeric_binary(u8"i64.le_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_le_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        break;
                    }
                    case wasm1_code::i64_le_u:
                    {
                        validate_numeric_binary(u8"i64.le_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_le_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        break;
                    }
                    case wasm1_code::i64_ge_s:
                    {
                        validate_numeric_binary(u8"i64.ge_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_ge_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        break;
                    }
                    case wasm1_code::i64_ge_u:
                    {
                        validate_numeric_binary(u8"i64.ge_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_ge_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        break;
                    }
                    case wasm1_code::f32_eq:
                    {
                        validate_numeric_binary(u8"f32.eq", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        br_if_fuse.kind = br_if_fuse_kind::f32_eq;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            // f32.cmp -> i32: output may land in the i32 ring (2D variant), so ensure the i32 ring has a free slot.
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_eq_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        else
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f32_ne:
                    {
                        validate_numeric_binary(u8"f32.ne", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        br_if_fuse.kind = br_if_fuse_kind::f32_ne;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_ne_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        else
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f32_lt:
                    {
                        validate_numeric_binary(u8"f32.lt", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        // `local.get(f32); local.get(f32); f32.lt` is allowed to continue in the conbine state machine,
                        // but we don't have a dedicated `f32.lt(2localget)` opfunc. Flush the pending local.get(s) so the
                        // generic compare sees the correct operands at runtime.
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            flush_conbine_pending();
                        }
                        br_if_fuse.kind = br_if_fuse_kind::f32_lt;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_lt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        else
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f32_gt:
                    {
                        validate_numeric_binary(u8"f32.gt", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        br_if_fuse.kind = br_if_fuse_kind::f32_gt;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_gt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        else
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f32_le:
                    {
                        validate_numeric_binary(u8"f32.le", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        br_if_fuse.kind = br_if_fuse_kind::f32_le;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_le_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        else
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f32_ge:
                    {
                        validate_numeric_binary(u8"f32.ge", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        br_if_fuse.kind = br_if_fuse_kind::f32_ge;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_ge_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        else
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f64_eq:
                    {
                        validate_numeric_binary(u8"f64.eq", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32);
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        br_if_fuse.kind = br_if_fuse_kind::f64_eq;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;
#endif
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_eq_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        else
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f64_ne:
                    {
                        validate_numeric_binary(u8"f64.ne", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_ne_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                        }
                        break;
                    }
                    case wasm1_code::f64_lt:
                    {
                        validate_numeric_binary(u8"f64.lt", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32);

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_convert)
                        {
                            conbine_pending.kind = conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_cmp;
                            break;
                        }
#endif

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        // Enable compare+br_if fusion for:
                        // - `f64.lt; br_if` (branch on `lhs < rhs`), and
                        // - `f64.lt; i32.eqz; br_if` (branch on `!(lhs < rhs)`  including NaN cases).
                        //
                        // The second form is common in LLVM loop codegen and cannot be rewritten into `f64.ge` due to NaN semantics.
                        // We therefore skip the `i32.eqz` opcode and select a dedicated fused `br_if_f64_lt_eqz` opfunc.

                        br_if_fuse.kind = br_if_fuse_kind::f64_lt;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;

                        if(!is_polymorphic && code_curr != code_end)
                        {
                            wasm1_code op1{};  // init
                            ::std::memcpy(::std::addressof(op1), code_curr, sizeof(op1));
                            if(op1 == wasm1_code::i32_eqz)
                            {
                                auto const after_eqz{code_curr + 1};
                                if(after_eqz != code_end)
                                {
                                    wasm1_code op2{};  // init
                                    ::std::memcpy(::std::addressof(op2), after_eqz, sizeof(op2));
                                    if(op2 == wasm1_code::br_if)
                                    {
                                        br_if_fuse.kind = br_if_fuse_kind::f64_lt_eqz;
                                        code_curr = after_eqz;  // skip `i32.eqz`, re-enter at br_if
                                    }
                                }
                            }
                        }
#endif

                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_lt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if)
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_no_fill_if_reachable(1uz);
                                if constexpr(stacktop_enabled)
                                {
                                    if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                                }
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_no_fill_if_reachable(2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        else
                        {
                            if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                            {
                                stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                            }
                            else
                            {
                                stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                            }
                        }
                        break;
                    }
                    case wasm1_code::f64_gt:
                    {
                        validate_numeric_binary(u8"f64.gt", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_gt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                        }
                        break;
                    }
                    case wasm1_code::f64_le:
                    {
                        validate_numeric_binary(u8"f64.le", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_le_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                        }
                        break;
                    }
                    case wasm1_code::f64_ge:
                    {
                        validate_numeric_binary(u8"f64.ge", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_ge_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_after_pop_n_retype_top_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 2uz, curr_operand_stack_value_type::i32);
                        }
                        break;
                    }
                    case wasm1_code::i32_clz:
                    {
                        validate_numeric_unary(u8"i32.clz", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_clz_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_clz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::i32_ctz:
                    {
                        validate_numeric_unary(u8"i32.ctz", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ctz_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_ctz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::i32_popcnt:
                    {
                        validate_numeric_unary(u8"i32.popcnt", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_popcnt_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_popcnt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::i32_add:
                    {
                        validate_numeric_binary(u8"i32.add", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::add>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_step_const)
                        {
                            conbine_pending.kind = conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_add;
                            break;
                        }
# endif
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::mac_after_mul && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            conbine_pending.kind = conbine_pending_kind::mac_after_add;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::rot_xor_add_after_xor_constc)
                        {
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_rot_xor_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, conbine_pending.imm_i32_2);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get2_const_i32_mul)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_mul_imm_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2_const_i32_shl)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_shl_imm_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            // Conbine: `local.get + const + add + local.set/local.tee` (same local).
                            // Lookahead is safe: we do not advance `code_curr`, and `code_curr` already points to the next opcode.
                            // [ ... i32.add ] | next_op ...
                            // [     safe    ] | unsafe
                            //                 ^^ code_curr

                            if(code_curr != code_end)
                            {
                                wasm1_code next_op;  // no init
                                ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));
                                if(next_op == wasm1_code::local_set || next_op == wasm1_code::local_tee)
                                {
                                    wasm_u32 next_local_index{};
                                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                    auto const [next_local_index_next,
                                                next_local_index_err]{::fast_io::parse_by_scan(reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1),
                                                                                               reinterpret_cast<char8_t_const_may_alias_ptr>(code_end),
                                                                                               ::fast_io::mnp::leb128_get(next_local_index))};
                                    (void)next_local_index_next;
                                    if(next_local_index_err == ::fast_io::parse_code::ok && next_local_index < all_local_count)
                                    {
                                        auto const next_local_off{local_offset_from_index(next_local_index)};
                                        if(next_local_off == conbine_pending.off1)
                                        {
                                            conbine_pending.kind = conbine_pending_kind::i32_add_imm_local_settee_same;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            // Conbine: `local.get + const + add` followed by load/store using the computed address.
                            if(code_curr != code_end)
                            {
                                wasm1_code next_op;  // no init
                                ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));

                                if(next_op == wasm1_code::local_get || next_op == wasm1_code::i32_load
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                                   || next_op == wasm1_code::f32_load || next_op == wasm1_code::f64_load
# endif
                                )
                                {
                                    conbine_pending.kind = conbine_pending_kind::local_get_const_i32_add;
                                    break;
                                }
                            }
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            // Conbine: `local.get a; local.get b; i32.add; local.set/local.tee dst`
                            // If the result is immediately stored, fold the whole sequence into one combined opcode to
                            // avoid materializing the add-result on the operand stack.
                            if(code_curr != code_end)
                            {
                                wasm1_code next_op;  // no init
                                ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));

                                if(next_op == wasm1_code::local_set || next_op == wasm1_code::local_tee)
                                {
                                    wasm_u32 next_local_index{};
                                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                    auto const* const next_local_imm_begin{reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1u)};
                                    auto const* const next_local_imm_end{reinterpret_cast<char8_t_const_may_alias_ptr>(code_end)};
                                    auto const [next_local_index_next, next_local_index_err]{
                                        ::fast_io::parse_by_scan(next_local_imm_begin, next_local_imm_end, ::fast_io::mnp::leb128_get(next_local_index))};
                                    (void)next_local_index_next;

                                    if(next_local_index_err == ::fast_io::parse_code::ok && next_local_index < all_local_count &&
                                       local_type_from_index(next_local_index) == curr_operand_stack_value_type::i32)
                                    {
                                        conbine_pending.off3 = local_offset_from_index(next_local_index);
                                        conbine_pending.kind = (next_op == wasm1_code::local_set) ? conbine_pending_kind::i32_add_2localget_local_set
                                                                                                  : conbine_pending_kind::i32_add_2localget_local_tee;
                                        break;
                                    }
                                }
                            }

                            bool fused_spill_and_add{};
                            [[maybe_unused]] ::std::size_t fuse_site{};

                            if constexpr(stacktop_enabled)
                            {
                                // i32_add_2localget pushes 1 result; spill if ring is full.
                                ::std::size_t const bc_before{bytecode.size()};
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);

                                // If a spill opfunc was emitted, rewrite that spill into a fused "spill1 + i32_add_2localget" opfunc and
                                // reuse the would-be `i32_add_2localget` opfunc slot for immediates.
                                if(bytecode.size() != bc_before)
                                {
                                    constexpr bool i32_i64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.i64_stack_top_begin_pos &&
                                                                 CompileOption.i32_stack_top_end_pos == CompileOption.i64_stack_top_end_pos};
                                    constexpr bool i32_f32_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                                 CompileOption.i32_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                                    constexpr bool i32_f64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                                 CompileOption.i32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                                    using wasm_i32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32;
                                    using wasm_i64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64;
                                    using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;
                                    using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;

                                    auto const spilled_vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};

                                    using opfunc_ptr_t =
                                        decltype(translate::get_uwvmint_i32_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    fuse_site = bytecode.size() - sizeof(opfunc_ptr_t);

                                    auto patch_with{[&](auto fused_fptr) constexpr UWVM_THROWS
                                                    {
                                                        ::std::byte tmp[sizeof(fused_fptr)];
                                                        ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                        ::std::memcpy(bytecode.data() + fuse_site, tmp, sizeof(fused_fptr));
                                                        fused_spill_and_add = true;
                                                    }};

                                    if(spilled_vt == curr_operand_stack_value_type::i32)
                                    {
                                        patch_with(translate::get_uwvmint_stacktop_spill1_then_i32_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_i32>(
                                            curr_stacktop,
                                            interpreter_tuple));
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i64)
                                    {
                                        if constexpr(i32_i64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_i32_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_i64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f32)
                                    {
                                        if constexpr(i32_f32_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_i32_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_f32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f64)
                                    {
                                        if constexpr(i32_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_i32_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_f64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                }
                            }

                            if(!fused_spill_and_add)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32); }
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_add_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                auto const before_curr_stacktop{curr_stacktop};
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i32_add_fptr_from_tuple<CompileOption>(before_curr_stacktop, interpreter_tuple));
                                stacktop_commit_pop_n(1uz);
                                codegen_stack_pop_n(1uz);

                                bool fused_add_fill1{};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                                if(stacktop_memory_count != 0uz)
                                {
                                    auto const vt0{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};
                                    if(vt0 == curr_operand_stack_value_type::i32)
                                    {
                                        ::std::size_t const begin0{stacktop_range_begin_pos(vt0)};
                                        ::std::size_t const end0{stacktop_range_end_pos(vt0)};
                                        ::std::size_t const ring0{end0 - begin0};
                                        if(ring0 != 0uz && stacktop_cache_count_for_range(begin0, end0) == ring0 - 1uz)
                                        {
                                            bool stop_after_one{};
                                            if(stacktop_memory_count == 1uz) { stop_after_one = true; }
                                            else
                                            {
                                                auto const vt1{codegen_operand_stack.index_unchecked(stacktop_memory_count - 2uz).type};
                                                if(stacktop_ranges_merged_for(vt0, vt1)) { stop_after_one = true; }
                                                else
                                                {
                                                    ::std::size_t const begin1{stacktop_range_begin_pos(vt1)};
                                                    ::std::size_t const end1{stacktop_range_end_pos(vt1)};
                                                    ::std::size_t const ring1{end1 - begin1};
                                                    if(ring1 != 0uz && stacktop_cache_count_for_range(begin1, end1) == ring1) { stop_after_one = true; }
                                                }
                                            }

                                            if(stop_after_one)
                                            {
                                                using opfunc_ptr_t =
                                                    decltype(translate::get_uwvmint_i32_add_fptr_from_tuple<CompileOption>(before_curr_stacktop,
                                                                                                                           interpreter_tuple));
                                                ::std::size_t const patch_site{bytecode.size() - sizeof(opfunc_ptr_t)};
                                                auto const fused_fptr{
                                                    translate::get_uwvmint_i32_add_then_fill1_fptr_from_tuple<CompileOption>(before_curr_stacktop,
                                                                                                                             interpreter_tuple)};
                                                ::std::byte tmp[sizeof(fused_fptr)];
                                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                ::std::memcpy(bytecode.data() + patch_site, tmp, sizeof(fused_fptr));

                                                --stacktop_memory_count;
                                                ++stacktop_cache_count;
                                                ++stacktop_cache_count_ref_for_vt(vt0);
                                                fused_add_fill1 = true;
                                            }
                                        }
                                    }
                                }
#endif

                                if(!fused_add_fill1) { stacktop_fill_to_canonical(bytecode); }
                                break;
                            }
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_sub:
                    {
                        validate_numeric_binary(u8"i32.sub", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::sub>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_sub_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_sub_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_sub_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_mul:
                    {
                        validate_numeric_binary(u8"i32.mul", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::mul>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::mac_localget3 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            conbine_pending.kind = conbine_pending_kind::mac_after_mul;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get2_const_i32)
                        {
                            conbine_pending.kind = conbine_pending_kind::local_get2_const_i32_mul;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_mul_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_mul_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_div_s:
                    {
                        validate_numeric_binary(u8"i32.div_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_div_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_div_u:
                    {
                        validate_numeric_binary(u8"i32.div_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_div_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_rem_s:
                    {
                        validate_numeric_binary(u8"i32.rem_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            // Conbine: `local.get a; local.get b; i32.rem_s` fused into `i32_rem_s_2localget`.
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rem_s_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_rem_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_rem_u:
                    {
                        validate_numeric_binary(u8"i32.rem_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                            // Heavy: `local.get a; local.get b; i32.rem_u; i32.eqz; br_if <L>` -> local-based `br_if_i32_rem_u_eqz_2localget`.
                            if(!is_polymorphic)
                            {
                                wasm1_code next_op{};  // init
                                if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op)); }
                                if(next_op == wasm1_code::i32_eqz && static_cast<::std::size_t>(code_end - code_curr) >= sizeof(wasm1_code) * 2uz)
                                {
                                    wasm1_code next2_op{};  // init
                                    ::std::memcpy(::std::addressof(next2_op), code_curr + sizeof(wasm1_code), sizeof(next2_op));
                                    if(next2_op == wasm1_code::br_if)
                                    {
                                        conbine_pending.kind = conbine_pending_kind::i32_rem_u_2localget_wait_eqz;
                                        break;
                                    }
                                }
                            }
# endif
                            // Conbine: `local.get a; local.get b; i32.rem_u` fused into `i32_rem_u_2localget`.
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rem_u_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_rem_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_and:
                    {
                        validate_numeric_binary(u8"i32.and", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            // Prefer keeping the existing `i32.and ; br_if` fusion when the and-result is immediately consumed by a branch.
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                            if(next_opbase != wasm1_code::br_if)
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                        CompileOption,
                                        ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::and_>(curr_stacktop, interpreter_tuple));
                                emit_imm_to(bytecode, conbine_pending.imm_i32);
                                conbine_pending.kind = conbine_pending_kind::none;
                                break;
                            }

                            flush_conbine_pending();
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_and_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_and_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }

                        br_if_fuse.kind = br_if_fuse_kind::i32_and_nz;
                        br_if_fuse.site = bytecode.size();
                        br_if_fuse.stacktop_currpos_at_site = curr_stacktop;

                        // else: Combine disabled: no `i32.and ; br_if` fusion tracking.
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_and_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        wasm1_code next_opbase{};  // init
                        if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }
                        if(next_opbase == wasm1_code::br_if) { stacktop_after_pop_n_no_fill_if_reachable(1uz); }
                        else
                        {
                            stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        }

                        break;
                    }
                    case wasm1_code::i32_or:
                    {
                        validate_numeric_binary(u8"i32.or", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::or_>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_or_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_or_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_or_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_xor:
                    {
                        validate_numeric_binary(u8"i32.xor", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::xor_>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::xorshift_after_shr)
                        {
                            conbine_pending.kind = conbine_pending_kind::xorshift_after_xor1;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::xorshift_after_shl)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_xorshift_mix_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            emit_imm_to(bytecode, conbine_pending.imm_i32_2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::rot_xor_add_after_gety)
                        {
                            conbine_pending.kind = conbine_pending_kind::rot_xor_add_after_xor;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::rotl_xor_local_set_after_rotl)
                        {
                            conbine_pending.kind = conbine_pending_kind::rotl_xor_local_set_after_xor;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_i32_xor_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_xor_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_xor_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_shl:
                    {
                        validate_numeric_binary(u8"i32.shl", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::shl>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::xorshift_after_xor1_getx_constb)
                        {
                            conbine_pending.kind = conbine_pending_kind::xorshift_after_shl;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get2_const_i32)
                        {
                            // Lookahead is safe: `validate_numeric_binary` already advanced `code_curr` to the next opcode.
                            // [ ... i32.shl ] | next_op ...
                            // [     safe    ] | unsafe
                            //                 ^^ code_curr
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                            if constexpr(CompileOption.is_tail_call)
                            {
                                wasm1_code next_op{};  // init
                                if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op)); }
                                if(next_op == wasm1_code::i32_load16_u)
                                {
                                    conbine_pending.kind = conbine_pending_kind::u16_copy_scaled_index_after_shl;
                                    break;
                                }
                            }
# endif
                            conbine_pending.kind = conbine_pending_kind::local_get2_const_i32_shl;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_shl_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_shl_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_shr_s:
                    {
                        validate_numeric_binary(u8"i32.shr_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::shr_s>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_shr_s_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_shr_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_shr_u:
                    {
                        validate_numeric_binary(u8"i32.shr_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::shr_u>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::xorshift_pre_shr)
                        {
                            conbine_pending.kind = conbine_pending_kind::xorshift_after_shr;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_shr_u_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_shr_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_rotl:
                    {
                        validate_numeric_binary(u8"i32.rotl", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::rotl>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get2_const_i32)
                        {
                            // Prefer the full `y ^= rotl(x, r)` update-local fusion when followed by `i32.xor; local.set/local.tee`.
                            wasm1_code next_op{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op)); }
                            if(!is_polymorphic && next_op == wasm1_code::i32_xor)
                            {
                                conbine_pending.kind = conbine_pending_kind::rotl_xor_local_set_after_rotl;
                                break;
                            }

                            emit_local_get_typed_to(bytecode, curr_operand_stack_value_type::i32, conbine_pending.off1);
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rotl_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            conbine_pending.kind = conbine_pending_kind::rot_xor_add_after_rotl;
                            break;
                        }
#endif

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_rotl_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_rotr:
                    {
                        validate_numeric_binary(u8"i32.rotr", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::rotr>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_rotr_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_rotr_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_clz:
                    {
                        validate_numeric_unary(u8"i64.clz", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_clz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::i64_ctz:
                    {
                        validate_numeric_unary(u8"i64.ctz", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_ctz_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::i64_popcnt:
                    {
                        validate_numeric_unary(u8"i64.popcnt", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_popcnt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::i64_add:
                    {
                        validate_numeric_binary(u8"i64.add", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::add>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
# ifdef UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::mac_after_mul && conbine_pending.vt == curr_operand_stack_value_type::i64)
                        {
                            conbine_pending.kind = conbine_pending_kind::mac_after_add;
                            break;
                        }
# endif
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::i64)
                        {
                            bool fused_spill_and_add{};
                            [[maybe_unused]] ::std::size_t fuse_site{};

                            if constexpr(stacktop_enabled)
                            {
                                ::std::size_t const bc_before{bytecode.size()};
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64);

                                if(bytecode.size() != bc_before)
                                {
                                    constexpr bool i32_i64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.i64_stack_top_begin_pos &&
                                                                 CompileOption.i32_stack_top_end_pos == CompileOption.i64_stack_top_end_pos};
                                    constexpr bool i64_f32_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f32_stack_top_begin_pos &&
                                                                 CompileOption.i64_stack_top_end_pos == CompileOption.f32_stack_top_end_pos};
                                    constexpr bool i64_f64_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                                 CompileOption.i64_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                                    using wasm_i32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32;
                                    using wasm_i64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64;
                                    using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;
                                    using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;

                                    auto const spilled_vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};

                                    using opfunc_ptr_t =
                                        decltype(translate::get_uwvmint_i64_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    fuse_site = bytecode.size() - sizeof(opfunc_ptr_t);

                                    auto patch_with{[&](auto fused_fptr) constexpr UWVM_THROWS
                                                    {
                                                        ::std::byte tmp[sizeof(fused_fptr)];
                                                        ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                        ::std::memcpy(bytecode.data() + fuse_site, tmp, sizeof(fused_fptr));
                                                        fused_spill_and_add = true;
                                                    }};

                                    if(spilled_vt == curr_operand_stack_value_type::i64)
                                    {
                                        patch_with(translate::get_uwvmint_stacktop_spill1_then_i64_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_i64>(
                                            curr_stacktop,
                                            interpreter_tuple));
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i32)
                                    {
                                        if constexpr(i32_i64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_i64_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_i32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f32)
                                    {
                                        if constexpr(i64_f32_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_i64_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_f32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f64)
                                    {
                                        if constexpr(i64_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_i64_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_f64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                }
                            }

                            if(!fused_spill_and_add)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i64_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i64); }
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_add_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                auto const before_curr_stacktop{curr_stacktop};
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_i64_add_fptr_from_tuple<CompileOption>(before_curr_stacktop, interpreter_tuple));
                                stacktop_commit_pop_n(1uz);
                                codegen_stack_pop_n(1uz);

                                bool fused_add_fill1{};

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                                if(stacktop_memory_count != 0uz)
                                {
                                    auto const vt0{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};
                                    if(vt0 == curr_operand_stack_value_type::i64)
                                    {
                                        ::std::size_t const begin0{stacktop_range_begin_pos(vt0)};
                                        ::std::size_t const end0{stacktop_range_end_pos(vt0)};
                                        ::std::size_t const ring0{end0 - begin0};
                                        if(ring0 != 0uz && stacktop_cache_count_for_range(begin0, end0) == ring0 - 1uz)
                                        {
                                            bool stop_after_one{};
                                            if(stacktop_memory_count == 1uz) { stop_after_one = true; }
                                            else
                                            {
                                                auto const vt1{codegen_operand_stack.index_unchecked(stacktop_memory_count - 2uz).type};
                                                if(stacktop_ranges_merged_for(vt0, vt1)) { stop_after_one = true; }
                                                else
                                                {
                                                    ::std::size_t const begin1{stacktop_range_begin_pos(vt1)};
                                                    ::std::size_t const end1{stacktop_range_end_pos(vt1)};
                                                    ::std::size_t const ring1{end1 - begin1};
                                                    if(ring1 != 0uz && stacktop_cache_count_for_range(begin1, end1) == ring1) { stop_after_one = true; }
                                                }
                                            }

                                            if(stop_after_one)
                                            {
                                                using opfunc_ptr_t =
                                                    decltype(translate::get_uwvmint_i64_add_fptr_from_tuple<CompileOption>(before_curr_stacktop,
                                                                                                                           interpreter_tuple));
                                                ::std::size_t const patch_site{bytecode.size() - sizeof(opfunc_ptr_t)};
                                                auto const fused_fptr{
                                                    translate::get_uwvmint_i64_add_then_fill1_fptr_from_tuple<CompileOption>(before_curr_stacktop,
                                                                                                                             interpreter_tuple)};
                                                ::std::byte tmp[sizeof(fused_fptr)];
                                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                ::std::memcpy(bytecode.data() + patch_site, tmp, sizeof(fused_fptr));

                                                --stacktop_memory_count;
                                                ++stacktop_cache_count;
                                                ++stacktop_cache_count_ref_for_vt(vt0);
                                                fused_add_fill1 = true;
                                            }
                                        }
                                    }
                                }
#endif

                                if(!fused_add_fill1) { stacktop_fill_to_canonical(bytecode); }
                                break;
                            }
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_sub:
                    {
                        validate_numeric_binary(u8"i64.sub", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::sub>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_sub_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_mul:
                    {
                        validate_numeric_binary(u8"i64.mul", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::mul>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::mac_localget3 && conbine_pending.vt == curr_operand_stack_value_type::i64)
                        {
                            conbine_pending.kind = conbine_pending_kind::mac_after_mul;
                            break;
                        }
#endif

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_div_s:
                    {
                        validate_numeric_binary(u8"i64.div_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_div_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_div_u:
                    {
                        validate_numeric_binary(u8"i64.div_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_div_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_rem_s:
                    {
                        validate_numeric_binary(u8"i64.rem_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_rem_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_rem_u:
                    {
                        validate_numeric_binary(u8"i64.rem_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_rem_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_and:
                    {
                        validate_numeric_binary(u8"i64.and", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::and_>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_i64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i64_and_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_and_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_or:
                    {
                        validate_numeric_binary(u8"i64.or", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::or_>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_or_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_xor:
                    {
                        validate_numeric_binary(u8"i64.xor", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::xor_>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_xor_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_shl:
                    {
                        validate_numeric_binary(u8"i64.shl", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::shl>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_shl_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_shr_s:
                    {
                        validate_numeric_binary(u8"i64.shr_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::shr_s>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_shr_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_shr_u:
                    {
                        validate_numeric_binary(u8"i64.shr_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::shr_u>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_shr_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_rotl:
                    {
                        validate_numeric_binary(u8"i64.rotl", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::rotl>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_rotl_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i64_rotr:
                    {
                        validate_numeric_binary(u8"i64.rotr", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#ifdef UWVM_ENABLE_UWVM_INT_COMBINE_OPS
                        if(conbine_pending.kind == conbine_pending_kind::const_i64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_i64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::int_binop::rotr>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_i64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_rotr_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f32_abs:
                    {
                        validate_numeric_unary(u8"f32.abs", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_abs_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_abs_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f32_neg:
                    {
                        validate_numeric_unary(u8"f32.neg", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_neg_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_neg_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f32_ceil:
                    {
                        validate_numeric_unary(u8"f32.ceil", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_ceil_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        break;
                    }
                    case wasm1_code::f32_floor:
                    {
                        validate_numeric_unary(u8"f32.floor", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_floor_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        break;
                    }
                    case wasm1_code::f32_trunc:
                    {
                        validate_numeric_unary(u8"f32.trunc", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_trunc_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        break;
                    }
                    case wasm1_code::f32_nearest:
                    {
                        validate_numeric_unary(u8"f32.nearest", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_nearest_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f32_sqrt:
                    {
                        validate_numeric_unary(u8"f32.sqrt", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_sqrt_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_sqrt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f32_add:
                    {
                        validate_numeric_binary(u8"f32.add", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::add>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::mac_after_mul && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            conbine_pending.kind = conbine_pending_kind::mac_after_add;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_mul_2localget_local3 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_mul_add_3localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_2mul_after_second_mul &&
                           conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_f32_mul_add_2mul_4localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_f32_2mul_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            emit_imm_to(bytecode, conbine_pending.off4);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            // Conbine (heavy): `local.get a; local.get b; f32.add; local.set/local.tee dst`
                            if(code_curr != code_end)
                            {
                                wasm1_code next_op;  // no init
                                ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));

                                if(next_op == wasm1_code::local_set || next_op == wasm1_code::local_tee)
                                {
                                    wasm_u32 next_local_index{};
                                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                    auto const* const next_local_imm_begin{reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1u)};
                                    auto const* const next_local_imm_end{reinterpret_cast<char8_t_const_may_alias_ptr>(code_end)};
                                    auto const [next_local_index_next, next_local_index_err]{
                                        ::fast_io::parse_by_scan(next_local_imm_begin, next_local_imm_end, ::fast_io::mnp::leb128_get(next_local_index))};
                                    (void)next_local_index_next;

                                    if(next_local_index_err == ::fast_io::parse_code::ok && next_local_index < all_local_count &&
                                       local_type_from_index(next_local_index) == curr_operand_stack_value_type::f32)
                                    {
                                        conbine_pending.off3 = local_offset_from_index(next_local_index);
                                        conbine_pending.kind = (next_op == wasm1_code::local_set) ? conbine_pending_kind::f32_add_2localget_local_set
                                                                                                  : conbine_pending_kind::f32_add_2localget_local_tee;
                                        break;
                                    }
                                }
                            }

                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_add_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f32_sub:
                    {
                        validate_numeric_binary(u8"f32.sub", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::sub>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::const_f32_localget)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_sub_from_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_mul_2localget_local3 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_mul_sub_3localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_2mul_after_second_mul &&
                           conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_mul_sub_2mul_4localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            emit_imm_to(bytecode, conbine_pending.off4);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_sub_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_sub_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f32_mul:
                    {
                        validate_numeric_binary(u8"f32.mul", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::mul>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::mac_localget3 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            conbine_pending.kind = conbine_pending_kind::mac_after_mul;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_2mul_wait_second_mul && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            conbine_pending.kind = conbine_pending_kind::float_2mul_after_second_mul;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            conbine_pending.kind = conbine_pending_kind::float_mul_2localget;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_mul_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f32_div:
                    {
                        validate_numeric_binary(u8"f32.div", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::div>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::const_f32_localget)
                        {
                            wasm1_code next_opbase{};  // init
                            if(code_curr != code_end) { ::std::memcpy(::std::addressof(next_opbase), code_curr, sizeof(next_opbase)); }

                            if(next_opbase == wasm1_code::local_tee)
                            {
                                conbine_pending.kind = conbine_pending_kind::f32_div_from_imm_localtee_wait;

                                break;
                            }

                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_div_from_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_div_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_div_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f32_min:
                    {
                        validate_numeric_binary(u8"f32.min", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::min>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_min_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_min_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_min_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f32_max:
                    {
                        validate_numeric_binary(u8"f32.max", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::max>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_max_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f32_max_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_max_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f32_copysign:
                    {
                        validate_numeric_binary(u8"f32.copysign", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f32)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f32_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::copysign>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_copysign_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f64_abs:
                    {
                        validate_numeric_unary(u8"f64.abs", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_abs_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_abs_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f64_neg:
                    {
                        validate_numeric_unary(u8"f64.neg", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_neg_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_neg_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f64_ceil:
                    {
                        validate_numeric_unary(u8"f64.ceil", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_ceil_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f64_floor:
                    {
                        validate_numeric_unary(u8"f64.floor", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_floor_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f64_trunc:
                    {
                        validate_numeric_unary(u8"f64.trunc", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_trunc_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f64_nearest:
                    {
                        validate_numeric_unary(u8"f64.nearest", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_nearest_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f64_sqrt:
                    {
                        validate_numeric_unary(u8"f64.sqrt", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_sqrt_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_sqrt_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        break;
                    }
                    case wasm1_code::f64_add:
                    {
                        validate_numeric_binary(u8"f64.add", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::add>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::mac_after_mul && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            conbine_pending.kind = conbine_pending_kind::mac_after_add;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_mul_2localget_local3 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_mul_add_3localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_2mul_after_second_mul &&
                           conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            if constexpr(CompileOption.is_tail_call)
                            {
                                emit_opfunc_to(
                                    bytecode,
                                    translate::get_uwvmint_f64_mul_add_2mul_4localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            else
                            {
                                emit_opfunc_to(bytecode, translate::get_uwvmint_f64_2mul_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            emit_imm_to(bytecode, conbine_pending.off4);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            // Conbine (heavy): `local.get a; local.get b; f64.add; local.set/local.tee dst`
                            if(code_curr != code_end)
                            {
                                wasm1_code next_op;  // no init
                                ::std::memcpy(::std::addressof(next_op), code_curr, sizeof(next_op));

                                if(next_op == wasm1_code::local_set || next_op == wasm1_code::local_tee)
                                {
                                    wasm_u32 next_local_index{};
                                    using char8_t_const_may_alias_ptr UWVM_GNU_MAY_ALIAS = char8_t const*;
                                    auto const* const next_local_imm_begin{reinterpret_cast<char8_t_const_may_alias_ptr>(code_curr + 1u)};
                                    auto const* const next_local_imm_end{reinterpret_cast<char8_t_const_may_alias_ptr>(code_end)};
                                    auto const [next_local_index_next, next_local_index_err]{
                                        ::fast_io::parse_by_scan(next_local_imm_begin, next_local_imm_end, ::fast_io::mnp::leb128_get(next_local_index))};
                                    (void)next_local_index_next;

                                    if(next_local_index_err == ::fast_io::parse_code::ok && next_local_index < all_local_count &&
                                       local_type_from_index(next_local_index) == curr_operand_stack_value_type::f64)
                                    {
                                        conbine_pending.off3 = local_offset_from_index(next_local_index);
                                        conbine_pending.kind = (next_op == wasm1_code::local_set) ? conbine_pending_kind::f64_add_2localget_local_set
                                                                                                  : conbine_pending_kind::f64_add_2localget_local_tee;
                                        break;
                                    }
                                }
                            }

                            bool fused_spill_and_add{};
                            [[maybe_unused]] ::std::size_t fuse_site{};

                            if constexpr(stacktop_enabled)
                            {
                                ::std::size_t const bc_before{bytecode.size()};
                                stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);

                                if(bytecode.size() != bc_before)
                                {
                                    constexpr bool f32_f64_merge{CompileOption.f32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                                 CompileOption.f32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};
                                    constexpr bool i32_f64_merge{CompileOption.i32_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                                 CompileOption.i32_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};
                                    constexpr bool i64_f64_merge{CompileOption.i64_stack_top_begin_pos == CompileOption.f64_stack_top_begin_pos &&
                                                                 CompileOption.i64_stack_top_end_pos == CompileOption.f64_stack_top_end_pos};

                                    using wasm_i32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i32;
                                    using wasm_i64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_i64;
                                    using wasm_f32 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f32;
                                    using wasm_f64 = ::uwvm2::parser::wasm::standard::wasm1::type::wasm_f64;

                                    auto const spilled_vt{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};

                                    using opfunc_ptr_t =
                                        decltype(translate::get_uwvmint_f64_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                                    fuse_site = bytecode.size() - sizeof(opfunc_ptr_t);

                                    auto patch_with{[&](auto fused_fptr) constexpr UWVM_THROWS
                                                    {
                                                        ::std::byte tmp[sizeof(fused_fptr)];
                                                        ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                        ::std::memcpy(bytecode.data() + fuse_site, tmp, sizeof(fused_fptr));
                                                        fused_spill_and_add = true;
                                                    }};

                                    if(spilled_vt == curr_operand_stack_value_type::f64)
                                    {
                                        patch_with(translate::get_uwvmint_stacktop_spill1_then_f64_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_f64>(
                                            curr_stacktop,
                                            interpreter_tuple));
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::f32)
                                    {
                                        if constexpr(f32_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_f64_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_f32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i32)
                                    {
                                        if constexpr(i32_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_f64_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_i32>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                    else if(spilled_vt == curr_operand_stack_value_type::i64)
                                    {
                                        if constexpr(i64_f64_merge)
                                        {
                                            patch_with(
                                                translate::get_uwvmint_stacktop_spill1_then_f64_add_2localget_typed_fptr_from_tuple<CompileOption, wasm_i64>(
                                                    curr_stacktop,
                                                    interpreter_tuple));
                                        }
                                    }
                                }
                            }

                            if(!fused_spill_and_add)
                            {
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_add_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            }
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            if constexpr(stacktop_enabled) { stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64); }
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_add_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);

                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic)
                            {
                                auto const before_curr_stacktop{curr_stacktop};
                                emit_opfunc_to(bytecode,
                                               translate::get_uwvmint_f64_add_fptr_from_tuple<CompileOption>(before_curr_stacktop, interpreter_tuple));
                                stacktop_commit_pop_n(1uz);
                                codegen_stack_pop_n(1uz);

                                bool fused_add_fill1{};

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                                if(stacktop_memory_count != 0uz)
                                {
                                    auto const vt0{codegen_operand_stack.index_unchecked(stacktop_memory_count - 1uz).type};
                                    if(vt0 == curr_operand_stack_value_type::f64)
                                    {
                                        ::std::size_t const begin0{stacktop_range_begin_pos(vt0)};
                                        ::std::size_t const end0{stacktop_range_end_pos(vt0)};
                                        ::std::size_t const ring0{end0 - begin0};
                                        if(ring0 != 0uz && stacktop_cache_count_for_range(begin0, end0) == ring0 - 1uz)
                                        {
                                            bool stop_after_one{};
                                            if(stacktop_memory_count == 1uz) { stop_after_one = true; }
                                            else
                                            {
                                                auto const vt1{codegen_operand_stack.index_unchecked(stacktop_memory_count - 2uz).type};
                                                if(stacktop_ranges_merged_for(vt0, vt1)) { stop_after_one = true; }
                                                else
                                                {
                                                    ::std::size_t const begin1{stacktop_range_begin_pos(vt1)};
                                                    ::std::size_t const end1{stacktop_range_end_pos(vt1)};
                                                    ::std::size_t const ring1{end1 - begin1};
                                                    if(ring1 != 0uz && stacktop_cache_count_for_range(begin1, end1) == ring1) { stop_after_one = true; }
                                                }
                                            }

                                            if(stop_after_one)
                                            {
                                                using opfunc_ptr_t =
                                                    decltype(translate::get_uwvmint_f64_add_fptr_from_tuple<CompileOption>(before_curr_stacktop,
                                                                                                                           interpreter_tuple));
                                                ::std::size_t const patch_site{bytecode.size() - sizeof(opfunc_ptr_t)};
                                                auto const fused_fptr{
                                                    translate::get_uwvmint_f64_add_then_fill1_fptr_from_tuple<CompileOption>(before_curr_stacktop,
                                                                                                                             interpreter_tuple)};
                                                ::std::byte tmp[sizeof(fused_fptr)];
                                                ::std::memcpy(tmp, ::std::addressof(fused_fptr), sizeof(fused_fptr));
                                                ::std::memcpy(bytecode.data() + patch_site, tmp, sizeof(fused_fptr));

                                                --stacktop_memory_count;
                                                ++stacktop_cache_count;
                                                ++stacktop_cache_count_ref_for_vt(vt0);
                                                fused_add_fill1 = true;
                                            }
                                        }
                                    }
                                }
#endif

                                if(!fused_add_fill1) { stacktop_fill_to_canonical(bytecode); }
                                break;
                            }
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_add_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f64_sub:
                    {
                        validate_numeric_binary(u8"f64.sub", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::sub>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_mul_2localget_local3 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_mul_sub_3localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_2mul_after_second_mul &&
                           conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_mul_sub_2mul_4localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            emit_imm_to(bytecode, conbine_pending.off3);
                            emit_imm_to(bytecode, conbine_pending.off4);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_sub_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_sub_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f64_mul:
                    {
                        validate_numeric_binary(u8"f64.mul", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::mul>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::mac_localget3 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            conbine_pending.kind = conbine_pending_kind::mac_after_mul;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::float_2mul_wait_second_mul && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            conbine_pending.kind = conbine_pending_kind::float_2mul_after_second_mul;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            conbine_pending.kind = conbine_pending_kind::float_mul_2localget;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_mul_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_mul_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);
                        break;
                    }
                    case wasm1_code::f64_div:
                    {
                        validate_numeric_binary(u8"f64.div", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::div>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_div_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_div_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f64_min:
                    {
                        validate_numeric_binary(u8"f64.min", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::min>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_min_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_min_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_min_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f64_max:
                    {
                        validate_numeric_binary(u8"f64.max", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::max>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get2 && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f64_max_2localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.off2);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
                        if(conbine_pending.kind == conbine_pending_kind::local_get_const_f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_f64_max_imm_localget_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f64);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_max_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::f64_copysign:
                    {
                        validate_numeric_binary(u8"f64.copysign", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::const_f64)
                        {
                            emit_opfunc_to(
                                bytecode,
                                translate::get_uwvmint_f64_binop_imm_stack_fptr_from_tuple<
                                    CompileOption,
                                    ::uwvm2::runtime::compiler::uwvm_int::optable::numeric_details::float_binop::copysign>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.imm_f64);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_copysign_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        stacktop_after_pop_n_if_reachable(bytecode, 1uz);

                        break;
                    }
                    case wasm1_code::i32_wrap_i64:
                    {
                        validate_numeric_unary(u8"i32.wrap_i64", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_wrap_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                        }

                        break;
                    }
                    case wasm1_code::i32_trunc_f32_s:
                    {
                        validate_numeric_unary(u8"i32.trunc_f32_s", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_from_f32_trunc_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif
                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_trunc_f32_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }

                        break;
                    }
                    case wasm1_code::i32_trunc_f32_u:
                    {
                        validate_numeric_unary(u8"i32.trunc_f32_u", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_from_f32_trunc_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;

                            break;
                        }
#endif

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_trunc_f32_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }

                        break;
                    }
                    case wasm1_code::i32_trunc_f64_s:
                    {
                        validate_numeric_unary(u8"i32.trunc_f64_s", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_from_f64_trunc_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_trunc_f64_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }

                        break;
                    }
                    case wasm1_code::i32_trunc_f64_u:
                    {
                        validate_numeric_unary(u8"i32.trunc_f64_u", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::f64)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                            emit_opfunc_to(bytecode,
                                           translate::get_uwvmint_i32_from_f64_trunc_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::i32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_trunc_f64_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }

                        break;
                    }
                    case wasm1_code::i64_extend_i32_s:
                    {
                        validate_numeric_unary(u8"i64.extend_i32_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_extend_i32_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }

                        break;
                    }
                    case wasm1_code::i64_extend_i32_u:
                    {
                        validate_numeric_unary(u8"i64.extend_i32_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;
                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_extend_i32_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                        if constexpr(stacktop_enabled)
                        {
                            if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                        }

                        break;
                    }
                    case wasm1_code::i64_trunc_f32_s:
                    {
                        validate_numeric_unary(u8"i64.trunc_f32_s", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_trunc_f32_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i64);
                        }

                        break;
                    }
                    case wasm1_code::i64_trunc_f32_u:
                    {
                        validate_numeric_unary(u8"i64.trunc_f32_u", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_trunc_f32_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i64);
                        }

                        break;
                    }
                    case wasm1_code::i64_trunc_f64_s:
                    {
                        validate_numeric_unary(u8"i64.trunc_f64_s", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_trunc_f64_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i64);
                        }

                        break;
                    }
                    case wasm1_code::i64_trunc_f64_u:
                    {
                        validate_numeric_unary(u8"i64.trunc_f64_u", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_trunc_f64_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i64);
                        }

                        break;
                    }
                    case wasm1_code::f32_convert_i32_s:
                    {
                        validate_numeric_unary(u8"f32.convert_i32_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_from_i32_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_convert_i32_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f32);
                        }

                        break;
                    }
                    case wasm1_code::f32_convert_i32_u:
                    {
                        validate_numeric_unary(u8"f32.convert_i32_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(conbine_pending.kind == conbine_pending_kind::local_get && conbine_pending.vt == curr_operand_stack_value_type::i32)
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                            emit_opfunc_to(bytecode, translate::get_uwvmint_f32_from_i32_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));
                            emit_imm_to(bytecode, conbine_pending.off1);
                            stacktop_commit_push1_typed_if_reachable(curr_operand_stack_value_type::f32);
                            conbine_pending.kind = conbine_pending_kind::none;
                            break;
                        }
#endif

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_convert_i32_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f32);
                        }

                        break;
                    }
                    case wasm1_code::f32_convert_i64_s:
                    {
                        validate_numeric_unary(u8"f32.convert_i64_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_convert_i64_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f32);
                        }

                        break;
                    }
                    case wasm1_code::f32_convert_i64_u:
                    {
                        validate_numeric_unary(u8"f32.convert_i64_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_convert_i64_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f32);
                        }

                        break;
                    }
                    case wasm1_code::f32_demote_f64:
                    {
                        validate_numeric_unary(u8"f32.demote_f64", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_demote_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::f32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f32);
                        }

                        break;
                    }
                    case wasm1_code::f64_convert_i32_s:
                    {
                        validate_numeric_unary(u8"f64.convert_i32_s", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_convert_i32_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f64);
                        }

                        break;
                    }
                    case wasm1_code::f64_convert_i32_u:
                    {
                        validate_numeric_unary(u8"f64.convert_i32_u", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

#if defined(UWVM_ENABLE_UWVM_INT_COMBINE_OPS) && defined(UWVM_ENABLE_UWVM_INT_HEAVY_COMBINE_OPS)
                        if(!is_polymorphic && conbine_pending.kind == conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_tee)
                        {
                            conbine_pending.kind = conbine_pending_kind::for_i32_inc_f64_lt_u_eqz_after_convert;
                            break;
                        }
#endif

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_convert_i32_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f64);
                        }

                        break;
                    }
                    case wasm1_code::f64_convert_i64_s:
                    {
                        validate_numeric_unary(u8"f64.convert_i64_s", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_convert_i64_s_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f64);
                        }

                        break;
                    }
                    case wasm1_code::f64_convert_i64_u:
                    {
                        validate_numeric_unary(u8"f64.convert_i64_u", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_convert_i64_u_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f64);
                        }

                        break;
                    }
                    case wasm1_code::f64_promote_f32:
                    {
                        validate_numeric_unary(u8"f64.promote_f32", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_promote_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::f64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f64);
                        }

                        break;
                    }
                    case wasm1_code::i32_reinterpret_f32:
                    {
                        validate_numeric_unary(u8"i32.reinterpret_f32", curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i32_reinterpret_f32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f32, curr_operand_stack_value_type::i32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i32);
                        }

                        break;
                    }
                    case wasm1_code::i64_reinterpret_f64:
                    {
                        validate_numeric_unary(u8"i64.reinterpret_f64", curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::i64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::i64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_i64_reinterpret_f64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::f64, curr_operand_stack_value_type::i64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::i64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::i64);
                        }

                        break;
                    }
                    case wasm1_code::f32_reinterpret_i32:
                    {
                        validate_numeric_unary(u8"f32.reinterpret_i32", curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f32) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f32);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f32_reinterpret_i32_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i32, curr_operand_stack_value_type::f32))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f32); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f32);
                        }

                        break;
                    }
                    case wasm1_code::f64_reinterpret_i64:
                    {
                        validate_numeric_unary(u8"f64.reinterpret_i64", curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64);
                        namespace translate = ::uwvm2::runtime::compiler::uwvm_int::optable::translate;

                        if constexpr(stacktop_enabled_for_vt(curr_operand_stack_value_type::f64) &&
                                     !stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64))
                        {
                            stacktop_prepare_push1_if_reachable(bytecode, curr_operand_stack_value_type::f64);
                        }

                        emit_opfunc_to(bytecode, translate::get_uwvmint_f64_reinterpret_i64_fptr_from_tuple<CompileOption>(curr_stacktop, interpreter_tuple));

                        if constexpr(stacktop_ranges_merged_for(curr_operand_stack_value_type::i64, curr_operand_stack_value_type::f64))
                        {
                            if constexpr(stacktop_enabled)
                            {
                                if(!is_polymorphic) { codegen_stack_set_top(curr_operand_stack_value_type::f64); }
                            }
                        }
                        else
                        {
                            stacktop_after_pop_n_push1_typed_if_reachable(bytecode, 1uz, curr_operand_stack_value_type::f64);
                        }

                        break;
                    }
                    [[unlikely]] default:
                    {
                        err.err_curr = code_curr;
                        err.err_selectable.u8 = static_cast<::std::uint_least8_t>(curr_opbase);
                        err.err_code = code_validation_error_code::illegal_opbase;
                        ::uwvm2::parser::wasm::base::throw_wasm_parse_code(::fast_io::parse_code::invalid);
                    }
                }

                if(runtime_log_on) [[unlikely]]
                {
                    runtime_log_wasm_op_state(u8"wasm.op.after",
                                              curr_opbase,
                                              op_begin,
                                              bytecode_before,
                                              thunks_before,
                                              opfunc_main_before,
                                              opfunc_thunk_before);
                }

                if(finished_current_func) { break; }
            }
        }

        // Fill local-defined call-info records (used by the runtime call bridge fast-path).
        if(local_func_count != 0uz)
        {
            auto const abi_bytes{[](wasm_value_type t) constexpr noexcept -> ::std::size_t
                                 {
                                     switch(t)
                                     {
                                         case wasm_value_type::i32:
                                         case wasm_value_type::f32: return 4uz;
                                         case wasm_value_type::i64:
                                         case wasm_value_type::f64:
                                             return 8uz;
                                         [[unlikely]] default:
                                             return 0uz;
                                     }
                                 }};

            for(::std::size_t i{}; i != local_func_count; ++i)
            {
                auto& info{storage.local_defined_call_info.index_unchecked(i)};
                info.runtime_func = ::std::addressof(curr_module.local_defined_function_vec_storage.index_unchecked(i));
                info.compiled_func = ::std::addressof(storage.local_funcs.index_unchecked(i));

                auto const* const ft{curr_module.local_defined_function_vec_storage.index_unchecked(i).function_type_ptr};
                if(ft == nullptr) [[unlikely]] { ::fast_io::fast_terminate(); }

                ::std::size_t para_bytes{};
                for(auto it{ft->parameter.begin}; it != ft->parameter.end; ++it)
                {
                    auto const add{abi_bytes(*it)};
                    if(add == 0uz) [[unlikely]] { ::fast_io::fast_terminate(); }
                    if(add > (::std::numeric_limits<::std::size_t>::max() - para_bytes)) [[unlikely]] { ::fast_io::fast_terminate(); }
                    para_bytes += add;
                }

                ::std::size_t res_bytes{};
                for(auto it{ft->result.begin}; it != ft->result.end; ++it)
                {
                    auto const add{abi_bytes(*it)};
                    if(add == 0uz) [[unlikely]] { ::fast_io::fast_terminate(); }
                    if(add > (::std::numeric_limits<::std::size_t>::max() - res_bytes)) [[unlikely]] { ::fast_io::fast_terminate(); }
                    res_bytes += add;
                }

                info.param_bytes = para_bytes;
                info.result_bytes = res_bytes;

                auto const m{details::match_trivial_call_inline_body(curr_module.local_defined_function_vec_storage.index_unchecked(i).wasm_code_ptr)};
                using trivial_kind_t = ::uwvm2::runtime::compiler::uwvm_int::optable::trivial_defined_call_kind;
                if(m.kind != trivial_kind_t::none)
                {
                    auto const param_n{static_cast<::std::size_t>(ft->parameter.end - ft->parameter.begin)};
                    auto const res_n{static_cast<::std::size_t>(ft->result.end - ft->result.begin)};
                    auto const is_i32{[](wasm_value_type t) constexpr noexcept { return t == wasm_value_type::i32; }};

                    bool ok{};
                    switch(m.kind)
                    {
                        case trivial_kind_t::param0_i32:
                            ok = (res_n == 1uz) && is_i32(ft->result.begin[0]) && (param_n >= 1uz) && is_i32(ft->parameter.begin[0]);
                            break;
                        case trivial_kind_t::add_const_i32:
                            ok = (param_n == 1uz) && (res_n == 1uz) && is_i32(ft->parameter.begin[0]) && is_i32(ft->result.begin[0]);
                            break;
                        case trivial_kind_t::mul_add_const_i32:
                            ok = (param_n == 1uz) && (res_n == 1uz) && is_i32(ft->parameter.begin[0]) && is_i32(ft->result.begin[0]);
                            break;
                        case trivial_kind_t::xor_i32:
                            ok = (param_n == 2uz) && (res_n == 1uz) && is_i32(ft->parameter.begin[0]) && is_i32(ft->parameter.begin[1]) &&
                                 is_i32(ft->result.begin[0]);
                            break;
                        case trivial_kind_t::xor_add_const_i32:
                            ok = (param_n == 2uz) && (res_n == 1uz) && is_i32(ft->parameter.begin[0]) && is_i32(ft->parameter.begin[1]) &&
                                 is_i32(ft->result.begin[0]);
                            break;
                        case trivial_kind_t::sub_or_const_i32:
                            ok = (param_n == 2uz) && (res_n == 1uz) && is_i32(ft->parameter.begin[0]) && is_i32(ft->parameter.begin[1]) &&
                                 is_i32(ft->result.begin[0]);
                            break;
                        case trivial_kind_t::sum8_xor_const_i32:
                        {
                            if(param_n == 8uz && res_n == 1uz && is_i32(ft->result.begin[0]))
                            {
                                ok = true;
                                for(::std::size_t j{}; j != 8uz; ++j)
                                {
                                    if(!is_i32(ft->parameter.begin[j]))
                                    {
                                        ok = false;
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                        [[unlikely]] default:
                            break;
                    }

                    if(ok)
                    {
                        info.trivial_kind = m.kind;
                        info.trivial_imm = m.imm;
                        info.trivial_imm2 = m.imm2;
                    }
                }
            }
        }

        return storage;
    }
}

#ifndef UWVM_MODULE
// macro
# include <uwvm2/utils/macro/pop_macros.h>
#endif
